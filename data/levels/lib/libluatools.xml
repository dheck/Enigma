<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libluatools"/>
      <el:version el:score="1" el:release="1" el:revision="3" el:status="released"/>
      <el:author  el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.00">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

---------------------------------------------------------------------
-- libluatools holds some general utilities for working with Lua.
-- It includes functions for deep-copying tables, combining tables,
-- and shuffling tables, a function to calculate Manhattan
-- distances and a wrapper for Lua's modulo-function, which has
-- been renamed from math.mod to math.fmod.
---------------------------------------------------------------------

luatools = {}

---------------------------------------------------------------------
--  TABLE  HANDLING
---------------------------------------------------------------------

-- deep_copy returns a copy of SOURCE, where table entries are
-- not copied as memory references, but complete ("deep copy").
-- Metatables are transfered, but not deep-copied.
function luatools.deep_copy(source)
 if type(source) ~= "table" then
   return source
 end
 local dest = {}
 for k, v in pairs(source) do
   if type(source[k]) == "table" then
     dest[k] = luatools.deep_copy(source[k])
   else
     dest[k] = source[k]
   end
 end
 setmetatable(dest, getmetatable(source))
 return dest
end 

-- combine_tables returns a table consisting of all entries of the
-- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
-- {T1, T2, T3, ...}. The result of combine_tables will be a new
-- table with all entries of T1, T2, T3 etc., with the first table
-- having highest priority etc.
function luatools.combine_tables(arg1, ...)
  local args = {arg1, ...}
  if table.getn(args) == 1 then
    args = arg1
  end
  if type(args) ~= "table" then
    error("combine_tables: None or only one argument, and it's not a table!")
  end
  local result = {}
  for j,t in pairs(args) do
    if type(t) ~= "table" then
      error("combine_tables: Main table does not consist of tables alone!")
    end
    for k,v in pairs(t) do
      result[k] = result[k] or luatools.deep_copy(v)
    end
  end
  return result
end

-- shuffle_table resorts the table T randomly. Note that only those entries
-- of T can be sorted, that are indexed with integers from 1 to table.getn(T).
-- No return value, the table itself is shuffled.
function luatools.shuffle_table(t)
  if table.getn(t) < 2 then
    return
  end
  for n = table.getn(t), 2, -1 do
    local m = math.random(n)
    t[n], t[m] = t[m], t[n]
  end
end

-- print_table uses the print command to print all
-- entries of a table, one table per line.
-- It should be used for debug reasons only.
-- PREFIX can be a string to be put in front of each
-- line of the output, in case you need to distinguish
-- several outputs from each other.
-- print_table is recursive, i.e. a table with table
-- as entries will call print_table again. To avoid
-- infinite loops, DEPTH is used as additional argument.
-- Don't use it in levels. If you want to suppress
-- the recursive function, use DEPTH = -1.
function luatools.print_table(t, prefix, depth)
  if type(t) ~= "table" then
    print("print_table: Argument is of type "..type(t)..", not table.")
    return
  end
  for key, value in pairs(t) do
    local key_s
    if type(key) == "string" then
      key_s = "\"" .. key .. "\""
    elseif type(key) == "number" then
      key_s = key
    else
      key_s = "<" .. type(key) .. ">"
    end
    if type(value) == "number" then
      print((prefix or "") .. "|" .. key_s .. " = " .. value)
    elseif type(value) == "string" then
      print((prefix or "").. "|" .. key_s .. " = \"" .. value .. "\"")
    elseif type(value) == "table" then
      if (depth or 0) < 5 then
        print((prefix or "") .. "|" .. key_s .. " = |")
        luatools.print_table(value,
            (prefix or "") .. "|" .. string.rep(" ", string.len(key_s) + 3),
            (depth or 0) + 1)
        print((prefix or "") .. "|")
      else
        print((prefix or "") .. "|" .. key_s .. " = | ...")
      end
    else
      print((prefix or "").. "|" .. key_s .. " of type " .. type(value))
    end
  end
end

---------------------------------------------------------------------
--  ADVANCED  POSITION  HANDLING  AND  CALCULATIONS
---------------------------------------------------------------------

-- manhattan_distance calculates the Manhattan-distance between
-- (X1,Y1) and (X2, Y2), which is |X1 - X2| + |Y1 - Y2|.
-- If X2 and Y2 are nil, X1 and Y1 are assumed to be positions
-- instead of coordinates.
function luatools.manhattan_distance(x1, y1, x2, y2)
  if x1 and y1 and x2 and y2 then
    -- x1, y1, x2, y2 are coordinates
    return math.abs(x1 - x2) + math.abs(y1 - y2)
  end
  if x1 and y1 then
    -- x1 and y1 are positions
    return math.abs(x1.x - y1.x) + math.abs(x1.y - y1.y)
  end
  error("manhattan_distance: Too less arguments.")  
end

---------------------------------------------------------------------
--  MATHEMATICAL  FUNCTIONS
---------------------------------------------------------------------

-- As Lua uses different names for the modulo-function in its
-- versions, it's sometimes better to wrap them.
-- Even worse, lua's modulo function doesn't handle negative
-- values as it should. The following function returns (given
-- an integer) another integer between 0 and MODUL-1.
function luatools.mod(value, modul)
  if value < 0 then
    -- No, the following call to luatools.mod is not a real
    -- recursion, it's only for the case where VALUE is a
    -- negative multiple of MODUL (otherwise we would get
    -- MODUL as result, not zero).
    return luatools.mod(modul + (math.fmod or math.mod)(value, modul), modul)
  else
    return (math.fmod or math.mod)(value, modul)
  end
end

-- A wrapper of "if" to resemble the ternary ?:-function.
-- Note that this function evaluates both IFTRUE as well as IFFALSE, e.g.
--   luatools.cond(t == 0, 1/t, error("Division by zero"))
-- will evaluate the error-function and thus halt for any T.
-- Hence: Make sure there are no sideeffects in IFTRUE and IFFALSE!
function luatools.cond(condition, iftrue, iffalse)
  if condition then
    return iftrue
  else
    return iffalse
  end
end

-- digits returns a table whose elements are the digits of NUMBER
-- in base BASE. BASE can be a number (e.g. 3 to get ternary)
-- as well as a table (then the table entries with numerical
-- keys will be used as digits).
-- Examples:
--   luatools.digits(13, 2) = {1, 0, 1, 1}
--   luatools.digits(15, 16) = {15}
--   luatools.digits(17, 3) = {2, 2, 1}
--   luatools.digits(17, {2, "b", 5}) = {5, 5, "b"}
-- Hexadecimal would be:
--   luatools.digits(x, {0,1,2,3,4,5,6,7,8,9,"A","B","C","D","E","F"})
-- NUMBER is supposed to be a non-negative integer.
function luatools.digits(number, base)
  -- Check arguments and calculate fullbase and exponent
  if type(number) ~= "number" then
    error("digits: First argument not a number ("..type(number).." instead).")
  end
  if (type(base) ~= "number") and (type(base) ~= "table") then
    error("digits: Second argument not valid type ("..type(base)..").")
  end
  if (number < 0) or (number ~= math.ceil(number)) then
    error("digits: First argument out of range ("..number..").")
  end
  local fullbase = {}
  local exponent = 0
  if type(base) == "number" then
    if (base < 2) or (base ~= math.ceil(base)) then
      error("digits: Second argument out of range ("..base..").")
    end
    for j = 1, base do
      table.insert(fullbase, j - 1)
    end
  else -- type(base) == "table"
    if table.getn(base) < 2 then
      error("digits: Second argument has not enough elements.")
    end
    fullbase = base
  end
  exponent = table.getn(fullbase)
  -- Decompose NUMBER
  local remains = number
  local result = {}
  while remains > 0 do
    local d = luatools.mod(remains, exponent)
    table.insert(result, fullbase[d + 1])
    remains = (remains - d) / exponent
    if remains ~= math.ceil(remains) then
      error("digits: Internal error during calculation (remains = "..remains..").")
    end
  end
  return result
end

-- Return a table of all combinations of DEPTH entries,
-- each of which is chosen from DIGITS.
-- Example: luatools.combinations(3, {7, 8, "a"}) will return
--   { {7,7,7}, {7,7,8}, {7,7,"a"}, {7,8,7}, {7,8,8}, {7,8,"a"},
--     {7,"a",7}, {7,"a",8}, {7,"a","a"}, {8,7,7}, ... }
-- Mathematically, it builds the leafs of an #DIGITS-ary tree
-- of depth DEPTH.
function luatools.combinations(depth, digits)
  local all_combinations = {{}}
  for _ = 1, depth do
    local next_step = {}
    for _, old_combination in pairs(all_combinations) do
      for _, new_digit in pairs(digits) do
        local new_combination = luatools.deep_copy(old_combination)
        table.insert(new_combination, new_digit)
        table.insert(next, new_combination)
      end
    end
    all_combinations = next_step
  end
  return all_combinations
end

-- cubic_polynomial returns the result of the
-- following polynomial with coefficients in A:
-- a[10]*y*y*y + a[9]*x*y*y + a[8]*x*x*y + a[7]*x*x*x
--   + a[6]*y*y + a[5]*x*y + a[4]*x*x + a[3]*y + a[2]*x + a[1]
-- You can use luatools.random_vector(10, ...) and
-- a modulo operation to easily form a random
-- pattern of a floor, or choose the coefficients
-- to your own liking. Entries in A which are not
-- numbers are considered zero.
function luatools.cubic_polynomial(a, x, y)
  if type(a) ~= "table" then
    error("cubic_polynomial: First argument not a table (" .. type(a)
          .. " instead).")
  end
  if (type(x) ~= "number") or (type(y) ~= "number") then
    error("cubic_polynomial: Second or third argument not a number.")
  end
  return   (a[10] or 0)*y*y*y + (a[9] or 0)*x*y*y + (a[8] or 0)*x*x*y
         + (a[7] or 0)*x*x*x + (a[6] or 0)*y*y + (a[5] or 0)*x*y
         + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
end

---------------------------------------------------------------------
--  PERMUTATIONS  AND  RANDOM  NUMBERS
---------------------------------------------------------------------

-- Return a random permutation of n elements.
-- This function outputs a table with integer entries between
-- 1 and n at positions 1 to n.
function luatools.permutation(n)
  if type(n) ~= "number" then
    error("permutation: Expected number, got "..type(n).."!")
  end
  local sequence = {}
  for j = 1, n do
    table.insert(sequence, j)
  end
  luatools.shuffle_table(sequence)
  return sequence
end

-- Return a random cyclic permutation (i.e. with only one cycle) of n elements.
function luatools.cyclic_permutation(n)  
  if type(n) ~= "number" then
    error("cyclic_permutation: Expected number, got "..type(n).."!")
  end
  local sequence1 = luatools.permutation(n)
  local sequence2 = {}
  for j = 1, n - 1 do
    sequence2[sequence1[j]] = sequence1[j+1]
  end
  sequence2[sequence1[n]] = sequence1[1]
  return sequence2
end

-- Return a table with NUMBER random entries.
-- Additional arguments like with math.random.
function luatools.random_vector(number, ...)
  if type(number) ~= "number" then
    error("random_vector: First argument not a number ("..type(number).." instead).")
  end
  if (number < 0) or (number ~= math.ceil(number)) then
    error("random_vector: First argument out of range ("..number..").")
  end
  local result = {}
  for j = 1, number do
    result[j] = math.random(...)
  end
  return result
end

---------------------------------------------------------------------
--  MAP  HANDLING
---------------------------------------------------------------------

-- A "map" is a table of strings, like it's used in most
-- graphical ways to describe a level, including API 2.

-- fuse_map_layers takes a list of maps or a table of maps
-- and returns a map, which is constructed from the others
-- in the following way:
--  Map1:  {"abc", "def"}
--  Map2:  {"ABC", "DEF"}
--  Map3:  {"123", "456"}
--  fuse_map_layers(Map1, Map2, Map3):
--         {"aA1bB2cC3", "dD4eE5fF6"}
-- Missing letters are replaced by " ".
-- This function can be used to combine several layers
-- (e.g. floors, stones, items, actors) into a common
-- (typically very large) map.
-- fuse_map_layers assumes that the input maps are all
-- using a key length of 1. Otherwise you should use
-- split_map_layers before applying fuse_map_layers.
function luatools.fuse_map_layers(layer1, ...)
  -- Understand arguments
  local layers = {layer1, ...}
  if table.getn(layers) == 1 then
    layers = layer1
  end
  if type(layers) ~= "table" then
    error("fuse_map_layers: Argument is not a table (map).")
  end
  -- Calculate new height and width
  local max_lines, max_length = 0, 0
  for _, layer in pairs(layers) do
    if type(layer) ~= "table" then
      error("fuse_map_layers: Argument is not a table.")
    end
    max_lines = math.max(max_lines, table.getn(layer))
    for _, line in pairs(layer) do
      if type(line) ~= "string" then
        error("fuse_map_layers: Line in table (map) is not a string.")
      end
      max_length = math.max(max_length, string.len(line))
    end
  end
  local result = {}
  -- Create result
  local result = {}
  for y = 1, max_lines do
    result[y] = ""
    for x = 1, max_length do
      for _, layer in pairs(layers) do
        if layer[y] and (string.len(layer[y]) >= x ) then
          result[y] = result[y] .. string.sub(layer[y], x, x)
        else
          result[y] = result[y] .. " "
        end
      end
    end
  end
  return result
end

-- split_map_layers takes a map, splits it into KEYLENGTH
-- layers and returns a table of layers. It's the opposite
-- to fuse_map_layers.
function luatools.split_map_layers(keylength, map)
  -- Analyse arguments
  if type(keylength) ~= "number" then
    error("split_map_layers: First argument should be a number (key length).")
  end
  if type(map) ~= "table" then
    error("split_map_layers: Second argument should be a table (map).")
  end
  -- Split layers
  local layers = {}
  for j = 1, keylength do
    layers[j] = {}
  end
  for y, line in pairs(map) do
    if type(line) ~= "string" then
      error("print_map: Line is not a string.")
    end
    for j = 1, keylength do
      layers[j][y] = ""
    end
    for x = 1, string.len(line) do
      local j = luatools.mod(x - 1, keylength) + 1
      layers[j][y] = layers[j][y]..string.sub(line, x, x)
    end
  end
  return layers
end

-- concat_maps_horizontally takes a list of maps or a table of
-- maps and returns a map, which is constructed from the others
-- in the following way:
--  Map1:  {"abc", "def"}
--  Map2:  {"ABC", "DEF"}
--  Map3:  {"123", "456"}
--  concat_maps_horizontally(Map1, Map2, Map3):
--         {"abcABC123", "defDEF456"}
-- Missing letters are replaced by " ".
-- This function can be used to combine several rooms
-- or areas of a map to build a larger map.
-- Note that concat_maps_horizontally doesn't take an
-- offset value for a vertical shift of the maps!
function luatools.concat_maps_horizontally(map1, ...)
  -- Understand arguments
  local maps = {map1, ...}
  if table.getn(maps) == 1 then
    maps = map1
  end
  if type(maps) ~= "table" then
    error("concat_maps_horizontally: Argument is not a table (map).")
  end
  -- Find maximal line lengths and height
  local lengths = {}
  local height = 0
  for j, map in pairs(maps) do
    lengths[j] = 0
    for y, line in pairs(map) do
      lengths[j] = math.max(lengths[j], string.len(line))
      height = math.max(height, y)
    end
  end
  -- Concat to result
  local result = {}
  for y = 1, height do
    result[y] = ""
    for j, map in pairs(maps) do
      result[y] = result[y] .. (map[y] or "")
                    .. string.rep(" ", lengths[j] - string.len(map[y] or "")) 
    end
  end
  return result
end

-- concat_maps_vertically takes a list of maps or a table of
-- maps and returns a map, which is constructed from the others
-- in the following way:
--  Map1:  {"abc", "def"}
--  Map2:  {"ABC", "DEF"}
--  Map3:  {"123", "456"}
--  concat_maps_vertically(Map1, Map2, Map3):
--         {"abc", "def", "ABC", "DEF", "123", "456"}
-- This function can be used to combine several rooms
-- or areas of a map to build a larger map.
-- Note that concat_maps_vertically doesn't take an
-- offset value for a horizontal shift of the maps!
function luatools.concat_maps_vertically(map1, ...)
  -- Understand arguments
  local maps = {map1, ...}
  if table.getn(maps) == 1 then
    maps = map1
  end
  if type(maps) ~= "table" then
    error("concat_maps_vertically: Argument is not a table (map).")
  end
  -- Create result
  local result = {}
  for j, map in pairs(maps) do
    for y, line in pairs(map) do
      table.insert(result, line)
    end
  end
  return result
end
  
-- get_key_in_map returns the key of MAP at position POSARG.
-- KEYLENGTH can be a number or a string (then its length is
-- considered to be the keylength). Returns nil if POSARG is
-- not described in map.
function luatools.get_key_in_map(map, keylength, posarg)
  if type(map) ~= "table" then
    error("get_key_in_map: First argument is not a table (map).")
  end
  if ((type(keylength) ~= "string") and (type(keylength) ~= "number"))
      or ((type(keylength) == "number") and (keylength ~= math.floor(keylength))) then
    error("get_key_in_map: Second argument is not an integer or string (keylength).")
  end
  local kl = keylength
  if type(kl) == "string" then
    kl = string.len(kl)
  end
  local pos = posarg
  if type(pos) ~= "userdata" then
    pos = po(posarg)
  end
  local px, py = math.floor(pos.x), math.floor(pos.y)
  if (type(px) ~= "number") and (type(py) ~= "number") then
    error("get_key_in_map: Can't interpret third argument as position.")
  end
  if not map[py] then
    return nil
  end
  if string.len(map[py]) < kl * px then
    return nil
  end
  return string.sub(map[py], kl * (px - 1) + 1, kl * px)  
end

-- insert_key_in_map inserts key KEY at position POSARG
-- into the map MAP, which is assumed to be a table of
-- strings, and returns the result. The key length of the
-- map is assumed to be the length of KEY, so partial keys
-- are not supported. Missing entries are filled with a
-- neccessary number of spaces.
function luatools.insert_key_in_map(map, key, posarg)
  if type(map) ~= "table" then
    error("insert_key_in_map: First argument is not a table (map).")
  end
  if type(key) ~= "string" then
    error("insert_key_in_map: Second argument is not a string (key).")
  end
  if key == "" then
    error("insert_key_in_map: Second argument (key) is empty.")
  end
  local pos = posarg
  if type(pos) ~= "userdata" then
    pos = po(posarg)
  end
  local px, py = math.floor(pos.x), math.floor(pos.y)
  if (type(px) ~= "number") and (type(py) ~= "number") then
    error("insert_key_in_map: Can't interpret third argument as position.")
  end
  local keylength = string.len(key)
  local result = {}
  for y = 1, math.max(#map, py) do
    if y ~= py then
      result[y] = map[y] or ""
    else
      local delta = keylength * (px - 1) - string.len(map[y])
      if delta >= 0 then
        -- Line of map has to be expanded.
        result[y] = (map[y] or "") .. string.rep(" ", delta) .. key
      else
        -- Insert key into map (old key is deleted).
        result[y] = string.sub(map[y], 1, keylength * (px - 1)) .. key ..
                      string.sub(map[y], keylength * px + 1, string.len(map[y]))
      end
    end
  end
  return result  
end

-- complete_map returns a rectangularly completed version
-- of MAP, with " " as fillers.
function luatools.complete_map(map)
  if type(map) ~= "table" then
    error("complete_map: Argument is not a table (map).")
  end
  local width = 0
  local height = 0
  local result = {}
  for key, entry in pairs(map) do
    height = math.max(height, tonumber(key) or 0)
    if type(entry) == "string" then
      width = math.max(width, string.len(entry))
    else
      -- Odd entry. Report if key is a number
      -- (i.e. non-number user keys are allowed).
      if type(key) == "number" then
        error("complete_map: Line " .. key .. " in map is not a string, but "
              .. type(entry) .. ".")
      else
        result[key] = luatools.deep_copy(entry)
      end
    end
  end
  for y = 1, height do
    result[y] = map[y] or ""
    result[y] = result[y] .. string.rep(" ", width - string.len(result[y]))
  end
  return result
end

-- mirror_map_vertically returns MAP, mirrored along a
-- horizontal axis (i.e. North and South are inverted).
-- Missing entries are replaced with " ".
function luatools.mirror_map_vertically(map)
  if type(map) ~= "table" then
    error("mirror_map_vertically: Argument is not a table (map).")
  end
  local completed = luatools.complete_map(map)
  local result = {}
  for key, entry in pairs(completed) do
    if type(key) == "number" then
      result[table.getn(completed) - key + 1] = entry
    else
      result[key] = luatools.deep_copy(entry)
    end
  end  
  return result
end

-- mirror_map_horizontally returns MAP, mirrored along
-- a vertical axis (i.e. East and West are inverted).
-- The keylength given by KEY (example tile key or number)
-- is respected.
function luatools.mirror_map_horizontally(map, keylength)
  if type(map) ~= "table" then
    error("mirror_map_horizontally: Argument is not a table (map).")
  end
  if ((type(keylength) ~= "string") and (type(keylength) ~= "number"))
      or ((type(keylength) == "number") and (keylength ~= math.floor(keylength))) then
    error("mirror_map_horizontally: Second argument is not an integer or string (keylength).")
  end
  local kl = keylength
  if type(kl) == "string" then
    kl = string.len(kl)
  end
  local completed = luatools.complete_map(map)
  local map_width = string.len(completed[1] or "") / kl
  if math.ceil(map_width) ~= map_width then
    error("mirror_map_horizontally: Map is odd (broken key length).")
  end
  local result = {}
  for v, entry in pairs(completed) do
    if type(v) == "number" then
      for j = 1, map_width do
        local x = kl * (map_width - j)
        result[v] = (result[v] or "") .. string.sub(entry, x + 1, x + kl)
      end
    else
      result[v] = luatools.deep_copy(entry)
    end
  end  
  return result
end

-- print_map uses the print command to print a map.
-- It should be used for debug reasons only.
-- SEP can be a separator like "|" to encase the map
-- on the left and on the right.
function luatools.print_map(map, sep)
  if type(map) ~= "table" then
    error("print_map: Argument is not a table (map).")
  end
  for _, line in pairs(map) do
    if type(line) ~= "string" then
      error("print_map: Line is not a string.")
    end
    print((sep or "")..line..(sep or ""))
  end
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>


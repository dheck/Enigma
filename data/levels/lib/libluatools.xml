<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libluatools"/>
      <el:version el:score="1" el:release="1" el:revision="2" el:status="released"/>
      <el:author  el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.00">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

---------------------------------------------------------------------
-- libluatools holds some general utilities for working with Lua.
-- It includes functions for deep-copying tables, combining tables,
-- and shuffling tables, a function to calculate Manhattan
-- distances and a wrapper for Lua's modulo-function, which has
-- been renamed from math.mod to math.fmod.
---------------------------------------------------------------------

luatools = {}

---------------------------------------------------------------------
--  TABLE  HANDLING
---------------------------------------------------------------------

-- deep_copy returns a copy of SOURCE, where table entries are
-- not copied as memory references, but complete ("deep copy").
-- Metatables are transfered, but not deep-copied.
function luatools.deep_copy(source)
 if type(source) ~= "table" then
   return source
 end
 local dest = {}
 for k, v in pairs(source) do
   if type(source[k]) == "table" then
     dest[k] = luatools.deep_copy(source[k])
   else
     dest[k] = source[k]
   end
 end
 setmetatable(dest, getmetatable(source))
 return dest
end 

-- combine_tables returns a table consisting of all entries of the
-- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
-- {T1, T2, T3, ...}. The result of combine_tables will be a new
-- table with all entries of T1, T2, T3 etc., with the first table
-- having highest priority etc.
function luatools.combine_tables(arg1, ...)
  local args = {arg1, ...}
  if table.getn(args) == 1 then
    args = arg1
  end
  if type(args) ~= "table" then
    error("combine_tables: None or only one argument, and it's not a table!")
  end
  local result = {}
  for j,t in pairs(args) do
    if type(t) ~= "table" then
      error("combine_tables: Main table does not consist of tables alone!")
    end
    for k,v in pairs(t) do
      result[k] = result[k] or luatools.deep_copy(v)
    end
  end
  return result
end

-- shuffle_table resorts the table T randomly. Note that only those entries
-- of T can be sorted, that are indexed with integers from 1 to table.getn(T).
-- No return value, the table itself is shuffled.
function luatools.shuffle_table(t)
  if table.getn(t) < 2 then
    return
  end
  for n = table.getn(t), 2, -1 do
    local m = math.random(n)
    t[n], t[m] = t[m], t[n]
  end
end

---------------------------------------------------------------------
--  ADVANCED  POSITION  HANDLING  AND  CALCULATIONS
---------------------------------------------------------------------

-- manhattan_distance calculates the Manhattan-distance between
-- (X1,Y1) and (X2, Y2), which is |X1 - X2| + |Y1 - Y2|.
-- If X2 and Y2 are nil, X1 and Y1 are assumed to be positions
-- instead of coordinates.
function luatools.manhattan_distance(x1, y1, x2, y2)
  if x1 and y1 and x2 and y2 then
    -- x1, y1, x2, y2 are coordinates
    return math.abs(x1 - x2) + math.abs(y1 - y2)
  end
  if x1 and y1 then
    -- x1 and y1 are positions
    return math.abs(x1.x - y1.x) + math.abs(x1.y - y1.y)
  end
  error("manhattan_distance: Too less arguments.")  
end

---------------------------------------------------------------------
--  MATHEMATICAL  FUNCTIONS
---------------------------------------------------------------------

-- As Lua uses different names for the modulo-function in its
-- versions, it's sometimes better to wrap them.
-- Even worse, lua's modulo function doesn't handle negative
-- values as it should. The following function returns (given
-- an integer) another integer between 0 and MODUL-1.
function luatools.mod(value, modul)
  if value < 0 then
    -- No, the following call to luatools.mod is not a real
    -- recursion, it's only for the case where VALUE is a
    -- negative multiple of MODUL (otherwise we would get
    -- MODUL as result, not zero).
    return luatools.mod(modul + (math.fmod or math.mod)(value, modul), modul)
  else
    return (math.fmod or math.mod)(value, modul)
  end
end

-- A wrapper of "if" to resemble the ternary ?:-function.
-- Note that this function evaluates both IFTRUE as well as IFFALSE, e.g.
--   luatools.cond(t == 0, 1/t, error("Division by zero"))
-- will evaluate the error-function and thus hold for any T.
-- Hence: Make sure there are no sideeffects in IFTRUE and IFFALSE!
function luatools.cond(condition, iftrue, iffalse)
  if condition then
    return iftrue
  else
    return iffalse
  end
end

-- Return a random permutation of n elements.
-- This function outputs a table with integer entries between
-- 1 and n at positions 1 to n.
function luatools.permutation(n)
  if type(n) ~= "number" then
    error("permutation: Expected number, got "..type(n).."!")
  end
  local sequence = {}
  for j = 1, n do
    table.insert(sequence, j)
  end
  luatools.shuffle_table(sequence)
  return sequence
end

-- Return a random cyclic permutation (i.e. with only one cycle) of n elements.
function luatools.cyclic_permutation(n)  
  if type(n) ~= "number" then
    error("cyclic_permutation: Expected number, got "..type(n).."!")
  end
  local sequence1 = luatools.permutation(n)
  local sequence2 = {}
  for j = 1, n - 1 do
    sequence2[sequence1[j]] = sequence1[j+1]
  end
  sequence2[sequence1[n]] = sequence1[1]
  return sequence2
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>


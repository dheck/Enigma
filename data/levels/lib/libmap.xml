<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libmap"/>
      <el:version el:score="1" el:release="1" el:revision="1" el:status="released"/>
      <el:author  el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2008 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.10">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

---------------------------------------------------------------------
-- libmap provides a metatable for maps, thus some general utilities
-- for working with maps. It includes functions for joining maps
-- in several ways, for queries and manipulation of single entries
-- in the map.
---------------------------------------------------------------------
--
-- libmap provides the following functions:
--   wo:newMap(defaultKey, arg1, arg2)
--   lib.map.concat_horizontally(map1, map2)  aka. map1 .. map2
--   lib.map.concat_vertically(map1, map2)    aka. map1 + map2
--   lib.map.fuse(arg1, arg2)                 aka. map1 * map2
--   lib.map.transform(map, op)               aka. map ^ op
--   lib.map.get(map, posarg)                 aka. map[posarg]
--   lib.map.set(map, posarg, value)            aka. map[posarg] = value
--   lib.map.extend(map, posarg)                aka. map:extend(posarg)
--   lib.map.sub(map, arg1, arg2)               aka. map:sub(arg1, arg2)
--   lib.map.paste(map1, map2, posarg, ignore)  aka. map1:paste(map2, posarg, ignore)
--   lib.map.covers(map, pos)                   aka. map:covers(pos)
--   lib.map.set_default_key(map, newkey)       aka. map:set_default_key(newkey)
--   lib.map.print(map, withXYCounts, left_separator, right_separator)
--                                            aka. map:print(...)
-- Please consult the reference manual for details.
--

lib.map = {}
setmetatable(lib.map, getmetatable(lib))

function lib.map.concat_horizontally(map1, map2)
  if    (type(map1) ~= "table") or (map1.type ~= "map")
     or (type(map2) ~= "table") or (map2.type ~= "map") then
    error("lib.map.concat_horizontally: Can only work on maps.", 2)
  end
  if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
    error("lib.map.concat_horizontally: Default keys differ in length.", 2)
  end
  local result = {}
  for y = 1, math.max(map1.height, map2.height) do
    result[y] = (rawget(map1, y) or string.rep(map1.defaultkey, map1.width))
             .. (rawget(map2, y) or string.rep(map2.defaultkey, map2.width))
  end
  return wo:newMap(map1.defaultkey, result)  
end

function lib.map.concat_vertically(map1, map2)
  if    (type(map1) ~= "table") or (map1.type ~= "map")
     or (type(map2) ~= "table") or (map2.type ~= "map") then
    error("lib.map.concat_vertically: Can only work on maps.", 2)
  end
  if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
    error("lib.map.concat_vertically: Default keys differ in length.", 2)
  end
  local result = {}
  for y = 1, map1.height do
    result[y] = rawget(map1, y)  -- rest of line will be filled by wo:newMap
  end
  -- As the default key for result will be set to the first
  -- default key, we have to attach the missing lines of the
  -- second map here now.
  local rest = string.rep(map2.defaultkey, math.max(0, map1.width - map2.width))
  for y = 1, map2.height do
    result[y + map1.height] = rawget(map2, y) .. rest
  end
  return wo:newMap(map1.defaultkey, result)
end

function lib.map.fuse(arg1, arg2)
  local map1, map2 = arg1, arg2
  if type(arg1) == "string" then
    map1 = wo:newMap(arg1)
  end
  if type(arg2) == "string" then
    map2 = wo:newMap(arg2)
  end
  if    (type(map1) ~= "table") or (map1.type ~= "map")
     or (type(map2) ~= "table") or (map2.type ~= "map") then
    error("lib.map.fuse: Can only work on maps.", 2)
  end
  local result = {}
  for y = 1, math.max(map1.height, map2.height) do
    result[y] = ""
    for x = 1, math.max(map1.width, map2.width) do
      result[y] = result[y] .. map1[{x - 1, y - 1}] .. map2[{x - 1, y - 1}]
    end
  end
  return wo:newMap(map1.defaultkey .. map2.defaultkey, result)  
end

function lib.map.transform(map, op)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.transform: Can only work on maps.", 2)
  end
  if (type(op) ~= "number") or (op < 0) or (op > 7) or (op ~= math.floor(op)) then
    error("lib.map.transform: Unknown transformation request.", 2)
  end
  local w, h = map.width, map.height
  local function rot(x, y)
    return ({[MAP_IDENT]             = {x,         y},
             [MAP_ROT_CW]            = {y,         h - 1 - x},
             [MAP_ROT_180]           = {w - 1 - x, h - 1 - y},
             [MAP_ROT_CCW]           = {w - 1 - y, x},
             [MAP_MIRROR_HORIZONTAL] = {w - 1 - x, y},
             [MAP_MIRROR_VERTICAL]   = {x,         h - 1 - y},
             [MAP_MIRROR_SLASH]      = {y,         x},
             [MAP_MIRROR_BACKSLASH]  = {w - 1 - y, h - 1 - x}     })[op]
  end
  local new_w, new_h = w, h
  if    (op == MAP_ROT_CW) or (op == MAP_ROT_CCW)
     or (op == MAP_MIRROR_SLASH) or (op == MAP_MIRROR_BACKSLASH) then
    new_w, new_h = h, w
  end
  local result = {}
  for y = 1, new_h do
    result[y] = ""
    for x = 1, new_w do
      result[y] = result[y] .. map[rot(x - 1, y - 1)]
    end
  end
  return wo:newMap(map.defaultkey, result)  
end

function lib.map.sub(map, origin, arg2, arg3)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.sub: Can only work on maps.", 2)
  end
  local pos1, pos2 = origin, arg2
  if (type(pos1) == "table") or (usertype(pos1) == "object") then
    pos1 = po(pos1)
  end
  if (type(pos2) == "table") or (usertype(pos2) == "object") then
    pos2 = po(pos2)
  end
  if type(arg2) == "number" and type(arg3) == "number" then
    -- arg2 and arg3 are width and height
    pos2 = po(pos1.x + arg2 - 1, pos1.y + arg3 - 1)
  end
  pos1 = pos1:grid()
  pos2 = pos2:grid()
  if (pos2.x < pos1.x) or (pos2.y < pos1.y) then
    error("lib.map.sub: Rectangular area not cleanly defined (first argument "
        .. "is not top left-hand corner).", 2)
  end
  local result = {}
  local kl = map.keylength
  for y = pos1.y + 1, pos2.y + 1 do
    if y < map.height then
      result[y-pos1.y] = string.sub(rawget(map, y) or "",
                             pos1.x * kl + 1, (pos2.x + 1) * kl) or ""
    end
  end
  return wo:newMap(map.defaultkey, result)  
end

function lib.map.paste(map1, map2, posarg)
  if (type(map1) ~= "table") or (map1.type ~= "map") then
    error("lib.map.paste: Needs two maps.", 2)
  end
  if (type(map2) ~= "table") or (map2.type ~= "map") then
    error("lib.map.paste: Needs two maps.", 2)
  end
  if (usertype(posarg) == "object") or (usertype(posarg) == "position") then
    local kl = rawget(map2, "__keylength")
    local dk = rawget(map2, "__defaultkey")
    for y = 1, map2.height do
      local line = rawget(map2, y)
      for x = 1, map2.width do
        tile = string.sub(line, kl * (x - 1) + 1, x * kl)
        if tile ~= dk then
          map1[{posarg.x + x - 1, posarg.y + y - 1}] = tile
        end
      end
    end
  elseif usertype(posarg) == "group" then
    for obj in posarg do
      lib.map.paste(map1, map2, obj)
    end
  elseif type(posarg) == "table" then
    lib.map.paste(map1, map2, po(posarg))
  else
    error("lib.map.paste: Expected position, got "..type(posarg)..".", 2)
  end
end

function lib.map.replace(map, tile1, tile2arg)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.replace: Can only work on maps.", 2)
  end
  local kl = rawget(map, "__keylength")
  local tile2 = tile2arg or rawget(map, "__defaultkey")
  if    (type(tile1) ~= "string") or (type(tile2) ~= "string")
     or (string.len(tile1) ~= kl) or (string.len(tile2) ~= kl) then
    error("lib.map.replace: Tiles do not have the same length as default key.")
  end
  for y = 1, map.height do
    local line = rawget(map, y)
    for x = 1, map.width do
      tile = string.sub(line, kl * (x - 1) + 1, x * kl)
      if tile == tile1 then
        map[{x-1, y-1}] = tile2
      end
    end
  end
end

function lib.map.covers(map, pos)
  if type(pos) == "table" then
    return (pos[1] >= 0) and (pos[2] >= 0)
        and (pos[1] < map.width) and (pos[2] < map.height)
  else
    return (pos.x >= 0) and (pos.y >= 0)
        and (pos.x < map.width) and (pos.y < map.height)
  end
end

function lib.map.get(map, posarg)
  if type(posarg) == "number" then
    return rawget(map, posarg)
  elseif (usertype(posarg) == "position") or (usertype(posarg) == "object") then
    local pos = posarg:grid()
    if map:covers(pos) then
      local kl = rawget(map, "__keylength")
      return string.sub(rawget(map, pos.y + 1), kl * pos.x + 1, (pos.x + 1) * kl)
    else
      return rawget(map, "__defaultkey")
    end
  elseif usertype(posarg) == "group" then
    local result = {}
    for obj in posarg do
      table.insert(result, lib.map.get(map, obj))
    end
    return result
  elseif type(posarg) == "table" then
    if map:covers(posarg) then
      local kl = rawget(map, "__keylength")
      return string.sub(rawget(map, posarg[2] + 1), kl * posarg[1] + 1, (posarg[1] + 1) * kl)
    else
      return rawget(map, "__defaultkey")
    end
  elseif type(posarg) == "string" then
    if (posarg == "type") then
      return getmetatable(map)._type
    elseif (posarg == "width") or (posarg == "height")
       or (posarg == "defaultkey") or (posarg == "keylength") then
      return rawget(map, "__"..posarg)
    else  
      return (rawget(map, "user_attributes"))[posarg]
    end
  else
    error("lib.map.get: Can't understand position argument.")
  end
end

function lib.map.set(map, posarg, value)
  if type(posarg) == "string" then
    if (posarg == "type") then
      if tostring(value) ~= "map" then
        error("lib.map.set: A map is a map is a map is a map, and not a "
            .. tostring(value) .. "!", 2)
      else
        return
      end
    elseif (posarg == "width") or (posarg == "height") then
      error("lib.map.set: Use extend or sub to change the size of a map.", 2)
    elseif (posarg == "keylength") then
      error("lib.map.set: Can't change keylength without default key.", 2)
    elseif (posarg == "defaultkey") then
      map:set_default_key(value)
      return
    end
    map.user_attributes[posarg] = value
  else
    if type(value) ~= "string" then
      error("lib.map.set: Key must be of type string, is "..type(value)..".", 2)
    end
    local kl = rawget(map, "__keylength")
    if string.len(value) ~= kl then
      error("lib.map.set: Key must be of the same length as default key "
          .."(should be "..kl.. ", is "..string.len(value)..").", 2)
    end
    if (usertype(posarg) == "position") or (usertype(posarg) == "object") then
      local pos = posarg:grid()
      if (pos.x < 0) or (pos.y < 0) then
        error("lib.map.set: Negative positions are not supported.", 2)
      end
      map:extend(pos)
      rawset(map, pos.y + 1,
             string.sub(rawget(map, pos.y + 1), 1, pos.x * kl)
          .. value
          .. string.sub(rawget(map, pos.y + 1), (pos.x + 1) * kl + 1, -1))
    elseif usertype(posarg) == "group" then
      for obj in posarg do
        map:extend(obj)
        rawset(map, obj.y + 1,
             string.sub(rawget(map, obj.y + 1), 1, obj.x * kl)
          .. value
          .. string.sub(rawget(map, obj.y + 1), (obj.x + 1) * kl + 1, -1))
      end
    elseif type(posarg) == "table" then
      lib.map.set(map, po(posarg), value)
    end
  end
end

function lib.map.extend(map, posarg)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.extend: Can only work on maps.", 2)
  end
  local pos = posarg
  if type(pos) == "table" then
    pos = po(pos)
  end
  local w, h = rawget(map, "__width"), rawget(map, "__height")
  if pos.x >= w then
    pos = pos:grid()  
    local dk = rawget(map, "__defaultkey")
    local attach = string.rep(dk, pos.x - w + 1)
    for y = 1, h do
      rawset(map, y, rawget(map, y) .. attach)
    end
    w = pos.x + 1
    rawset(map, "__width", w)
  end
  if pos.y >= h then
    pos = pos:grid()
    local dk = rawget(map, "__defaultkey")
    local line = string.rep(dk, w)
    for y = h + 1, pos.y + 1 do
      rawset(map, y, line)
    end
    h = pos.y + 1
    rawset(map, "__height", h)
  end
end

function lib.map.print(map, withXYCounts, left_separator, right_separator)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.print: Can only print maps, sorry.", 2)
  end
  local w, h = map.width, map.height
  local kl = rawget(map, "__keylength")
  if withXYCounts then
    local line = string.rep(" ", kl) .. (left_separator or "")
    for x = 0, w - 1 do
      line = line .. string.rep(" ", math.max(0, kl - string.len(x)))
                  .. string.sub(x, math.max(0, string.len(x) - kl) + 1, string.len(x))
    end
    line = line .. (right_separator or "")
    print(line)
  end
  for y = 0, h - 1 do
    local line = ""
    if withXYCounts then
      line =    string.rep(" ", math.max(0, kl - string.len(y)))
             .. string.sub(y, math.max(0, string.len(y) - kl) + 1, string.len(y))      
    end
    line = line .. (left_separator or "") .. map[y + 1] .. (right_separator or "")
    print(line)
  end
end

function lib.map.set_default_key(map, newkey)
  if (type(map) ~= "table") or (map.type ~= "map") then
    error("lib.map.set_default_key: Can only set default key of maps, sorry.", 2)
  end
  if type(newkey) ~= "string" then
    error("lib.map.set_default_key: Default key must be string, is "
          .. type(newkey)..".", 2)
  end
  if newkey == "" then
    error("lib.map.set_default_key: Default key can't be empty.", 2)
  end
  local new_width = map.width * map.keylength / string.len(newkey)
  if new_width ~= math.ceil(new_width) then
    error("lib.map.set_default_key: Map width doesn't fit to new default key.", 2)
  end
  rawset(map, "__defaultkey", newkey)
  rawset(map, "__keylength", string.len(newkey))
  rawset(map, "__width", new_width)
end

lib.map.metatable = {
  __concat = lib.map.concat_horizontally,
  __add = lib.map.concat_vertically,
  __mul = lib.map.fuse,
  __pow = lib.map.transform,
  __index = lib.map.get,
  __newindex = lib.map.set,
  _type = "map"
}

wo:_register("newMap",
  function(world, defaultKey, arg1, arg2)
    local newmap = {user_attributes = {}}
    -- Check arguments, create map if necessary.
    if type(defaultKey) ~= "string" then
      error("newMap: Default key is not of type string, but "
            .. type(defaultKey) .. ".", 2)
    end
    if defaultKey == "" then
      error("newMap: Default key can't be empty.", 2)
    end
    local width = 0
    local height = 0
    local kl = string.len(defaultKey)
    if (type(arg1) == "table") and (type(arg2) == "nil") then
      -- Interpret table as map.
      for key, entry in pairs(arg1) do
        if type(key) == "number" then
          -- This line is going to be a real map entry.
          height = math.max(height, key)
          if type(entry) ~= "string" then
            error("newMap: Line " .. key .. " is not a string, but "
                  .. type(entry) .. ".", 2)
          end
          local line_width = string.len(entry) / kl
          if line_width ~= math.floor(line_width) then
            error("newMap: Line " .. key .. " doesn't fit to key length ("
                  .. kl .. ").", 2)
          end
          width = math.max(width, line_width)
          newmap[key] = entry
        elseif type(key) == "string" then
          newmap.user_attributes[key] = entry
        else
          error("newMap: Strange type for a table key: " .. type(key) .. ".", 2)
        end
      end
      -- Now complete the map, make it rectangular.
      for y = 1, height do
        newmap[y] = newmap[y] or ""
        newmap[y] = newmap[y]
            .. string.rep(defaultKey, width - string.len(newmap[y]) / kl)
      end
    elseif type(arg1) == "number" and type(arg2) == "number" then
      -- Create map from scratch.
      if (arg1 < 1) or (arg2 < 1) or (arg1 ~= math.floor(arg1))
          or (arg2 ~= math.floor(arg2)) then
        error("newMap: Width or Height out of range ("..arg1..", "..arg2..").", 2)
      end
      local line = string.rep(defaultKey, arg1)
      for y = 1, arg2 do      
        newmap[y] = line
      end
      width = arg1
      height = arg2
    elseif type(arg1) == "nil" and type(arg2) == "nil" then
      -- Create 1x1-map from scratch.
      return wo:newMap(defaultKey, 1, 1)
    --elseif type(arg2) == "nil" then
    --  -- Interpret arg1 as position.
    --  return wo:newMap(defaultKey, pos.x + 1, pos.y + 1)
    else
      error("newMap: Syntax error. Can't understand arguments.", 2)
    end
    -- Set additional values.
    newmap.__width = width
    newmap.__height = height
    newmap.__defaultkey = defaultKey
    newmap.__keylength = string.len(defaultKey)
    -- Set methods and finally metatable.
    newmap.print = lib.map.print
    newmap.covers = lib.map.covers
    newmap.set_default_key = lib.map.set_default_key
    newmap.extend = lib.map.extend
    newmap.sub = lib.map.sub
    newmap.paste = lib.map.paste
    newmap.replace = lib.map.replace
    setmetatable(newmap, lib.map.metatable)
    return newmap
  end
)

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>


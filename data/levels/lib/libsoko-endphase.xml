<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libsoko-endphase"/>
      <el:version el:score="1" el:release="1" el:revision="5" el:status="experimental"/>
      <el:author el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007, 2008 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.10">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

-- This "library" holds those functions and algorithms needed by libsoko.xml
-- that are used for triggering goals and preparing and executing the sokoball-
-- endphases. Don't include this library with your levels (it won't
-- have any effect), but libsoko.xml.

lib.soko.GOAL_HOOK_RALF = 1
lib.soko.ENDPHASE_HOOK_DEFAULT = 1

------------------------------------------------------------------------
-- Goal Trigger and Endphase Main Functions
------------------------------------------------------------------------

function lib_soko_goal_trigger(onoff, sender)
  local nr = sender._sokoarea
  local more_boxes = false  -- memorizes whether a box was added or removed
  if lib.soko.sokoarea[nr].endphase_started then
    return
  end

  -- A new stone? Or has a stone been removed?
  if(sender._box == 0) then
    if -wo:st(sender) then
      sender._box = 1
      lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled + 1
      more_boxes = true
    else
      -- blind alarm, probably a marble
      return
    end
  else
    sender._box = 0
    lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled - 1
  end

  -- Call goal_hook, e.g. for algorithms "ralf" and "allcrack".
  if type(lib.soko.sokoarea[nr].goal_hook) == "number" then
    if lib.soko.sokoarea[nr].goal_hook == lib.soko.GOAL_HOOK_RALF then
      lib.soko.endphase_goal_hook_ralf(nr, sender, more_boxes,
          lib.soko.sokoarea[nr].goals_filled, lib.soko.sokoarea[nr].number_goals)
    else
      lib.soko.error("libsoko: Unknown goal hook.")
    end
  end
  
  -- Start endphase?
  if lib.soko.sokoarea[nr].goals_filled == lib.soko.sokoarea[nr].number_goals then
    lib.soko.sokoarea[nr].endphase_started = true
    if type(lib.soko.sokoarea[nr].endphase_hook) == "number" then
      if lib.soko.sokoarea[nr].endphase_hook == lib.soko.ENDPHASE_HOOK_DEFAULT then
        lib.soko.endphase(nr)
      else
        lib.soko.error("libsoko: Unknown endphase hook number " .. 
          lib.soko.sokoarea[nr].endphase_hook .. ".")
      end
    else
      lib.soko.error("libsoko: Unknown endphase hook of type "
        .. type(lib.soko.sokoarea[nr].endphase_hook) .. ".")
    end
  end
end

function lib.soko.prepare_endphase(sokoarea_number)
  local nr = sokoarea_number
  -- ensure existence of goals
  if lib.soko.sokoarea[nr].number_goals < 1 then
    lib.soko.error("No goals defined!\n")
  end
  -- ensure a correctly set endphase-attribute
  local endp = lib.soko.sokoarea[nr].design.endp
  if not endp then
    lib.soko.sokoarea[nr].design.endp = lib.lua.deep_copy(lib.soko.default_design.endp)
    endp = lib.soko.sokoarea[nr].design.endp
  end
  if type(endp) ~= "table" then
    lib.soko.error("This design's endphase is given as "..type(endp)
            ..", should be table.")
  end
  local alg = endp.alg
  if alg == nil then
    lib.soko.sokoarea[nr].design.endp.alg = lib.lua.deep_copy(lib.soko.default_design.endp.alg)
    alg = endp.alg
  end
  if type(alg) ~= "string" then
    lib.soko.error("This design's endphase algorithm is given as "..type(alg)
            ..", should be string.")
  end

  -- decompose alg into algorithm name and additional parameter
  local param = ""
  local sep = string.find(alg, ":")
  if sep then
    alg = string.sub(endp.alg, 1, sep - 1)
    param = string.sub(endp.alg, sep + 1)
  end
  
  -- prepare oxyds
  if     (alg == "circle")
      or (alg == "hide")
      or (alg == "fourswitch")
      or (alg == "gradients")
      or (alg == "magnets") then
    -- nothing to prepare
  elseif (alg == "ralf")
      or (alg == "allcrack")
      or (alg == "vortex") then
    lib.soko.endphase_set_block_oxyds(nr, (lib.soko.sokoarea[nr].design.door or
        lib.soko.sokoarea[nr].design.wall or "st_nil"), param)
    lib.soko.sokoarea[nr].goal_hook = lib.soko.GOAL_HOOK_RALF
  elseif (alg == "block") then
    lib.soko.endphase_set_block_oxyds(nr, param)
  elseif (alg == "outside") then
    lib.soko.endphase_set_outside_oxyds(nr, param)
  elseif (alg == "knock") then
    lib.soko.endphase_set_block_oxyds(nr, lib.soko.sokoarea[nr].design.door, 3)
    lib.soko.endphase_set_knocking(nr, param)
  -- "Jumpyoxyds" deactivated for once
  --elseif (alg == "jumpyoxyds") then
  --  endphase_set_block_oxyds(nr, "jumpy")
  --  goal_hook = lib.soko.GOAL_HOOK_RALF
  else
    lib.soko.warning("Endphase algorithm "..alg.." unknown! Will use 'circle' instead.")
  end
end

function lib.soko.endphase(sokoarea_number)
  -- Correct structure of endp-attribute has been checked
  -- by prepare_endphase, we trust it blindly.
  local endp = lib.lua.deep_copy(lib.soko.sokoarea[sokoarea_number].design.endp)
  local alg = endp.alg
  local param = ""
  local marble = po(no["marble_"..sokoarea_number.."_1"])

  -- decompose alg into algorithm name and additional parameter
  local sep = string.find(alg, ":")
  if sep then
    alg = string.sub(endp.alg, 1, sep - 1)
    param = string.sub(endp.alg, sep + 1)
  end
  if param == "" then
    lib.soko.debug("Endphase starts of type "..alg..", no parameter.")
  else
    lib.soko.debug("Endphase starts of type "..alg..", parameter "..param..".")
  end

  -- redraw level and give items
  lib.soko.endphase_redraw_level_array(sokoarea_number)
  local give = lib.lua.deep_copy(endp.give)
  if type(give) == "string" then
    give = {give}
  end
  if type(give) == "table" then
    for k, v in pairs(give) do
      if is_item(v) or is_stone(v) or is_floor(v) then
        lib.soko.set_element(marble, sokoarea_number, "", v)
      elseif is_actor(v) then
        wo[marble] = {v, 0.5, 0.5}
      elseif v == "rubberball" then
        local old_actor = no["marble_"..sokoarea_number.."_1"]
        local actor_kind = "ac-whiteball"
        if lib.soko.sokoarea[sokoarea_number].design.white then
          actor_kind = "ac-blackball"
        end
        wo[marble] = {actor_kind, "rubberball_sokoarea_"..sokoarea_number,
                        0.5, 0.5, controllers = 0}
        wo:add({"ot_rubberband", anchor1 = no["marble_"..sokoarea_number],
            anchor2 = no["rubberball_sokoarea_"..sokoarea_number], strength = 50})
      else
        lib.soko.error("Can't give "..v..".")
      end
    end
  elseif type(give) ~= "nil" then
    lib.soko.error("Can't give something of type "..type(v)..".")
  end

  if alg == "circle" then
    lib.soko.endphase_circle(sokoarea_number)
  elseif alg == "hide" then
    lib.soko.endphase_set_hide_oxyds(sokoarea_number, param)
  elseif    (alg == "ralf")
         or (alg == "outside")
         --or (alg == "jumpyoxyds")
         or (alg == "block") then
    lib.soko.endphase_ralf_open_doors(sokoarea_number)
  elseif alg == "allcrack" then
    lib.soko.endphase_ralf_open_doors(sokoarea_number)
    lib.soko.endphase_allcrack(sokoarea_number)
  elseif alg == "fourswitch" then
    lib.soko.endphase_fourswitch(sokoarea_number)
  elseif alg == "vortex" then
    lib.soko.endphase_ralf_open_doors(sokoarea_number)
    lib.soko.endphase_vortex(sokoarea_number)
  elseif alg == "gradients" then
    lib.soko.endphase_set_hide_oxyds(sokoarea_number)
    lib.soko.endphase_gradients(sokoarea_number, param)
  elseif alg == "magnets" then
    lib.soko.endphase_set_hide_oxyds(sokoarea_number)
    lib.soko.endphase_magnets(sokoarea_number, param)
  elseif alg == "knock" then
    -- don't do anything; endphase_call_knocking
    -- queries endphase_started.
  else
    -- use default: "circle"
    lib.soko.endphase_circle(sokoarea_number)
  end
end

function lib.soko.endphase_redraw_level_array(sokoarea_number)
  local nr = sokoarea_number or 1
  local endp = lib.lua.deep_copy(lib.soko.sokoarea[nr].design.endp)
  local offset = lib.soko.sokoarea[nr].offset
  
  -- small routine to check the walls and outside
  local function is_oxyd_or_blocker(x,y)
    if lib.soko.sokoarea[nr].list_oxyd[x.."/"..y] then
      return true
    elseif lib.soko.sokoarea[nr].list_blocker[x.."/"..y] then
      return true
    end
    return false
  end
  
  -- redraw outside
  for p, v in pairs(lib.soko.sokoarea[nr].list_outside) do
    if not is_oxyd_or_blocker(v.abs.x, v.abs.y) then
      lib.soko.set_element(v.abs, nr, k, endp.outf)
    end
  end
  
  -- redraw the rest inside level_array:
  for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
      if not is_oxyd_or_blocker(x + offset.x, y + offset.y) then
        local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
        for k, v in pairs(endp) do
          if    ((k == "inf")  and char_is_inf(ch))
             or ((k == "wall") and char_is_wall(ch))
             or ((k == "goal") and char_is_goal(ch)) then
            lib.soko.set_element(offset + {x,y}, nr, k, v)
          end
        end
      end
    end
  end
  
  -- if existent, redraw blocker floors
  if (lib.soko.sokoarea[nr].list_blocker) and (endp.inf) then
    for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
      lib.soko.set_element(v.abs, nr, "inf", endp.inf)
    end
  end 
end

------------------------------------------------------------------------
-- Endphase Games and Algorithms
------------------------------------------------------------------------

function lib.soko.endphase_circle(sokoarea_number)
  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or "b"
  local actor = no["marble_"..sokoarea_number.."_1"]
  if not -actor then
    actor = no["marble"]
    if not -actor then
      lib.soko.error("No marble found. Please name it 'marble'.")  
    end
  end
  local abs = po(actor)
  if abs.x > 10 then
    abs = abs + {-2,0}
  end
  if abs.y > 6 then
    abs = abs + {0,-2}
  end
  for j = 0, 2 do
    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,-1}}, flavor, 2*j)
    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {-1,j}}, flavor, 2*j)
    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,3}},  flavor, 2*j+1)
    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {3,j}},  flavor, 2*j+1)
    for k = 0, 2 do
      wo:st(abs + {j,k}):kill()
      wo:it(abs + {j,k}):kill()
      lib.soko.set_element(abs + {j,k}, sokoarea_number, "inf")
    end
  end
  wo[abs + {1,1}] = {"st_fart", _sokoarea = sokoarea_number}
  wo:shuffleOxyd()
end

-- endphase_set_outside_oxyds distributes oxyds over the outside and
-- wall_two-area of the level. There will be 2 to 5 pairs of oxyds
-- depending on the amount of space. PARAM may define a maximal
-- number of oxyd pairs (good for outf = "fl-space").
function lib.soko.endphase_set_outside_oxyds(sokoarea_number, param)
  local places = {}
  local nr = sokoarea_number or 1
  local offset = lib.soko.sokoarea[nr].offset
  local mx = lib.soko.sokoarea[nr].array_width
  local my = lib.soko.sokoarea[nr].array_height
  local flavor = lib.soko.sokoarea[nr].design.oxyd or "b"

  -- Select all places outside or in the walls, unreachable
  -- for the marble.
  for p, v in pairs(lib.lua.combine_tables(lib.soko.sokoarea[nr].list_outside,
                lib.soko.sokoarea[nr].list_wall_two)) do
    if (v.abs.x % 2 == 0) and (v.abs.y % 2 == 0) then
      table.insert(places, v)
    end
  end

  -- Choose some appropriate subset
  local max = table.getn(places)
  local number_pairs = 2
  if max < 2 then
    -- Not enough places? Then choose corners of level_array.
    -- They should always be at least wall_two and far enough
    -- away from each other.
    places = { {abs = offset},
               {abs = offset + {mx - 1, 0}},
               {abs = offset + {0, my - 1}},
               {abs = offset + {mx - 1, my - 1}}}
  elseif max <  20 then  number_pairs = 2
  elseif max <  50 then  number_pairs = 3
  elseif max < 100 then  number_pairs = 4
  else                   number_pairs = 5
  end
  if (type(param) ~= "nil") and (param ~= "") then
    local max_pairs = tonumber(param)
    if max_pairs then
      number_pairs = math.min(max_pairs, number_pairs)
    end    
  end

  places = lib.lua.shuffle(places)

  for j = 1, number_pairs do
    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
  end
  wo:shuffleOxyd()
end

function lib.soko.endphase_set_block_oxyds(sokoarea_number, blocker, max_pairs)
  local oxyds = {}
  local nr = sokoarea_number or 1
  local flavor = lib.soko.sokoarea[nr].design.oxyd or "b"

  -- Add all wall_one-elements with exactly one way near as blocker,
  -- and the opposite position as oxyd, if it is of type wall_two.
  -- Make sure that each possible oxyd position is assigned at most once,
  -- and that no other oxyds or blockers are near.
  local function opposite_as_oxyd(xy, dxy)
    if     lib.soko.sokoarea[nr].list_way[(xy.x+dxy.x).."/"..(xy.y+dxy.y)]
       and lib.soko.sokoarea[nr].list_wall_two[(xy.x-dxy.x).."/"..(xy.y-dxy.y)] then
      -- Check that no oxyd has been set on this position before
      -- and no other oxyd or blocker is near the new oxyd or its
      -- blocker.
      for j, w in pairs(oxyds) do
        if    (lib.math.manhattan_distance(w.blocker.abs, xy) <= 1)
           or (lib.math.manhattan_distance(w.abs, xy) <= 1)
           or (lib.math.manhattan_distance(w.blocker.abs, xy - dxy) <= 1)
           or (lib.math.manhattan_distance(w.abs, xy - dxy) <= 1) then
          return
        end
      end
      table.insert(oxyds, {abs = xy - dxy,
          blocker = {abs = xy, oxyd = {abs = xy - dxy}}, way = {abs = xy + dxy}})
      return
    end
    return
  end
  local directions = {po({-1,0}), po({1,0}), po({0,-1}), po({0,1})}
  for p, v in pairs(lib.soko.sokoarea[nr].list_wall_one) do
    if v.count == 1 then
      for _, dir in ipairs(directions) do
        opposite_as_oxyd(v.abs, dir)
      end
    end
  end

  -- Choose some appropriate subset
  local max = table.getn(oxyds)
  local number_pairs = 2
  if max < 4 then
    -- Not enough places? Choose "circle"-algorithm instead.
    lib.soko.sokoarea[nr].design.endp.alg = "circle"
    return
  elseif max <  8 then  number_pairs = 2
  elseif max < 16 then  number_pairs = 3
  elseif max < 28 then  number_pairs = 4
  else                  number_pairs = 5
  end
  if (type(max_pairs) ~= "nil") and (max_pairs ~= "") then
    if tonumber(max_pairs) >= 1 then
      number_pairs = math.min(tonumber(max_pairs), number_pairs)
    end    
  end

  oxyds = lib.lua.shuffle(oxyds)

  -- set oxyds and blockers
  local function set_block(w)
    local myblocker = lib.lua.deep_copy(blocker)
    -- If there's an entry "st_door_d", choose the faces.
    if type(myblocker) == "string" then
      myblocker = {myblocker}
    end
    for j, v in pairs(myblocker) do
      if v == "st_door_d" then
        if w.abs.x == w.oxyd.abs.x then
          myblocker[j] = "st_door_d"
        else
          myblocker[j] = "st_door_d_ew"
        end        
      end
    end
    -- now set in-floor and blocker, and add to list_blocker.
    lib.soko.set_element(w.abs, nr, "inf")
    lib.soko.set_element(w.abs, nr, "", myblocker)
    lib.soko.sokoarea[nr].list_blocker[(w.abs.x).."/"..(w.abs.y)] = lib.lua.deep_copy(w)
  end
  for j = 1, number_pairs do   -- Testlevel: 14
    lib.soko.set_oxyd(nr, oxyds[2*j-1], flavor, j - 1)
    lib.soko.set_oxyd(nr, oxyds[2*j], flavor, j - 1)
    set_block(oxyds[2*j-1].blocker)
    set_block(oxyds[2*j].blocker)
  end
  wo:shuffleOxyd()

  -- assign goals to blockers
  -- Note: There might be more goals as blockers, and, vice versa,
  --       there might be more blockers as goals.
  local goal_table = {}
  for p, v in pairs(lib.soko.sokoarea[nr].list_goal) do
    table.insert(goal_table, v)
  end
  goal_table = lib.lua.shuffle(goal_table)
  for j = 2, math.min(table.getn(goal_table), table.getn(oxyds)) do
    lib.soko.sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
  end
end

-- endphase_set_hide_oxyds distributes oxyds over the wall_one-walls.
-- PARAM is a maximal number of oxyd pairs.
function lib.soko.endphase_set_hide_oxyds(sokoarea_number, param)
  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or "b"
  local places = {}
  
  -- add all wall_one-elements
  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
    table.insert(places, v)
  end

  places = lib.lua.shuffle(places)
  
  -- choose number of oxyds
  local max = table.getn(places)
  local number_pairs = 1
  if max < 2 then
    -- use circle instead
    lib.soko.endphase_circle(sokoarea)
    return
  elseif max <  6  then  number_pairs = 2
  elseif max < 10  then  number_pairs = 3
  elseif max < 30  then  number_pairs = 4
  else                   number_pairs = 5 end
  if (type(param) ~= "nil") and (param ~= "") then
    local max_pairs = tonumber(param)
    if max_pairs then
      number_pairs = math.min(max_pairs, number_pairs)
    end    
  end
  
  -- set oxyds
  for j = 1, number_pairs do
    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
  end
  wo:shuffleOxyd()
end

function lib.soko.endphase_gradients(sokoarea_number, param)
  local force = tonumber(param) or 25.0
  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
    local grad_type = random(1,12)
    wo[v.abs] = {"fl-gradient", type = grad_type, force = force}
  end
end

function lib.soko.endphase_magnets(sokoarea_number, param)
  local force = tonumber(param) or 30.0
  local places = {}
  local nr = sokoarea_number or 1
  local flavor = lib.soko.sokoarea[nr].design.oxyd or "b"

  -- add all way-elements which are not goals
  for p, v in pairs(lib.soko.sokoarea[nr].list_way) do
    if not char_is_goal(lib.soko.sokoarea[nr].level_array[v.rel.y][v.rel.x]) then
      table.insert(places, v)
    end
  end

  places = lib.lua.shuffle(places)

  -- choose number of magnets
  local number_magnets = math.floor(table.getn(places)/6)

  -- set magnets
  for j = 1, number_magnets do
    wo[places[j].abs] = {"it_magnet_on", range = 5, strength = force}
  end
end

function lib.soko.endphase_fourswitch(sokoarea_number)
  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or "b"
  local places = {}

  -- add all wall_one-elements
  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
    table.insert(places, v)
  end

  places = lib.lua.shuffle(places)

  -- choose number of fourswitchs/oxyds
  local max = table.getn(places)
  local number_pairs = 1
  if max < 2 then
    -- use circle instead
    lib.soko.endphase_circle(sokoarea_number)
    return
  elseif max <  6  then  number_pairs = 2
  elseif max < 10  then  number_pairs = 3
  else                   number_pairs = 4 end
  
  -- set fourswitchs
  for j = 1, 2*number_pairs do
    wo[places[j].abs] =
        {"st_fourswitch", target = "lib_soko_endphase_call_fourswitch", _number = j,
         _sokoarea = sokoarea_number}
    places[j].current = 4
    places[j].solve = random(1,4)
    places[j].correct = false
  end
  places.number_pairs = number_pairs
  lib.soko.sokoarea[sokoarea_number].places = lib.lua.deep_copy(places)
end

function lib_soko_endphase_call_fourswitch(onoff, sender)
  local j = sender._number
  local nr = sender._sokoarea
  local places = lib.soko.sokoarea[nr].places

  -- When fourswitch is knocked, count it.
  places[j].current = places[j].current + 1
  if places[j].current == 5 then
    places[j].current = 1
  end
  
  -- When count is correct, make it "st-likeoxyda-open".
  if places[j].current == places[j].solve then
    places[j].correct = true
    wo[places[j].abs] = {"st-likeoxyda-open", _number = 0, _sokoarea = sokoarea_number}
  end

  -- Now the difficult part: If it's the first fourswitch (the one
  -- fourswitch that doesn't change any other), check all fourswitchs
  -- and replace them by oxyds if all are correct. Else, recreate the
  -- next fourswitch in hierarchy, set it to the old number, then
  -- set the callback function and call it once by triggering another
  -- time (making it show the new number). This means: Recursion!
  if j ~= 1 then
    -- Trigger all lower fourswitchs
    local xy = places[j-1].abs
    if places[j-1].correct then
      -- reset the fourswitch
      wo[xy] = {"st_fourswitch", _number = j - 1, _sokoarea = sokoarea_number}
      mystone = wo:st(xy)
      for k = 1, places[j-1].current do
        mystone:toggle()
      end
      mystone.target = "lib_soko_endphase_call_fourswitch"
      places[j-1].correct = false
    end
    wo:st(xy):toggle()
  else
    -- Check all fourswitchs
    local correct = true
    for k = 1, 2*places.number_pairs do
      correct = correct and places[k].correct
    end
    if correct then
      -- replace fourswitchs by oxyds
      for k = 1, places.number_pairs do
        lib.soko.set_oxyd(sokoarea_number, places[2*k-1], flavor, k - 1)
        lib.soko.set_oxyd(sokoarea_number, places[2*k], flavor, k - 1)
      end
      wo:shuffleOxyd()
    end
  end  
end


function lib.soko.endphase_allcrack(sokoarea_number)
  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
    if not -wo:it(v.abs) then
      wo[v.abs] = {"it-crack3"}
    end
  end  
end

function lib.soko.endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
    goals_filled, number_goals)
  local nr = sokoarea_number or 1
  -- verify correct sokoarea-number and existence of "goal_to_blocker"
  if nr ~= sender._sokoarea then
    lib.soko.error("libsoko: Inconsistent sokoarea numbers in goal hook!")
  end
  if type(lib.soko.sokoarea[nr].goal_to_blocker) ~= "table" then
    lib.soko.error("libsoko: Blocker list is missing during goal hook!")
  end
  -- identify the corresponding door and open it
  local blocker = lib.soko.sokoarea[nr].goal_to_blocker[sender._goal_number]
  if blocker then
    lib.soko.endphase_ralf_open_door(nr, more_boxes, blocker.abs)
  end
end

function lib.soko.endphase_ralf_open_doors(sokoarea_number)
  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_blocker) do
    lib.soko.endphase_ralf_open_door(sokoarea_number, true, v.abs)
  end
end

-- endphase_ralf_open_door opens or closes a door at position
-- (X,Y), dependend on the boolean OPEN.
function lib.soko.endphase_ralf_open_door(sokoarea_number, open, xy)
  local door_kind = lib.soko.sokoarea[sokoarea_number].design.endp.open_door
  if door_kind then
    if not open then
      door_kind =    lib.soko.sokoarea[sokoarea_number].design.door
                  or lib.soko.sokoarea[sokoarea_number].design.wall or "st_nil"
    end
    lib.soko.set_element(xy, sokoarea_number, "", door_kind)
  else
    -- use default "open"/"close"-messages instead
    local st = wo:st(xy)
    local it = wo:it(xy)
    local fl = wo:fl(xy)
    if -st and st._sokoarea then
      st:message(lib.lua.cond(open, "open", "close"))
    end
    if -it and it._sokoarea then
      it:message(lib.lua.cond(open, "open", "close"))
    end
    if -fl then
      fl:message(lib.lua.cond(open, "close", "open"))
    end
  end  
end

function lib.soko.endphase_vortex(sokoarea_number)
  local nr = sokoarea_number or 1
  local list_way = 
    lib.lua.combine_tables(lib.soko.sokoarea[nr].list_way, lib.soko.sokoarea[nr].list_blocker)
  local components = 0
  local component = {}

  -- Remove old component-entries, in case there are still some left.
  for p, v in pairs(list_way) do
    list_way[p].component = nil
  end

  -- Analyse connected components of list_way, separated by goals.
  local function mark_component(xy)
    if     (list_way[xy.x.."/"..xy.y])
       and (not list_way[xy.x.."/"..xy.y].component)
       and (not lib.soko.sokoarea[nr].list_goal[xy.x.."/"..xy.y]) then
      list_way[xy.x.."/"..xy.y].component = components
      --set_floor(({"fl-leaves", "fl-ice", "fl-red", "fl-black", "fl-white",
      --    "fl-sahara", "fl-light", "fl-gray", "fl-lightgray", "fl-rough",
      --    "fl-marble", "fl-tigris"})[components] or "fl-sand", lx, ly)
      table.insert(component[components], {abs = xy})
      mark_component(xy + {1,0})
      mark_component(xy + {-1,0})
      mark_component(xy + {0,1})
      mark_component(xy + {0,-1})
    end
  end
  for p, v in pairs(list_way) do
    if (not list_way[p].component) and (not lib.soko.sokoarea[nr].list_goal[p]) then
      components = components + 1
      component[components] = {oxyds = 0}
      mark_component(v.abs)
    end    
  end

  -- If only one component, exit, player will find his or her way alone.
  if components < 2 then
    return
  end

  -- Analyse oxyds and to which components they belong to.
  for p, v in pairs(lib.soko.sokoarea[nr].list_oxyd) do
    local component_number = list_way[v.blocker.abs.x.."/"..v.blocker.abs.y].component or -1
    if component_number == -1 then
      lib.soko.error("Error in component calculation.")
    else
      component[component_number].oxyds = component[component_number].oxyds + 1
    end
  end  

  -- Let there be at most max(5, number-of-oxyd-components)
  -- components, plus the one the marble actually occupies.
  local t = {}  -- helper table: components with oxyds or marble
  local u = {}  -- helper table: all components except t
  local mx, my = po(no["marble_"..nr.."_1"]):xy()
  local marble_component = (list_way[mx.."/"..my] or {}).component
  for j = 1, components do
    if (component[j].oxyds > 0) or (j == marble_component) then
      table.insert(t, component[j])
    else
      table.insert(u, component[j])
    end
  end
  u = lib.lua.shuffle(u)
  while (table.getn(t) < 5) and (table.getn(u) > 0) do
    table.insert(t, u[table.getn(u)])
    table.remove(u)
  end
  component = t
  components = table.getn(component)

  -- From each component, choose one tile and save the position
  local vortex = {}
  for j = 1, components do
    table.insert(vortex, component[j][random(1, table.getn(component[j]))])
  end
  
  -- Find a cyclic permutation (i.e. with only one cycle) to connect the
  -- vortices (each vortex shall be reached by starting from any other).
  local connect = lib.math.cyclic_permutation(components)

  -- Now set and connect the vortices
  for j, v in ipairs(vortex) do
    local w = vortex[connect[j]]
    -- Remember: We also allow (we need!) vortices at old blocker-positions.
    -- There could still be a stone over this. This stone might be st-blocker,
    -- which turns to it-blocker and has therefore to be removed. Better
    -- we remove all stones:
    wo:st(v.abs):kill()
    wo[v.abs] = {"it_vortex_open", destination = w.abs}
  end  
end

function lib.soko.endphase_set_knocking(sokoarea_number, param)
  local nr = sokoarea_number
  local flavor = lib.soko.sokoarea[nr].design.oxyd or "b"
  local places = {}

  -- add all blockers
  for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
    table.insert(places, v)
  end

  places = lib.lua.shuffle(places)

  -- set attributes of door
  for j, v in ipairs(places) do
    local st = wo:st(v.abs)
    if -st then
      st.action = "callback"
      st.target = "lib_soko_endphase_call_knocking"
      st._close = places[lib.lua.mod(j, table.getn(places)) + 1].abs
      st._open = places[lib.lua.mod(j+1, table.getn(places)) + 1].abs
      st._number = j
    end
  end
end

function lib_soko_endphase_call_knocking(onoff, sender)
  local j = sender._number
  local nr = sender._sokoarea
  if (not nr) or (not j) then
    lib.soko.error("libsoko: Knocking's source has no number or no sokoarea.")
  end
  lib.soko.debug("Knocked on "..j.."/"..lib.soko.sokoarea[nr].number_oxyds)
  -- Deactivate the first door until endphase has started.
  if (j == 1) and (not lib.soko.sokoarea[nr].endphase_started) then
    lib.soko.debug("Door deactivated until endphase.")
    return
  end
  -- Open or close the neccessary doors given as attributes.
  if sender._sokoarea == nr then
    if wo:st(sender._close):is("st_door") then
      wo:st(sender._close):close()
    end
    if wo:st(sender._open):is("st_door") then
      wo:st(sender._open):open()
    end
  end
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>


<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libsoko-endphase"/>
      <el:version el:score="1" el:release="1" el:revision="1" el:status="experimental"/>
      <el:author el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.00">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

-- This "library" holds those functions and algorithms needed by libsoko.xml
-- that are used for triggering goals and preparing and executing the sokoball-
-- endphases. Don't include this library with your levels (it won't
-- have any effect), but libsoko.xml.

------------------------------------------------------------------------
-- Goal Trigger and Endphase Main Functions
------------------------------------------------------------------------

function goal_trigger(onoff, sender)
  local x, y = enigma.GetPos(sender)
  local nr = enigma.GetAttrib(sender, "_sokoarea")
  local more_boxes = false  -- memorizes whether a box was added or removed
  if sokoarea[nr].endphase_started then
    return
  end

  -- A new stone? Or has a stone been removed?
  if(enigma.GetAttrib(sender, "_box") == 0) then
    if enigma.GetStone(x,y) then
      enigma.SetAttrib(sender, "_box", 1)
      sokoarea[nr].goals_filled = sokoarea[nr].goals_filled + 1
      more_boxes = true
    else
      -- blind alarm, probably a marble
      return
    end
  else
    enigma.SetAttrib(sender, "_box", 0)
    sokoarea[nr].goals_filled = sokoarea[nr].goals_filled - 1
  end

  -- Call goal_hook, e.g. for algorithms "ralf" and "allcrack".
  if type(sokoarea[nr].goal_hook) == "function" then
    sokoarea[nr].goal_hook(nr, sender, more_boxes, sokoarea[nr].goals_filled,
              sokoarea[nr].number_goals)
  end
  
  -- Start endphase?
  if sokoarea[nr].goals_filled == sokoarea[nr].number_goals then
    sokoarea[nr].endphase_started = true
    if type(sokoarea[nr].endphase_hook) == "function" then
      sokoarea[nr].endphase_hook(nr)
    else
      mydebug("libsoko: No endphase hook found!")
    end
  end
end

function prepare_endphase(sokoarea_number)
  local nr = sokoarea_number
  -- ensure existence of goals
  if sokoarea[nr].number_goals < 1 then
    myerror("No goals defined!\n")
  end
  -- ensure a correctly set endphase-attribute
  local endp = sokoarea[nr].design.endp
  if not endp then
    sokoarea[nr].design.endp = luatools.deep_copy(default_design.endp)
    endp = sokoarea[nr].design.endp
  end
  if type(endp) ~= "table" then
    myerror("This design's endphase is given as "..type(endp)
            ..", should be table.")
  end
  local alg = endp.alg
  if alg == nil then
    sokoarea[nr].design.endp.alg = luatools.deep_copy(default_design.endp.alg)
    alg = endp.alg
  end
  if type(alg) ~= "string" then
    myerror("This design's endphase algorithm is given as "..type(alg)
            ..", should be string.")
  end

  -- decompose alg into algorithm name and additional parameter
  local param = ""
  local sep = string.find(alg, ":")
  if sep then
    alg = string.sub(endp.alg, 1, sep - 1)
    param = string.sub(endp.alg, sep + 1)
  end
  
  -- prepare oxyds
  if     (alg == "circle")
      or (alg == "hide")
      or (alg == "fourswitch")
      or (alg == "gradients")
      or (alg == "magnets") then
    -- nothing to prepare
  elseif (alg == "ralf")
      or (alg == "allcrack")
      or (alg == "vortex") then
    endphase_set_block_oxyds(nr, (sokoarea[nr].design.door or
        sokoarea[nr].design.wall or "st-none"), param)
    sokoarea[nr].goal_hook = endphase_goal_hook_ralf
  elseif (alg == "block") then
    endphase_set_block_oxyds(nr, param)
  elseif (alg == "outside") then
    endphase_set_outside_oxyds(nr, param)
  elseif (alg == "knock") then
    endphase_set_block_oxyds(nr, sokoarea[nr].design.door, 3)
    endphase_set_knocking(nr, param)
  -- "Jumpyoxyds" deactivated for once
  --elseif (alg == "jumpyoxyds") then
  --  endphase_set_block_oxyds(nr, "jumpy")
  --  goal_hook = endphase_goal_hook_ralf
  else
    mywarning("Endphase algorithm "..alg.." unknown! Will use 'circle' instead.")
  end
end

function endphase(sokoarea_number)
  -- Correct structure of endp-attribute has been checked
  -- by prepare_endphase, we trust it blindly.
  local endp = luatools.deep_copy(sokoarea[sokoarea_number].design.endp)
  local alg = endp.alg
  local param = ""
  local px, py = enigma.GetPos(enigma.GetNamedObject("marble_"..sokoarea_number.."_1"))
  
  -- decompose alg into algorithm name and additional parameter
  local sep = string.find(alg, ":")
  if sep then
    alg = string.sub(endp.alg, 1, sep - 1)
    param = string.sub(endp.alg, sep + 1)
  end
  if param == "" then
    mydebug("Endphase starts of type "..alg..", no parameter.")
  else
    mydebug("Endphase starts of type "..alg..", parameter "..param..".")
  end

  -- redraw level and give items
  endphase_redraw_level_array(sokoarea_number)
  local give = luatools.deep_copy(endp.give)
  if type(give) == "string" then
    give = {give}
  end
  if type(give) == "table" then
    for k, v in pairs(give) do
      if is_item(v) or is_stone(v) or is_floor(v) then
        set_element(px, py, sokoarea_number, "", v)
      elseif is_actor(v) then
        set_actor(v, px + 0.5, py + 0.5)
      elseif v == "rubberball" then
        local old_actor = enigma.GetNamedObject("marble_"..sokoarea_number.."_1")
        local actor_kind = "ac-whiteball"
        if sokoarea[sokoarea_number].design.white then
          actor_kind = "ac-blackball"
        end
        local new_actor = set_actor(actor_kind, px+0.5, py+0.5, {controllers=0})
        AddRubberBand(old_actor, new_actor, 50, 0)
      else
        myerror("Can't give "..v..".")
      end
    end
  elseif type(give) ~= "nil" then
    myerror("Can't give something of type "..type(v)..".")
  end

  if alg == "circle" then
    endphase_circle(sokoarea_number)
  elseif alg == "hide" then
    endphase_set_hide_oxyds(sokoarea_number, param)
  elseif    (alg == "ralf")
         or (alg == "outside")
         --or (alg == "jumpyoxyds")
         or (alg == "block") then
    endphase_ralf_open_doors(sokoarea_number)
  elseif alg == "allcrack" then
    endphase_ralf_open_doors(sokoarea_number)
    endphase_allcrack(sokoarea_number)
  elseif alg == "fourswitch" then
    endphase_fourswitch(sokoarea_number)
  elseif alg == "vortex" then
    endphase_ralf_open_doors(sokoarea_number)
    endphase_vortex(sokoarea_number)
  elseif alg == "gradients" then
    endphase_set_hide_oxyds(sokoarea_number)
    endphase_gradients(sokoarea_number, param)
  elseif alg == "magnets" then
    endphase_set_hide_oxyds(sokoarea_number)
    endphase_magnets(sokoarea_number, param)
  elseif alg == "knock" then
    -- don't do anything; endphase_call_knock_item
    -- queries endphase_started.
  else
    -- use default: "circle"
    endphase_circle(sokoarea_number)
  end
end

function endphase_redraw_level_array(sokoarea_number)
  local nr = sokoarea_number or 1
  local endp = luatools.deep_copy(sokoarea[nr].design.endp)
  local dx = sokoarea[nr].offset.x
  local dy = sokoarea[nr].offset.y

  -- small routine to check the walls and outside
  local function is_oxyd_or_blocker(x,y)
    if sokoarea[nr].list_oxyd[x.."/"..y] then
      return true
    elseif sokoarea[nr].list_blocker[x.."/"..y] then
      return true
    end
    return false
  end
  
  -- redraw outside
  for p, v in pairs(sokoarea[nr].list_outside) do
    if not is_oxyd_or_blocker(v.lx, v.ly) then
      set_element(v.lx, v.ly, nr, k, endp.outf)
    end
  end
  
  -- redraw the rest inside level_array:
  for y = 0, sokoarea[nr].array_height - 1 do
    for x = 0, sokoarea[nr].array_width - 1 do
      if not is_oxyd_or_blocker(x+dx, y+dy) then
        local ch = sokoarea[nr].level_array[y+1][x+1]
        for k, v in pairs(endp) do
          if    ((k == "inf")  and char_is_inf(ch))
             or ((k == "wall") and char_is_wall(ch))
             or ((k == "goal") and char_is_goal(ch)) then
            set_element(x+dx, y+dy, nr, k, v)
          end
        end
      end
    end
  end
  
  -- if existent, redraw blocker floors
  if (sokoarea[nr].list_blocker) and (endp.inf) then
    for p, v in pairs(sokoarea[nr].list_blocker) do
      set_element(v.lx, v.ly, nr, "inf", endp.inf)
    end
  end 
end

------------------------------------------------------------------------
-- Endphase Games and Algorithms
------------------------------------------------------------------------

function endphase_circle(sokoarea_number)
  local acname = "marble_"..sokoarea_number.."_1"
  local flavor = sokoarea[sokoarea_number].design.oxyd or "b"
  local actor = enigma.GetNamedObject(acname)
  if not actor then
    acname = "marble"
    actor = enigma.GetNamedObject(acname)
    if not actor then
      myerror("No marble found. Please name it 'marble'.")  
    end
  end
  local x, y = enigma.GetPos(actor)
  if x > 10 then
    x = x - 2
  end
  if y > 6 then
    y = y - 2
  end
  for j = 0, 2 do
    set_oxyd(sokoarea_number, {lx = x+j, ly = y-1}, flavor, 2*j)
    set_oxyd(sokoarea_number, {lx = x-1, ly = y+j}, flavor, 2*j)
    set_oxyd(sokoarea_number, {lx = x+j, ly = y+3}, flavor, 2*j+1)
    set_oxyd(sokoarea_number, {lx = x+3, ly = y+j}, flavor, 2*j+1)
    for k = 0, 2 do
      kill_stone(x+j, y+k)
      kill_item(x+j, y+k)
      set_element(x+j, y+k, sokoarea_number, "inf")
    end
  end
  set_stone("st-fart", x+1, y+1, {_sokoarea = sokoarea_number})
  oxyd_shuffle()
end

-- endphase_set_outside_oxyds distributes oxyds over the outside and
-- wall_two-area of the level. There will be 2 to 5 pairs of oxyds
-- depending on the amount of space. PARAM may define a maximal
-- number of oxyd pairs (good for outf = "fl-space").
function endphase_set_outside_oxyds(sokoarea_number, param)
  local places = {}
  local nr = sokoarea_number or 1
  local dx = sokoarea[nr].offset.x
  local dy = sokoarea[nr].offset.y
  local mx = sokoarea[nr].array_width
  local my = sokoarea[nr].array_height
  local flavor = sokoarea[nr].design.oxyd or "b"

  -- Select all places outside or in the walls, unreachable
  -- for the marble.
  for p, v in pairs(luatools.combine_tables(sokoarea[nr].list_outside,
                sokoarea[nr].list_wall_two)) do
    if (mod(v.lx, 2) == 0) and (mod(v.ly, 2) == 0) then
      table.insert(places, v)
    end
  end

  -- Choose some appropriate subset
  local max = table.getn(places)
  local number_pairs = 2
  if max < 2 then
    -- Not enough places? Then choose corners of level_array.
    -- They should always be at least wall_two and far enough
    -- away from each other.
    places = { {lx = dx,           ly = dy},
               {lx = dx + mx - 1,  ly = dy},
               {lx = dx,           ly = dy + my - 1},
               {lx = dx + mx - 1,  ly = dy + my - 1} }
  elseif max <  20 then  number_pairs = 2
  elseif max <  50 then  number_pairs = 3
  elseif max < 100 then  number_pairs = 4
  else                   number_pairs = 5
  end
  if (type(param) ~= "nil") and (param ~= "") then
    local max_pairs = tonumber(param)
    if max_pairs then
      number_pairs = math.min(max_pairs, number_pairs)
    end    
  end

  luatools.shuffle_table(places)

  for j = 1, number_pairs do
    set_oxyd(sokoarea_number, luatools.deep_copy(places[2*j-1]), flavor, j - 1)
    set_oxyd(sokoarea_number, luatools.deep_copy(places[2*j]), flavor, j - 1)
  end
  oxyd_shuffle()
end

function endphase_set_block_oxyds(sokoarea_number, blocker, max_pairs)
  local oxyds = {}
  local nr = sokoarea_number or 1
  local flavor = sokoarea[nr].design.oxyd or "b"

  -- Add all wall_one-elements with exactly one way near as blocker,
  -- and the opposite position as oxyd, if it is of type wall_two.
  -- Make sure that each possible oxyd position is assigned at most once,
  -- and that no other oxyds or blockers are near.
  local function opposite_as_oxyd(x, y, dx, dy)
    if     sokoarea[nr].list_way[(x+dx).."/"..(y+dy)]
       and sokoarea[nr].list_wall_two[(x-dx).."/"..(y-dy)] then
      -- Check that no oxyd has been set on this position before
      -- and no other oxyd or blocker is near the new oxyd or its
      -- blocker.
      for j, w in pairs(oxyds) do
        if    (luatools.manhattan_distance(w.blocker.lx, w.blocker.ly, x, y) <= 1)
           or (luatools.manhattan_distance(w.lx, w.ly, x, y) <= 1)
           or (luatools.manhattan_distance(w.blocker.lx, w.blocker.ly, x-dx, y-dy) <= 1)
           or (luatools.manhattan_distance(w.lx, w.ly, x-dx, y-dy) <= 1) then
          return false
        end
      end
      table.insert(oxyds,
         {lx = x-dx, ly = y-dy,
          blocker = {lx = x, ly = y, oxyd = {lx = x-dx, ly = y-dy}},
          way = {lx = x+dx, ly = y+dy}})
      return true
    end
    return false
  end
  for p, v in pairs(sokoarea[nr].list_wall_one) do
    if v.count == 1 then
      opposite_as_oxyd(v.lx, v.ly, -1,  0)
      opposite_as_oxyd(v.lx, v.ly,  1,  0)
      opposite_as_oxyd(v.lx, v.ly,  0, -1)
      opposite_as_oxyd(v.lx, v.ly,  0,  1)
    end
  end

  -- Choose some appropriate subset
  local max = table.getn(oxyds)
  local number_pairs = 2
  if max < 4 then
    -- Not enough places? Choose "circle"-algorithm instead.
    sokoarea[nr].endp.alg = "circle"
    return
  elseif max <  8 then  number_pairs = 2
  elseif max < 16 then  number_pairs = 3
  elseif max < 28 then  number_pairs = 4
  else                  number_pairs = 5
  end
  if (type(max_pairs) ~= "nil") and (max_pairs ~= "") then
    if tonumber(max_pairs) >= 1 then
      number_pairs = math.min(tonumber(max_pairs), number_pairs)
    end    
  end

  luatools.shuffle_table(oxyds)

  -- set oxyds and blockers
  local function set_block(w)
    local myblocker = luatools.deep_copy(blocker)
    -- if there's an entry "st-door", choose between st-door-h and st-door-v.
    if type(myblocker) == "string" then
      myblocker = {myblocker}
    end
    for j, v in pairs(myblocker) do
      if v == "st-door" then
        if w.lx == w.oxyd.lx then
          myblocker[j] = "st-door-h"
        else
          myblocker[j] = "st-door-v"
        end        
      end
    end
    -- now set in-floor and blocker, and add to list_blocker.
    set_element(w.lx, w.ly, nr, "inf")
    set_element(w.lx, w.ly, nr, "", myblocker)
    sokoarea[nr].list_blocker[(w.lx).."/"..(w.ly)] = luatools.deep_copy(w)
  end
  for j = 1, number_pairs do   -- Testlevel: 14
    set_oxyd(nr, luatools.deep_copy(oxyds[2*j-1]), flavor, j - 1)
    set_oxyd(nr, luatools.deep_copy(oxyds[2*j]), flavor, j - 1)
    set_block(oxyds[2*j-1].blocker)
    set_block(oxyds[2*j].blocker)
  end
  oxyd_shuffle()

  -- assign goals to blockers
  -- Note: There might be more goals as blockers, and, vice versa,
  --       there might be more blockers as goals.
  local goal_table = {}
  for p, v in pairs(sokoarea[nr].list_goal) do
    table.insert(goal_table, v)
  end
  luatools.shuffle_table(goal_table)
  for j = 2, math.min(table.getn(goal_table), table.getn(oxyds)) do
    sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
  end
end

-- endphase_set_hide_oxyds distributes oxyds over the wall_one-walls.
-- PARAM is a maximal number of oxyd pairs.
function endphase_set_hide_oxyds(sokoarea_number, param)
  local flavor = sokoarea[sokoarea_number].design.oxyd or "b"
  local places = {}
  
  -- add all wall_one-elements
  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
    table.insert(places, v)
  end

  luatools.shuffle_table(places)
  
  -- choose number of oxyds
  local max = table.getn(places)
  local number_pairs = 1
  if max < 2 then
    -- use circle instead
    endphase_circle(sokoarea)
    return
  elseif max <  6  then  number_pairs = 2
  elseif max < 10  then  number_pairs = 3
  elseif max < 30  then  number_pairs = 4
  else                   number_pairs = 5 end
  if (type(param) ~= "nil") and (param ~= "") then
    local max_pairs = tonumber(param)
    if max_pairs then
      number_pairs = math.min(max_pairs, number_pairs)
    end    
  end
  
  -- set oxyds
  for j = 1, number_pairs do
    set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
    set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
  end
  oxyd_shuffle()  
end

function endphase_gradients(sokoarea_number, param)
  local force = tonumber(param) or 25.0
  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
    local grad_type = random(1,12)
    set_floor("fl-gradient", v.lx, v.ly, {type = grad_type, force = force})
  end
end

function endphase_magnets(sokoarea_number, param)
  local force = tonumber(param) or 50.0
  local places = {}
  local nr = sokoarea_number or 1
  local flavor = sokoarea[nr].design.oxyd or "b"

  -- add all way-elements which are not goals
  for p, v in pairs(sokoarea[nr].list_way) do
    if not char_is_goal(sokoarea[nr].level_array[v.ay][v.ax]) then
      table.insert(places, v)
    end
  end

  luatools.shuffle_table(places)

  -- choose number of magnets
  local number_magnets = math.floor(table.getn(places)/6)

  -- set magnets
  for j = 1, number_magnets do
    set_item("it-magnet-on", places[j].lx, places[j].ly,
             {range = 5, strength = force})
  end
end

function endphase_fourswitch(sokoarea_number)
  local flavor = sokoarea[sokoarea_number].design.oxyd or "b"
  local places = {}

  -- add all wall_one-elements
  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
    table.insert(places, v)
  end

  luatools.shuffle_table(places)

  -- choose number of fourswitchs/oxyds
  local max = table.getn(places)
  local number_pairs = 1
  if max < 2 then
    -- use circle instead
    endphase_circle(sokoarea_number)
    return
  elseif max <  6  then  number_pairs = 2
  elseif max < 10  then  number_pairs = 3
  else                   number_pairs = 4 end
  
  -- set fourswitchs
  for j = 1, 2*number_pairs do
    set_stone("st-fourswitch", places[j].lx, places[j].ly,
        {action="callback", target="endphase_call_fourswitch", _number=j,
         _sokoarea = sokoarea_number})
    places[j].current = 4
    places[j].solve = random(1,4)
    places[j].correct = false
  end
  places.number_pairs = number_pairs
  sokoarea[sokoarea_number].places = luatools.deep_copy(places)
end

function endphase_call_fourswitch(onoff, sender)
  local j = enigma.GetAttrib(sender, "_number")
  local nr = enigma.GetAttrib(sender, "_sokoarea")
  local places = sokoarea[nr].places

  -- When fourswitch is knocked, count it.
  places[j].current = places[j].current + 1
  if places[j].current == 5 then
    places[j].current = 1
  end
  
  -- When count is correct, make it "st-likeoxyda-open".
  if places[j].current == places[j].solve then
    places[j].correct = true
    set_stone("st-likeoxyda-open", places[j].lx, places[j].ly,
        {_number = 0, _sokoarea = sokoarea_number})
  end

  -- Now the difficult part: If it's the first fourswitch (the one
  -- fourswitch that doesn't change any other), check all fourswitchs
  -- and replace them by oxyds if all are correct. Else, recreate the
  -- next fourswitch in hierarchy, set it to the old number, then
  -- set the callback function and call it once by triggering another
  -- time (making it show the new number). This means: Recursion!
  if j ~= 1 then
    -- Trigger all lower fourswitchs
    local x = places[j-1].lx
    local y = places[j-1].ly
    if places[j-1].correct then
      -- reset the fourswitch
      mystone = set_stone("st-fourswitch", x, y,
        {_number = j - 1, _sokoarea = sokoarea_number})
      for k = 1, places[j-1].current do
        SendMessage(mystone, "trigger")
      end
      enigma.SetAttrib(mystone, "action", "callback")
      enigma.SetAttrib(mystone, "target", "endphase_call_fourswitch")
      places[j-1].correct = false
    end
    SendMessage(enigma.GetStone(x, y), "trigger")
  else
    -- Check all fourswitchs
    local correct = true
    for k = 1, 2*places.number_pairs do
      correct = correct and places[k].correct
    end
    if correct then
      -- replace fourswitchs by oxyds
      for k = 1, places.number_pairs do
        set_oxyd(sokoarea_number, places[2*k-1], flavor, k - 1)
        set_oxyd(sokoarea_number, places[2*k], flavor, k - 1)
      end
      oxyd_shuffle()
    end
  end  
end


function endphase_allcrack(sokoarea_number)
  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
    if not enigma.GetItem(v.lx, v.ly) then
      set_item("it-crack3", v.lx, v.ly)
    end
  end  
end

function endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
    goals_filled, number_goals)
  local nr = sokoarea_number or 1
  -- verify correct sokoarea-number and existence of "goal_to_blocker"
  if nr ~= enigma.GetAttrib(sender, "_sokoarea") then
    myerror("libsoko: Inconsistent sokoarea numbers in goal hook!")
  end
  if type(sokoarea[nr].goal_to_blocker) ~= "table" then
    myerror("libsoko: Blocker list is missing during goal hook!")
  end
  -- identify the corresponding door and open it
  local goal_number = enigma.GetAttrib(sender, "_goal_number")
  local blocker = sokoarea[nr].goal_to_blocker[goal_number]
  if blocker then
    endphase_ralf_open_door(nr, more_boxes, blocker.lx, blocker.ly)  
  end
end

function endphase_ralf_open_doors(sokoarea_number)
  for p, v in pairs(sokoarea[sokoarea_number].list_blocker) do
    endphase_ralf_open_door(sokoarea_number, true, v.lx, v.ly)
  end
end

-- endphase_ralf_open_door opens or closes a door at position
-- (X,Y), dependend on the boolean OPEN.
function endphase_ralf_open_door(sokoarea_number, open, x, y)
  local door_kind = sokoarea[sokoarea_number].design.endp.open_door
  if door_kind then
    if not open then
      door_kind =    sokoarea[sokoarea_number].design.door
                  or sokoarea[sokoarea_number].design.wall or "st-none"
    end
    set_element(x, y, sokoarea_number, "", door_kind)
  else
    -- use default "open"/"close"-messages instead
    local st = enigma.GetStone(x, y)
    local it = enigma.GetItem(x, y)
    local fl = enigma.GetFloor(x, y)
    if st and enigma.GetAttrib(st, "_sokoarea") then
      SendMessage(st, luatools.cond(open, "open", "close"))
    end
    if it and enigma.GetAttrib(it, "_sokoarea") then
      SendMessage(it, luatools.cond(open, "open", "close"))
    end
    if fl then
      SendMessage(fl, luatools.cond(open, "close", "open"))
    end
  end  
end

function endphase_vortex(sokoarea_number)
  local nr = sokoarea_number or 1
  local list_way = 
    luatools.combine_tables(sokoarea[nr].list_way, sokoarea[nr].list_blocker)
  local components = 0
  local component = {}

  -- Remove old component-entries, in case there are still some left.
  for p, v in pairs(list_way) do
    list_way[p].component = nil
  end

  -- Analyse connected components of list_way, separated by goals.
  local function mark_component(lx, ly)
    if     (list_way[lx.."/"..ly])
       and (not list_way[lx.."/"..ly].component)
       and (not sokoarea[nr].list_goal[lx.."/"..ly]) then
      list_way[lx.."/"..ly].component = components
      --set_floor(({"fl-leaves", "fl-ice", "fl-red", "fl-black", "fl-white",
      --    "fl-sahara", "fl-light", "fl-gray", "fl-lightgray", "fl-rough",
      --    "fl-marble", "fl-tigris"})[components] or "fl-sand", lx, ly)
      table.insert(component[components], {lx = lx, ly = ly})
      mark_component(lx+1, ly)
      mark_component(lx-1, ly)
      mark_component(lx, ly+1)
      mark_component(lx, ly-1)
    end
  end
  for p, v in pairs(list_way) do
    if (not list_way[p].component) and (not sokoarea[nr].list_goal[p]) then
      components = components + 1
      component[components] = {oxyds = 0}
      mark_component(v.lx, v.ly)      
    end    
  end

  -- If only one component, exit, player will find his or her way alone.
  if components < 2 then
    return
  end

  -- Analyse oxyds and to which components they belong to.
  for p, v in pairs(sokoarea[nr].list_oxyd) do
    local component_number = list_way[v.blocker.lx.."/"..v.blocker.ly].component or -1
    if component_number == -1 then
      set_item("it-banana", v.blocker.lx, v.blocker.ly)
      mydebug("Banana on "..v.blocker.lx.."/"..v.blocker.ly)
    else
      component[component_number].oxyds = component[component_number].oxyds + 1
    end
  end  

  -- Let there be at most max(5, number-of-oxyd-components)
  -- components, plus the one the marble actually occupies.
  local t = {}  -- helper table: components with oxyds or marble
  local u = {}  -- helper table: all components except t
  local mx, my = enigma.GetPos(enigma.GetNamedObject("marble_"..nr.."_1"))
  local marble_component = (list_way[mx.."/"..my] or {}).component
  for j = 1, components do
    if (component[j].oxyds > 0) or (j == marble_component) then
      table.insert(t, component[j])
    else
      table.insert(u, component[j])
    end
  end
  luatools.shuffle_table(u)
  while (table.getn(t) < 5) and (table.getn(u) > 0) do
    table.insert(t, u[table.getn(u)])
    table.remove(u)
  end
  component = t
  components = table.getn(component)
  u = nil

  -- From each component, choose one tile and save the {lx,ly}-entry
  local vortex = {}
  for j = 1, components do
    table.insert(vortex, component[j][random(1, table.getn(component[j]))])
  end
  
  -- Find a cyclic permutation (i.e. with only one cycle) to connect the
  -- vortices (each vortex shall be reached by starting from any other).
  local connect = luatools.cyclic_permutation(components)

  -- Now set and connect the vortices
  for j, v in pairs(vortex) do
    local w = vortex[connect[j]]
    -- Remember: We also allow (we need!) vortices at old blocker-positions.
    -- There could still be a stone over this. This stone might be st-blocker,
    -- which turns to it-blocker and has therefore to be removed. Better
    -- we remove all stones:
    kill_stone(v.lx, v.ly)
    set_item("it-vortex-open", v.lx, v.ly, {targetx = w.lx, targety = w.ly})
  end  
end

function endphase_set_knocking(sokoarea_number, param)
  local nr = sokoarea_number
  local flavor = sokoarea[nr].design.oxyd or "b"
  local places = {}
  local itemkind = param
  if (itemkind == nil) or (itemkind == "") then
    itemkind = "it-sensor"
  end

  -- add all blockers
  for p, v in pairs(sokoarea[nr].list_blocker) do
    table.insert(places, v)
  end

  luatools.shuffle_table(places)
  
  -- set items (for Enigma 1.0), set attributes of door (>= 1.1)
  for j, v in pairs(places) do
    set_item(itemkind, v.lx, v.ly, {action="callback",
        target="endphase_call_knocking", _number=j, _sokoarea=nr})
    local st = enigma.GetStone(v.lx, v.ly)
    if st then
      enigma.SetAttrib(st, "action", "callback")
      enigma.SetAttrib(st, "target", "endphase_call_knocking")
      local closepos = places[luatools.mod(j, table.getn(places)) + 1]
      local openpos = places[luatools.mod(j+1, table.getn(places)) + 1]
      enigma.SetAttrib(st, "_close_x", closepos.lx)
      enigma.SetAttrib(st, "_close_y", closepos.ly)
      enigma.SetAttrib(st, "_open_x", openpos.lx)
      enigma.SetAttrib(st, "_open_y", openpos.ly)
      --enigma.SetAttrib(st, "_close",
      --  luatools.deep_copy(places[luatools.mod(j+1, table.getn(places)) + 1]))
      --enigma.SetAttrib(st, "_open",
      --  luatools.deep_copy(places[luatools.mod(j+2, table.getn(places)) + 1]))
    end
  end
end

function endphase_call_knocking(onoff, sender)
  local j = enigma.GetAttrib(sender, "_number")
  local nr = enigma.GetAttrib(sender, "_sokoarea")
  if (not nr) or (not j) then
    myerror("libsoko: Knocking's source has no number or no sokoarea.")
  end
  -- Check that it-sensor did not send its message because of
  -- the marble standing on it:
  local x, y = enigma.GetPos(sender)
  local mx, my = enigma.GetPos(enigma.GetNamedObject("marble_"..nr.."_1"))
  if (x == mx) and (y == my) then
    return
  end
  mydebug("Knocked on "..j.."/"..sokoarea[nr].number_oxyds)
  -- Deactivate the first door until endphase has started.
  if (j == 1) and (not sokoarea[nr].endphase_started) then
    mydebug("Door deactivated until endphase.")
    return
  end
  -- Get the door (possibly it already is sender), and open or close
  -- the neccessary doors given as attributes.
  local mydoor = enigma.GetStone(x, y)
  if enigma.GetAttrib(mydoor, "_sokoarea") == nr then
    local close_x = enigma.GetAttrib(mydoor, "_close_x")
    local close_y = enigma.GetAttrib(mydoor, "_close_y")
    local open_x = enigma.GetAttrib(mydoor, "_open_x")
    local open_y = enigma.GetAttrib(mydoor, "_open_y")
    local closedoor = enigma.GetStone(close_x, close_y)
    local opendoor = enigma.GetStone(open_x, open_y)
    if closedoor then
      SendMessage(closedoor, "close")
    end
    if opendoor then
      SendMessage(opendoor, "open")
    end
  end
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>


\input texinfo                              @c -*- texinfo -*-
@setfilename enigma-ref.info
@settitle Enigma Reference Manual
@titlepage
@title Enigma Reference Manual
@subtitle for version 1.10
@author Daniel Heck
@author Petr Machata
@author Ralf Westram
@author Ronald Lamprecht
@author Andreas Lochmann
@end titlepage

@defindex ob
@defindex at
@defindex ms

@contents

@ifnottex
@node Top
@top

This manual describes the internals of
@uref{http://www.nongnu.org/enigma/,Enigma} version 1.10, in particular how to
build new levels using Lua and how to interact with the game engine.
@end ifnottex

@menu
* Running Enigma::              Running Enigma
* Levelpack Basics::            Addition and managing of levels in packs 
* Level Basics::                Introduction to level description
* Enigma Paradigm::             Principles of world, objects and messages
* Lua API::                     Describing a level with all its objects and interactions
* Common Attributes and Messages::  What all objects support
* Floor Objects::               
* Item Objects::
* Stone Objects::
* Actor Objects::
* Other Objects::               Rubberbands, etc.
* Advanced Features::           Fire, ...
* Extension Development::       Resolver, Library Development
* Old API - Objects::           Description of all objects in Enigma
* Old API - Variables::         Lua variables that influence the game
* Old API - Functions::               Predefined functions
* Object Index::
* Attribute Index::
* Message Index::
* Function Index::
* Concept Index::
@end menu

@node  Running Enigma
@chapter Running Enigma

Hopefully, after successfully installing and playing some first levels, you may be interested in
some information about how we have configured Enigma, how you can optimize Enigma to your
needs, and the purpose of some options and attributes within Enigma.

This first chapter should give you some valuable information about these questions, and provide
some basic knowledge you will need to manage level packs, levels or write your own levels, as
described in the following chapters.

@menu
* Locating Resources::
* Startup Switches::
* User Options::
* Level Info::
* Handicap and PAR::           Background to score evaluation and HCP
* User Sound Sets::            How to create and install sound themes
@end menu

@node Locating Resources
@section Locating Resources

For reasons of backup, system changes, special configurations, level additions and hopefully
your own new levels, you may need to know where Enigma stores the resources and how you
can control them.

Enigma maintains several paths for control of load and storage of files. You
can list these paths either by pressing @key{F2} within the main menu, or by 
starting Enigma with the switch @option{--log} (@pxref{Startup Switches}) and looking at the
console output.

@table @asis
@cindex preferences path
@item @b{Preferences Path}
This is the path to the file that stores your preferences concerning application
options. This file is usually located at your @env{HOME} directory. For @env{HOME}-less
Windows users, it is stored in the @samp{Application Data\Enigma} directory. Since it is the
third version in the history of Enigma, the file is named 
@samp{.enigmarc.xml} by default. 

We recommend that you backup this file, although it contains only a few data that you can
quickly reconfigure.

Since these preferences are quite specific for the operating system and configuration, you will
use a different version on each Enigma installation you have.

Mainly for Enigma developers, a switch exists @option{--pref} (@pxref{Startup Switches})
to rename this preferences file. By starting Enigma with a renamed preferences
file, a developer can temporarily use a complete separate configuration for
testing purposes without the danger of destroying his main configuration. The
developer may use it to start Enigma with a plain standard configuration for
testing purposes, too.

In all cases, a leading @samp{.} will hide the preferences filename.

@cindex user path
@item @b{User Path}
This is the main path to the user's Enigma data. All updates, user-installed levels and user-
written levels, the user's scores, history and usually the user's screenshots and level previews,
are stored at this path.

A backup of this directory is mandatory!

The standard location is the directory @samp{.enigma} at your @env{HOME} 
directory. For @env{HOME}-less Windows users, it is the @samp{Application Data\Enigma} 
directory.

You can define your own path within the @ref{User Options}. By doing so, you can store your
Enigma user data on a memory stick or on a shared partition, and use them alternatively from
two Enigma installations.

@cindex user image path
@item @b{User Image Path}
This is a second path to the user's Enigma data, which you can use to access images such as
screenshots and thumbnails of levels. Usually this path is identical to the main @samp{User
Path}.

Just in case you make many screenshots and have limited resources on the main
@samp{User Path}, you may want to store the images on another path. You can 
define your own path within the @ref{User Options}.

@cindex system path
@item @b{System Path}
This path gives you the location of all system resources that are distributed with Enigma. Here
you will find the levels, libraries, etc. This is a first class address to look for examples if you start
writing your own levels.

@cindex resource paths
@item @b{Resource Paths}
This is a list of paths. The program looks up each version-independent resource on all paths in
this list, and loads from the first occurrence.

User data precedes system data; this way, updates on your user data path will win. Have a look
at this list if you are observing a difference between a source and the runtime behavior. You may
have looked at a file that another file had hidden on a preceding path in this list.

@cindex l10n path
@cindex localization path
@item @b{l10n Path}
This path shows the directory that contains the localization data.

@end table

Please note that some resources, like levels, may be zipped. In this case, a 
resource that you expect to find at @samp{dirname/filename} may be stored in a zipfile
named @samp{dirname.zip}. The path of the file within the zip can be either
@samp{dirname/filename} or @samp{./filename}. In case a resource is provided
in zipped and unzipped form, the plain file stored in a directory wins, since Enigma 
assumes it to to be an update to the zip.

@node Startup Switches
@section Startup Switches

Besides starting Enigma by clicking on an installation-provided icon or start menu entry, you
can start Enigma from a shell or commandline. With release 1.00, the Windows version
supports this feature without restrictions. Although playing the distributed levels using this
feature is not necessary, you may take advantage of this feature in special or advanced usage.

The following list explains the supported user options. If an option is listed with a long name
preceded by two minus signs, and with a one-character abbreviation preceded by one minus
sign, use one of the notations, not both together; for example,
@samp{--data path} or @samp{-d path}.

@table @asis
@item @b{-@w{}-assert}
A switch for Enigma developers that forces all debugging assertions, even
expensive ones, to be evaluated. The additionally evaluated checks look like
@samp{ASSERT(noAssert || long_lasting_check(), XLevelRuntime, "remark");}.

@item @b{-@w{}-data -d path}
A switch for Enigma developers that allows you to add an additional path to the
resource paths that precedes the system path (@pxref{Startup Switches}). A
developer can test an Enigma compilation, without installation, by calling it
from the shell with the current working directory on the main directory via
@samp{src/Enigma -d ./data}.

@item @b{-@w{}-help -h}
Just lists the available startup switches to the output and terminate.

@item @b{-@w{}-lang -l lang}
A switch that allows you to override any other language preference. The language
is given in the common 2-character sequence as @samp{fr} for French or @samp{ru}
for Russian.

@item @b{-@w{}-log}
This switch turns on logging of internal information to the standard output.
Windows users will find an file called @samp{stdout.txt} in the current working
directory. The output will, for example, list the paths described in @ref{Locating Resources}.

@item @b{-@w{}-nograb}
A switch for Enigma developers that causes Enigma not to grab the mouse. You can hardly
play a level in this mode, but it makes it possible to debug the
application in its core parts.

@item @b{-@w{}-nomusic}
Start Enigma without playing background music.

@item @b{-@w{}-nosound}
Start Enigma with sound being switched off.

@item @b{-@w{}-pref -p filename}
The name of an alternative preferences file without the leading dot for hidden
filenames. This switch is a pure Enigma developer support feature, as described
in @ref{Locating Resources}.

@item @b{-@w{}-pref -p dirpath}
The path of an alternative directory that contains the standard named preference
file @samp{.enigmarc.xml}. If no preference file exists or the directory does
not yet exist they are created. On creation of the preference file the user data
path is set to the given dirpath per default. This allows to store all Enigma
user data in a single directory that can be stored anywhere, e.g. on a USB stick.
You always need to call Enigma with the above switch to use this new set up.
Remember that a path with spaces needs to be quoted.

@item @b{-@w{}-showfps}
Show the framerate (FPS) during the game.

@item @b{-@w{}-version}
Just print the version number to the output and terminate.

@item @b{-@w{}-window -w}
Start Enigma in window mode instead of screen mode.

@end table

Enigma interprets all further arguments supplied on the commandline as level file
addresses. You can use absolute or relative addresses to level files stored
on your computer. Adding url's to levels stored in the internet is also possible.

A Unix user may start Enigma with the following command:

@code{enigma --log ~/mylevel.xml http://somewhere.com/netlevel.xml}

A Windows user may start Enigma from the command line (please adjust the Enigma
installation path):

@code{C:\programs\Enigma-1.00\enigma.exe demo_simple.xml} 

You will find these levels in a levelpack called @samp{Startup Levels}, which is
only visible by default if you supplied levels on the commandline.

@node User Options
@section User Options

@table @asis
@item @b{Ratings update}
Please retain this option on the value @samp{Never} until release of Enigma 1.00.

@item @b{User name}
Enter your user name, which Enigma will attach to your scores. Please look at
the Enigma home page for user names already in use and choose a new, unique name.
You can change your user name at anytime without losing any of your
scores.

@item @b{User path}
This textfield allows you to define an arbitrary directory for your Enigma user
data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

Enigma activates the new path when you leave the options menu. Though it stores all files
directly to the new path, and will still find files on the old path, you may want to quit Enigma
immediately and first copy/merge the old directory to the new location. This copy of your old
data is necessary, since with the next start, Enigma will locate user data at the new location
exclusively. 

@item @b{User image path}
This textfield allows you to define an arbitrary directory for your Enigma user
image data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

Enigma activates the new path when you leave the options menu. Though it has stored all files
directly to the new path and files will still be found on the old path, you may want to quit
Enigma immediately and first copy/merge the old directory to the new location. This copy of
your old data is necessary, since with the next start, Enigma will locate user data at the new
location exclusively.

@end table

@node Level Info
@section Level Info

@cindex levelinspector
For every level, Enigma manages more data than can be displayed in the level menu. You can
view them all with the levelinspector. You can call this special menu from within the level menu
by right or control clicking on the level icon.

Besides title and author, Enigma provides information concerning a public rating of the level,
different score values of interest, details on the level version, the level file location and more.
Additionally, the levelinspector allows you to enter personal annotations for a level. You can
review any screenshots you made for this level directly from the levelinspector, too.

@menu
* Public Ratings::
* Scores::
* Versions::
* Private Annotations and Ratings::
* Screenshots::
@end menu

@node Public Ratings
@subsection Public Ratings

Most levels are rated within five different categories:
@itemize @bullet
@item
int = Intelligence

@item
dex = Dexterity

@item
pat = Patience

@item
kno = Knowledge of Enigma

@item
spe = Speed and Speed control

@end itemize

To distinguish the ratings from their everyday-meanings, we use the following abbreviations for
the ratings. Each of these categories takes values between 1 (easy) and 5 (difficult), except kno,
which can also be 6 (unique mechanism).

Please bear in mind that it's not simple to retain the
following definitions in each of nearly 750 cases, so there
might be (will be) deviations from them in single levels.

@strong{Intelligence (int)}

This rating is intended to measure the creativity, planning and analytic requirements needed to
solve the level. Intelligence is a very difficult concept in itself, and thus at first not easy to rate or
to grasp. Consequently, a fixed definition of the five rating-degrees not only helps, but is
essential in the rating process. So, assume you know everything about the single elements of a
level. Then ask yourself these questions:
@itemize @bullet
@item
Can I see the solution at once? Yes -> int 1

@item
Do I only have to orient myself, for example, testing the exits of wormholes or to see the
function of a switch? -> int 2

@item
Is there a standard algorithm to solve the problem, like in a maze, or
searching for a hidden item? -> int 3

@item
Neither trial-and-error nor standard algorithms work; is it a simple
kind of code or does it require advance planning? -> int 4

@item
Is it a difficult code, pattern or causal chain? -> int 5

@end itemize

High values for intelligence are typically puzzles.
int-ratings do not accumulate; the most difficult puzzle
itself already determines the rating.

@strong{Dexterity (dex)}

You can solve many levels either by accuracy or by patience. In our context, we do not mean
dexterity in the sense of accuracy to avoid impatience, but accuracy to avoid death. So it focuses
on the lethal positions in a level, not only death-stones and abysses, but also casualties like
pushing a stone accidentally into an unreachable corner.

@itemize @bullet
@item
It doesn't matter what I touch, this level is damn-proof. -> dex 1

@item
Well, there are lethal positions I shouldn't move the level into, but
they are not difficult to overcome. -> dex 2

@item
Comparable to a single row with an abyss left and right. -> dex 3

@item
Comparable to pushing a stone to the right with an abyss on
the left, or a single row with death-stones left and right. ->
dex 4

@item
Needs lots of attempts to succeed. -> dex 5

@end itemize

In contrast to the int-rating, dex might accumulate: A level with many situations,
each of dex 3, can add up to dex 4 or even 5. This way, you can achieve dex 5.  
Rotors in a level also contribute to dex and to the
speed-rating, spe. Thus, levels with a high dex-spe-combination are
mostly action-driven, whereas a high dex-pat-combination typically is
a dangerous maze.

@strong{Patience (pat)}

Patience is a relatively subjective rating, and refers mostly to ``felt time'', how long it felt to
complete the level. So two levels with same mechanics can have different pat-values, e.g., if one
level has a nicer design or shows the progress of the level in some way, like the number of
opened oxyds. It explicitly includes having to restart the level repeatedly; not the time in the
lower left corner or the score is crucial, but the complete ``felt time'' needed to solve the level,
starting from the first look at it.
@itemize @bullet
@item
I solved the level right after understanding it. -> pat 1

@item
I needed some time, but it wasn't boring. -> pat 2

@item
Okay, it took some minutes, but the landscape is nice @enddots{} -> pat 3

@item
I know what to do, but it doesn't seem to end. -> pat 4

@item
This level really requires discipline. -> pat 5

@end itemize

A high number of oxyds can heighten the pat-value and also lower it: If the player has to
traverse the level several times to open matching pairs of oxyds, it is definitely pat-heightening.
However, if oxyds are arranged to mark the progress of the player, and act as a kind of small
reward within the level, they can lower the pat-value. It's the same with a high number of doors:
The arrangement is the critical factor.

High pat-values are typically mazes. In combination with int 3, a high
pat-value can indicate a hidden item or a hollow stone. pat-values
involve the whole level, so they can't accumulate.

@strong{Knowledge of Enigma (kno)}

The kno-rating mostly takes on the function and interactions of single
objects in the game, like stones, floors, items, and actors. However,
in some cases it also deals with special techniques. The guideline is
the ``Advanced Tutorial'', which defines kno 3. kno 4 corresponds to
standard objects that aren't shown in the tutorial; kno 5 requires a
deeper knowledge of the game internals. Finally, kno 6 indicates
special mechanisms, that are seldom encountered or unique. The overall kno-rating
of a level equals that of the most difficult object or technique (and
thus is non-accumulative):
@enumerate
@item
Moving a single marble on normal floors, normal walls, oxyds,
stones that look like oxyds, death-stones, water, an abyss, documents,
using the inventory, static gravity, visible gradients.

@item
Pushing stones, simple Sokoban-tricks, bridge-building in water
and an abyss, connected puzzle-stones, moving more than one marble,
meditations, grates, rotors and tops, hidden gradients, triggers and
switches, doors, holes (not made by dynamite), swamp, floppies and
st-floppy, keys and locks, coins and slots, cracks, timer-stones.

@item
Different floors can have different fraction and mouseforce, space,
ice, inverted floor, some stones sink while others swim, black grates
that hold rotors and tops away, dynamite, dynamite-breakable stones,
spade, bolders, magic-wand to change bolder-direction, bolders sink
into an abyss, sheets of glass, spoon, actors and items may hide under
movable stones, small not-killer whiteballs, coloured one-way-streets,
actorimpulse-stones (``bumpers''), rotors can fly over an abyss,
fart-stones, swords and knights, lasers, static and movable mirrors,
item- and coin-transformations by pushing stones over them and by
using lasers, umbrellas protect in an abyss, hammer and breakable stones
(although not in the tutorial).

@item
Bridge-building in swamps, rubber-bands, rubber-band-stones,
scissor-stones, unconnected puzzle-stones, exploding puzzle-stones,
turning puzzle-stones (with and without a magic wand), springs (both
types, on the floor and hole-kind springs like in ``Upstream
Journey''), thieves, three-part shogun-stones, invisible stones,
hollow stones, chameleon-stones, items hidden under chameleon stones,
stones that aren't what they seem (e.g., fake-death-stones), wormholes,
magnets, using F3 for a restart to solve a level, yin-yangs,
one-color-, yin-yang- and inverted yin-yang-stones, stones breakable
by only one color, killer-balls, swap-stones, brush and paintable
stones, changing one-way-streets with a magic wand, changing stones to
glass with a magic wand, impulse-stones (movable, static and hollow),
black and white bombs, bomb-stones, fire, extinguishers,
rotator-stones, yellow anti-swapping stones, mines, flags, seeds,
weights, putting objects under one-way-streets and other hollow
stones, electric stones, turnstiles, mailing and pipes, rings (single
and multiplayer), volcanos, bags, randomizers (as possible effect of a
switch), horses (the actors) and horse-passing stones, pins, bananas, cherries
can make you invisible, surprise-item.

@item
Cracks, floor-springs, wormholes, etc., are all items, seeds can grow
inside stones, the laser is blocked by all items, killer-balls don't sink
in water, ``Space Meditation''-kind collisions, holding down the
mouse-button, invisibility lets you go through glass, jumping over
lasers @enddots{}

@item
Spitter-stones, surprise-stones, levels like ``Enigris'' or ``Flood
Gates'' @enddots{}

@end enumerate

kno 6 does not necessarily mean that this level is difficult to
understand; the unique mechanism or object might also be very
intuitive, like in ``Flood Gates''.

@strong{Speed and speed control (spe)}

The spe-value corresponds not only to the maximum speed a level
requires (like you need to run away from a rotor), but also the
degree of control a player has over his mouse while moving it;
excellent examples for this are ``Mourning Palace'' and the middle
part of ``Sacrifice''. This involves moving the mouse at a constant
velocity for a long time, as well as correctly estimating the speed
that's needed in a certain task, like shattering a sheet of glass.

@enumerate
@item
No time limit. 

@item
You shouldn't stop for too long. For example, something slow might
be chasing you.

@item
There is an appropriate time limit or speed control task. This can
be a single, not-too-fast rotor in an open area.

@item
Don't stop! Examples include difficult timing-tasks as well as a single
fast rotor or several slower ones.

@item
Hurry Up! Whereas spe 4 is meant to be difficult, but obviously
solvable in not too many attempts, spe 5 is everything beyond this.

@end enumerate

The spe-rating again is cumulative, since many slow rotors can add up
to spe 3 or 4, or a combination of many slow time-switches to be
pressed in a certain order can create a horrible task. In contrast to
the other categories, for which the average is near 3 (or between 3
and 4 for kno), most levels are definitely
spe 1. So, the spe-rating is more a supplement to the three
core-ratings int, dex and pat.

@strong{Combinations of ratings}

Sometimes, it can be interesting to have a single value to measure the difficulty of a level. To
calculate such a universal rating, a simple possibility is choosing a linear combination of the 5
single ratings, weighted with appropriate weights. These weights should correspond to the
difficulty a single category adds to the universal difficulty. Yet you should also choose these
weights carefully to avoid number-theoretic obstructions (e.g., when all weights are even except
for the spe-rating, then there will be a visible difference in the distribution of even and odd
universal ratings, which can be very misleading). A working, and very interesting linear
combination, is the following, which has been applied in the reordering process:


@example
universal difficulty  =  7*int + 6*dex + 4*pat + 3*kno + 4*spe - 23
@end example

This has a special property, in that it takes relatively broad and continuously distributed values
between 1 (all ratings 1) and 100 (all ratings 5, kno 6) and emphasizes the most difficult
categories, intelligence and dexterity. However, some very low or very high values cannot
appear in this combination, such as 2 or 99. Other combinations lead to full but narrow, or to
broad but noncontinuous spectra.

@node Scores
@subsection Scores

The score columns show your and some comparison values for the difficult and
for the easy mode, if the levels supports it.

The world record is the best score that was retransmitted to the Enigma team.
The world record holders are listed below.

The PAR value is the ``professional average rating'' of the level. It is the harmonic average of all
scores that Enigma players have retransmitted. However, we take into account only scores from
players who have solved a certain number of levels. Opposed to the world record, which will be
very difficult to gain, the PAR value is a much more realistic aim for an ambitious player. If you
are equal or better than PAR, the levels are marked with a speeding blackball within the level
menu.

The author's value is another reference score. Most authors are not keen on holding the world
record of their own levels. However, they will likely know the fastest way to solve the level. If
your score is much higher than the author's score, a simpler solution to solve the level may
exist.

The solved number is the number of players who solved this level in the given
score version.

The solved percentage is the relation of the number of players who solved this
level to the number of players who retransmitted scores. Actually, we take into
account only those players who could have solved the level. For example, players
who did retransmit scores before the level was written, without updating
afterwards, are not taken into account. A low percentage is a hint that a level
is not easy to solve.

@node Versions
@subsection Versions

The version column shows detailed information about the level. Read the chapter Level
Basics node @pxref{<version>} and @pxref{<modes>} for an explanation of the
values.

For you as a player, the @samp{Score} version number can be interesting.
A level you had solved with a certain score may appear with a red triangle in the level menu in
an updated Enigma release of the level. Although the level menu displays the medals showing
that you solved the level, it will not display the score values anymore. This is due to an
incompatible level update that requires a new solution with different, incomparable score
values. The author will increase the score version number in such a case.

@node Private Annotations and Ratings
@subsection Private Annotations and Ratings

This textfield allows you to enter an annotation for a level that you can review
on later replays. Note that the current textfield is limited (it may not allow you to enter all
characters, and needs the mouse cursor to remain within its boundaries). Yet it should work for
entering short annotations that may be very useful later.

Enigma stores annotations in your private applications @samp{state.xml} file. It permits one
annotation per level, independent of the level version.

You may rate the levels, too. Just click on the ratings button. Values go from
0 to 10 with an additional @samp{-} for abstention. 0 stands for a poor level
that you think is not worth playing, 5 for an average level and 10 for the
ultimate, best levels. Try to use all values in your ratings.

Enigma stores the ratings with the scores and evaluates them anonymously. Enigma displays
the resulting average rating of all users, for your information. Note that different ratings are
possible for different score versions of the same level, because levels may improve as a result of
suggestions by users. If you do not re-rate a new version of a level, Enigma inherits your rating
from a previous version.

@node Screenshots
@subsection Screenshots

While playing a level, you can make screenshots by pressing @key{F10}. You can make
several screenshots in sequence for documentation purposes. Enigma will store each
with a unique image filename. Using the level inspector, you can view the screenshots directly
from within Enigma. Just click on the screenshot button to
view the first image. 

Because any buttons would disturb the view of a screenshot, all functions are keyboard
commands. Press @key{F1} to get a help screen. @key{ESC} returns to the level inspector. 
@key{Page Up} and @key{Page Down} will show the previous and next screenshot.
If you scroll down behind the last screenshot, the ``missing'' screenshot file is named.
This may be a useful hint as to where to search the other screenshot files on your
@samp{user image path} (@pxref{Locating Resources}).

@node Handicap and PAR
@section Handicap and PAR

As PAR (@pxref{Scores}) describes the difficulty of a level, the handicap @samp{hcp}
describes your ability to solve levels in PAR. The handicap is always related
to a levelpack or group of levelpacks. You can see your handicap for each levelpack in the level
menu, if you select the PAR mode by clicking on the lower
left button until the speeding black marble appears. The value is displayed in
the upper right corner, with the number of levels you solved in PAR.

The handicap is similar to the golfer's handicap. A low value is better than a
high value. If you solve all levels exactly in PAR, your handicap will be 0. If
you are even better than PAR, your handicap will be negative. Players can use
this value to compare their overall abilities.

Just for those of you that want to know the details of this score rating system
of PAR and handicap, here is some additional information, which others may skip and
continue with the next chapter @ref{Levelpack Basics}.

We request all users to send their scores. All scores are evaluated for world
records and counts of level solution rates and numbers. 

However, for the PAR calculation, we take into account only scores from users who have solved
more than a certain percentage of levels (currently about 10% of the levels). For every level, we
calculate the harmonic average of the scores of these 
@samp{professionals}. We take professionals who did not solve a level into account with the
10-fold world record score. The harmonic average calculates as

harm.avg. = N / (sum_[j=1..N] 1/score_j) )

It weights small (short) times with a greater weight than large (long) solution times.

The handicap is a sum of values that describe your scores in relationship to the PAR value of a
level. Since it has to take into account that you have no score at all or that no PAR value exists,
we apply some exception rules to the addends:

@multitable @columnfractions .1 .15 .75
@item @bullet{ } @tab + 1.0 @tab for each unsolved level
@item @bullet{ } @tab + log10(score/par) @tab for each solved level with existing par if score >= par
@item @bullet{ } @tab + 0.7 @tab as upper limit for each solved level with existing par if score >= par
@item @bullet{ } @tab + log2(score/par) @tab for each solved level with existing par if score < par
@item @bullet{ } @tab - 3.0 @tab as lower limit and as value for levels without par
@end multitable

Note that each score that is better than PAR results in a negative addend and
thus reduces your handicap. For a levelpack with 100 levels, the handicap will
be in the range of +100 to -300. For levelpacks with more or fewer levels, Enigma
will scale the sum by a factor 100/size to result in comparable handicap values.
Handicaps are stated with one digit behind the decimal point.


@node User Sound Sets
@section User Sound Sets

(The following information accounts only for Enigma 1.01 and above.)
Sound effects are triggered by so-called @samp{sound events}. These sound
events usually have a name (like @samp{dooropen}) and an associated location
(the coordinates of the door) which affects the way a sound effect is
played. The collection of all sound files, their assignment to sound events,
and some additional information how to play them is called a @samp{sound set}.

You can use own sound files to create own sound sets for Enigma, and choose
among them in the options menu (entry @samp{Sound set}). You can distribute
these sound sets under your own choice of license and install sound sets from
other users. There is no internal limit for the number of installed sound sets.

The sound event is converted into a real sound effect using tables, you can
find such tables in the @samp{data/sound-defaults.lua} file and in the empty
sample file at @samp{reference/soundset.lua}. Each entry in these tables is
either a string like @samp{enigma/st-coinslot}, which is interpreted as the
file @samp{soundsets/enigma/st-coinslot.wav} with some default properties, or a
list of sound attributes enclosed in curly braces. Sound events triggered with
@ref{enigma.EmitSound} are converted the same way. Here is an example of such an
entry:

@example
dooropen = @{ file="my_soundset/open-door", volume=0.9, priority=4 @},
@end example

The meaning of these attributes is as follows:

@itemize

@item @samp{file}
Path and name of the sound file for this event, without the @samp{.wav}
extension.

@item @samp{volume}
The sound volume: 1.0 is default, 0.0 is silent.

@item @samp{priority}
If many effects are active at the same time, high-priority
effects can replace lower-priority effects. Use an integer
between 1 and 10 (default 1). This property does not yet
work with Enigma 1.01.

@item @samp{global}
Either @samp{true} or @samp{false}.  If true, no stereo effects are
applied and there is no attenuation.  Used for menu sound,
level end sounds, etc. Default is @samp{false}.

@item @samp{loop}
@samp{true} or @samp{false}. If true, the sound repeats infinitely
until canceled. Default is @samp{false}. 

@item @samp{damp_max}, @samp{damp_inc}, @samp{damp_mult}, @samp{damp_min}, @samp{damp_tick}
Parameters for sound damping.  Sounds from noisy objects like light passengers
are damped to reduce the noise.  For this, the sound event's frequency is
estimated.  @samp{damp_max} calibrates the maximal damping factor (high means
quiet), @samp{damp_inc} how fast the damping accumulates, @samp{damp_mult} is an
overall factor, @samp{damp_min} defines a lower bound for the damping entries
(beyond which they are removed from memory) and @samp{damp_tick} the factor
that's applied all 0.1 seconds.  See @samp{sound.hh} for details.
Defaults: 10.0, 1.0, 1.0, 0.5, 0.9.

@end itemize

To design a new sound set, proceed as follows:

@enumerate

@item
Create a new folder containing a copy of the sample file @samp{soundset.lua}
and the wav files you want to use.  

@item
Move this new folder into Enigma's "soundsets" folder in your user path.
(Possibly you have to create it.) The directory structure should look
something like this:

@example
(user path)/soundsets/my_sounds/
                               /soundset.lua
                               /high_pitch.wav
                               /soundfile_13.wav
                               ...
@end example

@item
Run Enigma and choose @samp{My Soundset} in the options menu.  Since this file's
sound set does not map any sound effect to a wav file, you should hear nothing.

@item
Edit the contents of @samp{soundset.lua} to your liking.  You can access the
default sound files, e.g.:

@example
...
coinsloton = @{ file="enigma/st-coinslot" @},
...
@end example

When using own sound files, remember to add the subfolder, like in

@example
...
coinsloton = @{ file="my_sounds/soundfile_13" @},
...
@end example

No extension ".wav"! It's added automatically. Make sure that the
extension is in lower case letters.

@item
Replace @samp{MY_SOUNDSET} by a suitable variable name, and @samp{My Soundset}
by the name you want to see in the sound options menu.  Remember to
make it short enough to fit on the button.  The three identifiers variable,
button name, directory name need not have the same names, but it eases the life
of other developers to give them similar names that uniquely determine the
sound set.

@end enumerate

Remember to choose the sound set in the options menu anew each time you change
its name.  And always shut down Enigma before changing sound sets, new sounds
are not recognized during runtime.

Feel free to zip and distribute the whole directory containing your
sounds and the @samp{soundset.lua} file. You can install a downloaded zipped
sound set simply by unpacking it and placing it into the
@samp{soundsets}-subdirectory of your user path. Make sure that the
@samp{soundset.lua} is always exactly one subdirectory below @samp{soundsets}.
Deinstall a user sound set simply by deleting its directory. Renaming the
directory does not suffice -- you have to rename the @samp{soundset.lua} if you
want to hide a sound set from Enigma. This can be advantageous if you use
interdependent sound sets (sound sets that share sound files) and want to
deactivate just one of them. 


@node  Levelpack Basics
@chapter Levelpack Basics

Knowing the basics of running Enigma, you may wonder how levels are organized in
levelpacks and how you can add levels or complete levelpacks to Enigma.

@cindex crossreference
@cindex crossindex
@cindex levelpack
@cindex index
Levelpacks are sorted collections of levels that consist of an index and optional
attached level sources. Not all level sources of a levelpack have to be included
within the levelpack itself. A levelpack can crossreference levels stored in
other levelpacks. If a levelpack has no level sources of its own and consists only
of crossreferences, we speak of a crossindex, since just a single index file represents the
levelpack.

These definitions suit all versions of Enigma well. However, up to Enigma 0.92, levelpacks
needed to be manually edited, and the registration of levelpacks was a little bit cryptic. Thus, we
decided to rewrite the complete levelpack system for Enigma 1.0, and tried to make it versatile
and easy to use. We did set up the following aims:

@itemize @bullet
@item 
an @samp{Auto} levelpack that allows level addition by drag and drop of the
level source

@item
levelpack addition simply by copying the files to the userpath

@item
autodetection of all levelpacks without editing any registration files

@item
commandline-supplied levels as a standard levelpack

@item
a @samp{History} levelpack with crossreferences of last-played levels

@item
level search results as a levelpack of crossreferences

@item
zipped levelpacks that are just archives of levelpack directories and their files

@item
grouping of levelpacks in the menu

@item
integrated composer to create and modify new levelpacks

@item
updates of levelpacks without updating Enigma itself

@item
automatic conversion of Enigma 0.92 levelpacks

@end itemize

Some of these features work seamlessly. You can use them immediately from the
levelpack menu. For others, you may need to know where to place files. We will
explain these details in the following sections:

@menu
* Getting Started with Levelpacks::
* Converting 0.92 Levelpacks::
* Zip Levelpacks::
* Grouping and Sorting Levelpacks::
* Creating New Levelpacks::
* Modifying and Deleting Levelpacks::
* Composing Levelpacks::
@end menu

@node Getting Started with Levelpacks
@section Getting Started with Levelpacks

One of the outstanding features of Enigma is its extensibility by new levels.
And the community of users usually provides us several new great levels every week.

Adding a new level that you receive as an XML file is very simple. Locate the
subdirectory @samp{levels/auto} on your @samp{user path} (@pxref{Locating Resources}).
Just copy the level file to this folder and restart Enigma. The new level will be
part of the @samp{Auto} levelpack, and you can play it like any other level.

Please note that Enigma displays erroneous or incompatible levels with an error icon in the level
menu. Of course an attempt to run such a level will result in an error message. Look at the level
metadata with the levelinspector 
(@pxref{Level Info}) to identify the required compatibility version, and contact
the author via the address in case of level code errors.

A second way to run new levels is to add the address of the level files to the
commandline (@pxref{Startup Switches}). This way you can play levels that are stored
anywhere, and you may even use url addresses of levels stored on the internet. Levels added to
the commandline are accessible via the @samp{Startup Levels}
levelpack. 

If you want to run an old-fashioned Lua level that someone wrote for Enigma 0.92 or earlier,
you may try to start it via the commandline. These old levels miss necessary metadata for auto
detection. However, commandline-supplied levels are treated as temporary levels available just
for a single run of Enigma; reasonable defaults substitute the missing data. The level will
probably run, but scoring and copy, paste and linking of such levels is not possible.

Besides single new levels, the community may provide you with complete levelpacks, too. These
levelpacks may occur as directories with levels, zip archives or single XML files. You can install
all of them simply by copying the files, but we have to distinguish the three formats.

You must copy levelpacks distributed as directories, with level files and an index file in them, to
the subdirectory @samp{levels} on your @samp{user path}
(@pxref{Locating Resources}).

You must copy levelpacks distributed as zip archives to the subdirectory
@samp{levels} on your @samp{user path}. You do not need to unpack the zip,
although it is possible, as described in the section @ref{Zip Levelpacks}.

You must copy levelpacks that are distributed as a single XML index file to the subdirectory
@samp{levels/cross} on your @samp{user path}.

All new levelpacks should be accessible via the levelpack
menu after restarting Enigma.

That is all you need to know to be able to add new levels and levelpacks for
testing and playing. If your main interest lies in writing your own levels, you may 
want to proceed directly to chapter @ref{Level Basics}. The rest of this chapter
explains how to arrange and sort existing levels in your own levelpacks.

@node Converting 0.92 Levelpacks
@section Converting 0.92 Levelpacks

With the changes of the levelpack index format, converting old levelpacks is necessary. Although
the main work is done automatically just by starting Enigma, a few special cases remain that
need manual preparation. Further on, after the autoconversion, some cleanup may be useful.

If you formerly maintained your levelpacks within the Enigma system levels directory, you
should now copy your own levelpacks from the old Enigma version to the @samp{user path}
subdir @samp{levels} (@pxref{Locating Resources}). The @samp{user path} exists on all
systems, and since Enigma 1.00 will never write to the system levels directory, it will perform
updates and conversions only on the @samp{user path}. If you
registered your levelpacks on the system levels directory within the @samp{index.lua}
file, you need to copy these registration lines to the @samp{index_user.lua} file,
which you should store on your @samp{user path}.

If you maintained several of your own levelpacks, Enigma 0.92 allowed you to keep them
in several subdirectories of the @samp{levels} directory.However, since it also allowed you to
keep all level files and different indices in the @samp{levels} directory
itself, you will run into trouble with the auto conversion, because Enigma 1.00 allows only one
levelpack with attached level files per directory. 
In this case, we recommend a step-by-step conversion: in every step, provide only one old index
for conversion. Enigma will convert this index to a new @samp{index.xml}.
Move this new index, together with all levels, to a subdirectory and convert the
next levelpack.

A last special case occurs if you had an old index stored in @samp{levels} that
referenced level files in different subdirectories of @samp{levels}. Since Enigma 0.92 did not
have a concept of cross-references, and Enigma 1.00 requires that you store all level files
attached to a levelpack in a single subdirectory, the conversion algorithm needs to guess the
correct subdirectory. It simply takes the subdirectory of the first level. If this does not fit, you
may need to clean up your 0.92 levelpack prior to conversion.

Enigma should convert all other standard levelpacks without problems. It only performs the
conversion once. As soon as the new @samp{index.xml} exists, only this 
index is used. Thus, after a careful check, you may remove the old @samp{index.txt}.
We recommend keeping a backup of the old index until you have completely switched to
Enigma 1.00.

If you used a levelpack of your own in the zip format, you will find a subdirectory named with
the base name of the zip archive in your user @samp{levels}
directory. Enigma stores the converted @samp{index.xml} within this directory. You
may want to exchange the old @samp{index.txt} in the zip with the new index.
Afterwards you can delete the subdirectory, since Enigma will load the index directly
from the zip archive.

After converting your levelpacks, we strongly recommend that you update your own
levels to the new XML format, as described in @ref{Level Basics}.

@node Zip Levelpacks
@section Zip Levelpacks

Besides the classic levelpack format of a subdirectory of @samp{levels} with
an @samp{index.xml} and several level files, Enigma 1.00 provides a compatible
zip archive format. This zip allows you to reduce resources and to ease distribution
of levelpacks.

The compatibility is 100%. If you have a classic subdirectory levelpack, you
can simply zip the complete subdirectory and name the zip with the name of the 
subdirectory, plus the standard @samp{.zip} suffix. Now you can completely remove the
subdirectory; Enigma autodetects the levelpack and it is fully playable. Even cross-references
into this levelpack will not be broken!

On the other hand, Enigma allows you to expand every zip levelpack to a subdirectory with
index and level files. Again, everything runs and no cross-references are broken.

If you keep both, the files contained in the subdirectory precede files in the zip
archive. Thus, Enigma stores updates of single files in subdirectories in parallel
to existing zip archives.

@node Grouping and Sorting Levelpacks
@section Grouping and Sorting Levelpacks

As the number of levelpacks increased, it became necessary to sort and group the
levelpacks in the menu. We tried to provide a useful set of default groups
and default assignment of the distributed levelpacks to these groups:

@itemize @bullet
@item 
@b{Enigma} - levels that are written just for Enigma

@item 
@b{D@'ej@`a-vu} - levels that you may have seen before

@item 
@b{Sokoban}

@item 
@b{Facets} - special sortings and views of the levels above

@item 
@b{User} - personal levels and levelpacks like History, Autofolder generated by the 
system for the user.

@item 
@b{Development} - templates and unfinished levels from the Enigma Team 

@item 
@b{All Packs}

@end itemize

Still, this is just a proposal. You are free to rename the groups, add new groups and change the
assignments of the levelpacks. As in other parts of Enigma, you can right or control click on the
group and levelpack buttons.

The group configuration menu allows you to rename and reposition a group. You
can choose any name that is not a duplicate, that is not enclosed in square brackets
and differs from @samp{Every Group}. Note that you may not be able to enter as many
characters as you are used to. Sorry for this inconvenience.

The levelpack configuration menu allows you to assign a pack to a group. The
group list contains two special entries: @samp{[Every Group]} and another name
enclosed in square brackets. Selecting the first pseudogroup displays the levelpack in every
group. This is the default assignment of the @samp{Startup Levels} group. The second square
bracket-enclosed name is the default group of the
levelpack itself. It is a hint for you and allows you to reassign a levelpack
to the default group even if meanwhile you have deleted the group.

@node Creating New Levelpacks
@section Creating New Levelpacks

To create a new levelpack, you simply select the group to which you want to add
the new pack. This is most likely the @samp{User} group. Right or ctrl click on
the group and simply click on the @samp{New Levelpack} button. Enigma will call the
levelpack configuration menu, which allows you to enter all the important data for the creation
of a levelpack.

First you should enter a name for the levelpack. You are limited to characters
that can be used for filenames, too. You may use alphanumerical characters A-Z, a-z, 0-9 and
space, underscore and hyphen. Note that you may rename the pack
later for a better or more suitable display name (@pxref{Modifying and Deleting Levelpacks}).

Later, you should decide whether you want a levelpack that can contain level
sources or just a crossreference levelpack. The first one is useful for storing
your own self-written levels or levels that you download from the internet.
You may use the crossreference levelpacks for your favorite collections, where you simply
reference existing levels of other levelpacks with your own personal sorting.
You set the selected type with the @samp{Level types} button, which uses symbols
for references and carbon copies.

The @samp{Default Location} is a number that determines the sorting location 
within levelpack groups, if you have not resorted the levelpack manually 
(@pxref{Grouping and Sorting Levelpacks}). This default value is relevant only
if you distribute your levelpack and want to ensure that the users will find
your levelpack at a proper location. The value given after creating a new
levelpack should work well in most circumstances.

You may declare yourself as owner or creator of the levelpack. This is just a
string for identification purposes.

Finally, when you have completed the configuration, you can create the levelpack by
clickling @samp{OK}. Enigma will create the levelpack on your @samp{userpath} 
(@pxref{Locating Resources}).

If you decide not to create a new levelpack, just click @samp{Undo}. Enigma will not create or
change anything in this case.

If you want to set up the new levelpack immediately, you can click directly on
@samp{Compose Pack}. Enigma will create the levelpack, and you can use the composer to fill
it with levels.

@node Modifying and Deleting Levelpacks
@section Modifying and Deleting Levelpacks

To modify a levelpack, right or ctrl click on its button in the levelpack menu.
You will see the metadata for all levelpacks. However, an @samp{Edit Metadata} button will
appear only for your own levelpacks, which Enigma stores on your @samp{userpath}.
Clicking on it allows you to edit the metadata.

Renaming the levelpack is possible, but Enigma will not change the filenames anymore. It will
use the new name as the logical levelpack name that shows up in Enigma.

Other attributes that you can modify include the @samp{Default Location} and the 
@samp{Owner}. 

Note that changing the levelpack type later is not possible. You must create a new levelpack of
the proper type and copy the levels by using
@ref{Composing Levelpacks}.

We do not provide a levelpack deletion function to avoid unintended loss of levelsources.
Still, the deletion of a levelpack is as simple as deleting the complete levelpack
directory on your @samp{userpath}. For crossreference levelpacks, you simply need to
delete the index XML file on the @samp{levels/cross} subdirectory of your
@samp{userpath}.

@node Composing Levelpacks
@section Composing Levelpacks

You can change the levels of a levelpack by using the levelpack composer. You call it
by right or ctrl clicking on the levelpack button in the levelpack menu, then
clicking on the @samp{Compose Pack} button in the levelpack configuration menu.

The composer looks similar to the levelmenu, but it provides other functionality. Enigma lists
all commands in the F1 help menu. First, if you compose your own levelpacks, you may note
that the levels are bordered red. This is a warning, since you can modify these levelpacks.
System levelpacks (the distributed Enigma levelpacks) will border the levels in gray, since you
can use the composer only for copying levels to the clipboard.

The clipboard allows you to select levels in one or several levelpacks and to
insert these levels as reference or as copy to your own levelpacks. First, clear
the clipboard by @samp{Shift delete}. Then select any levelpack you want from within the
composer levels. Add them by @samp{Shift click}. They will appear
in the upper text lines in the composer. Return to the levelpack where you want
to add the levels. Select the level behind which you want to add the levels. Use
@samp{F8} to insert the levels of the clipboard as references. If you edit a
levelpack that can take level copies, you may use @samp{F9} to insert the levels
of the clipboard as file copies.

As soon as you modify the levelpack, a small red triangle in the upper left corner
signals the modification. Leaving the composer via the @samp{OK} button finalizes all
changes. Leaving the composer via the@samp{Undo} button reverts all changes.

Besides adding levels, you can delete levels by using the @samp{delete}
button. Note that Enigma will delete the level files themselves if you delete a level
that is not just a reference. Be careful with all levels that have the document
icon on their preview. You can revert deletions with the @samp{Undo} button.

You can resort all levels with the @samp{alt left arrow} and @samp{alt right arrow}.
The new sorting appears immediately, and you can save it by using the @samp{OK} button.

You can use the @samp{F5} button to update the index from the levels. This is very useful if
you edit levels yourself. The levelpack will notice changes in title, revision, easy mode support
etc. Enigma updates all levels of the levelpack at once.

By using the Auto levelpack and the composer, you can set up levelpacks of your own levels, as
follows: Create a new levelpack, add the level files to the @samp{auto}
folder, restart Enigma, add the levels from the @samp{auto} folder to the clipboard,
use the composer to insert the levelpack to your levelpack as a copy, and delete the
unused level file copies from the @samp{auto} folder.


@node  Level Basics
@chapter Level Basics

Now that you have played some levels of Enigma, you may have noticed that Enigma is quite a
dynamic game with versatile levels. Thus, it is not astonishing that it is impossible to describe
such levels with a static approach of a simple object map like Sokoban. Some levels, like mazes,
generate their layout and look different each time you play them. Other levels provide a dynamic
behavior during the play; i.e., switches may open doors only in certain circumstances. To
comply with these demands, we have integrated the powerful lightweight C extension language
@url{http://www.lua.org, Lua}
into Enigma.

Up to Enigma 0.92, two different level formats did exist. One was a XML-like format, primarily
designed for external level editor programs. Because its static object map description part was
inconvenient for manual editing, many authors never used it. The second format was plain Lua
code that used an interface of Enigma Lua functions to add objects and callback functions.
Nearly all authors used this second format, but it had a small drawback:
you could store metadata for the level (like the author name, license info, and last but not least,
the level name itself) only as unformatted Lua comments, and you had
to reinsert it manually into the level-package indices.

With the post-0.92 XMLification of Enigma, we achieved full XML support by integrating
Apache Xerces, and were wondering how to get rid of the old level format drawbacks and how to
add some compelling new features:

@itemize @bullet
@item 
a single format with optional parts - use only those parts you need

@item
no major changes or any limitations for Lua level authors

@item
keep all author-supplied metadata in the level

@item
enable plug & play for users - copy the level from the author and play it 
without manual index edition

@item
support of various encodings, such as US-ASCII, UTF-8, UTF-16, Windows-1252

@item
internationalization of levels - allow authors to add strings in their native
language and supply translators with all translatable level strings and comments
from the authors' how-to-translate.

@item
add a release and dependency management for levels and libraries

@item
add level update and upgrade support for levels and libraries

@item
substitute the old XML format with a versatile editor interface

@item
keep the format open to future extensions

@end itemize

Let us have a first view on complete simple @samp{Hello World} level in the new format:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo Simple}" @i{el}:@b{id}="@var{20060210ral001}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{stable}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

You may notice that the XML portion contains all the metadata that the level author is
accustomed to supplying with a level. The XML part is like a formula that you can copy from a
template and fill out.

The Lua code is embedded in the XML. The only limitation to the Lua portion is that it reserves 
@samp{]]>} for the end mark, and you would have to substitute it with 
@samp{]] >}. No further restrictions.

Since the example above includes all mandatory XML parts, we should achieve our aim to avoid
major changes for Lua level authors.

You can find the example above in the @samp{Exp} levelpack grouped in
@samp{Development}.
The source code is located on the system path subdirectory
@samp{levels/enigma_experimental}
(@pxref{Locating Resources}).

If you make your first coding experiments on a copy of this level, either add your
copy to the auto folder (@pxref{Getting Started with Levelpacks}), or use it as 
an argument on the command line (@pxref{Startup Switches}).

Of course we must look at the details of the format and explain the optional
parts:

@menu
* Getting Started with Levels::
* XML Level structure::
* Info metadata::
* LUA code::
* Internationalization (i18n)::
* Usage::
* Update and Upgrade::
* Libraries::
@end menu

@node Getting Started with Levels
@section Getting Started with Levels

A Simple Level

Here is a very simple level description that can also serve as a
starting-point for new landscapes.  (In fact, this is the first level
in Enigma, so you can try it out right away.)

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
 4
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
 8
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
14
15   set_actor("ac-blackball", 10,6.5)
@end example

The resulting level looks like this inside the game:

@image{images/first_level}
@ignore
      <img src="welcome.png" alt="The first level" width="75%" height="75%"></para>
@end ignore

Let's now turn to a line-by-line analysis of this program:

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
@end example

The level begins with a call to @code{CreateWorld}, which creates a
new world that is 20 blocks wide and 13 blocks high.  You can access every
@dfn{block} in the world with a pair of coordinates:
The upper left corner has coordinates (0,0); the lower right has
coordinates (19,12).  Every block contains a floor tile, an (optional)
item, and an (optional) stone.

You draw a frame of stones around the newly created landscape with the
@code{draw_border} command.  Its argument, @code{"st-brownie"}, is the
name of a stone.  By convention, all stones have @code{"st-"} prefixed
to their name; similarly all item names begin with @code{"it-"} and
all floor names with @code{"fl-"}.

The @code{fill_floor} command in line 3 fills the complete floor with
tiles of type @code{"fl-hay"}.  The other arguments are the upper left
corner and the width and height of the rectangle to be filled.

@example
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
@end example

Lines 5 to 7 demonstrate how to create individual stones.  The
@code{set_stone} command takes a stone name, the desired
coordinates, and an (optional) list of @emph{attributes}
as arguments.  Note the use of curly braces @code{@{},
@code{@}} to enclose the attribute list.

Attributes are the key to customizing the behavior of objects in a
landscape.  Here, we name the first stone we create.
It's a fart stone that has the unpleasant habit of ``blowing off''
when triggered.  The timer stone that we create in line 6-7 triggers this fart stone.  This stone
performs a predefined action at
regular intervals.  In this case, we want to send a ``trigger'' message
every ten seconds to the object named ``fart''.

@example
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
@end example

These commands place a couple of oxyd stones in the level.  The
@code{oxyd} command internally uses @code{set_stone("st-oxyd", x,y,
@dots{})} to create the stones, but additionally it assigns sensible
values to some of the oxyd stones' attributes (most notably the
color).  The command on line 14 permutes the colors on the oxyd stones
currently in the landscape.

@example
15   set_actor("ac-blackball", 10,6.5)
@end example

This final line creates the black marble that the player controls.
We call objects that can move around freely ``actors'' in Enigma.
Unlike stones and items, actors are not restricted to integer
coordinates, as you can see in this example. 



@node XML Level structure
@section XML Level structure

Let us start with a complete overview of all existing top XML element nodes. The
following level skeleton contains optional elements that are beyond level basics.
We include these elements for completeness:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd http://enigma-game.org/schema/editor editor.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}" xmlns:@i{ee}="@i{http://enigma-game.org/schema/editor}">
  <@i{el}:@b{protected}>
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <!-- required elements omited -->
    </@i{el}:@b{info}>
    <@i{el}:@b{elements}/>
    <@i{el}:@b{luamain}><![CDATA[
    ]]></@i{el}:@b{luamain}>
    <@i{ee}:@b{editor}/>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}/>
    <@i{el}:@b{upgrade}/> 
  </@i{el}:@b{public}>
</@i{el}:@b{level}>
@end example

The first line is the XML declaration. It is fixed besides the encoding 
specification. Enigma supports on all platforms, at least @samp{US-ASCII}, 
@samp{UTF-8}, @samp{UTF-16}, @samp{ISO-8859-1}, @samp{windows-1252}.
Enter your encoding and make sure that your editor saves the level in this encoding.
On some editors, you can start in ASCII mode, copy the level skeleton with a
different encoding declaration, like UTF-8, save the level still in ASCII mode
and reopen the file.  The editor may then detect the XML declaration and switch 
automatically to the given encoding. Note that unless you enter
international strings in the level, you do not have to bother with the encoding 
at all. You can choose UTF-8 in this case.

Some additional remarks for XML newbies: The XML markup tags are quite similar
to HTML. But XML requires a corresponding
end tag @samp{</element>} for each start tag @samp{<element>}. For elements that have
only attributes and no content,
you can and should use the alternative empty element notation @samp{<element/>}.
Note that when we define an element as empty or state that no content is allowed,
not a single whitespace, not even a linebreak is allowed between start and end tag. Use the
empty element notation to avoid mistakes.

We use a pretty printing format with an indentation of 2. Each element starts on a separate line.
Elements with text content have the end tag on the same line. Only elements with subelements
have the end tag on a separate line with the same indentation.

This format is not mandatory. You can even insert linebreaks in text contents, within the marks,
and even within attribute values. But note: The basic rule is that each linebreak will be
substituted by a space during the XML parsing. Take this space into account to avoid mistakes,
or simply live with the long lines.

A namespace identifier prefixes all tag names and attribute names.  We
use @samp{el} as an abbreviation for Enigma levels. All tag names you can
manually edit use this prefix.

Finally, a short comment on the XML reserved characters, @samp{&} and @samp{<}.
These two characters are reserved as tag and entity starting characters. If you
need them in text contents or in attribute values, you must substitute
them by the entity sequences @samp{&amp;} and @samp{&lt;}. Additionally, you must enclose
attribute values with either @samp{"} or @samp{'}. Of course, you must substitute the
enclosing character used in attribute values, too. Use @samp{&quot}
and @samp{&apos}.

@b{Elements:}

@table @asis
@item @b{/level}, @i{required, single occurence} 
This is the root node. Only one instance of this node occurs per file. Like the first XML
declaration line, this second line is quite fixed. There are two versions. The simple 3-attribute
version, as used in the first example, and only level editor programs use the 4-attribute version
as above. For manual level
editing, just copy the simple version as the second line to your level file.
 
@b{Attributes:}

@table @asis
@item @b{xmlns:xsi}, @i{required, contents fixed} 
Namespace definition for the schema. The contents are fixed to 
``http://www.w3.org/2001/XMLSchema-instance''. The attribute tag @samp{xsi} must
match the prefix of the next attribute tag, and is standard.

@item @b{xsi:schemaLocation}, @i{required, contents fixed} 
Location of the schemas used. The contents are the fixed Enigma level 
namespace, followed by the schema location URL. Level editor programs will add
their namespace and their schema location URL, as in the second example above.

@item @b{xmlns:el}, @i{required, contents fixed} 
Namespace definition for ``Enigma level''. We use @samp{el} as the namespace prefix
for all level element and attribute tags, as standard. The prefix used can be
arbitrary, but must match this attributes tag. The contents of the attribute is
fixed to the Enigma level namespace.

@item @b{xmlns:ee}, @i{optional} 
Only level editor programs use this last namespace definition. For
example, we declared @samp{ee} as the namespace prefix for all editor element and
attribute tags.  The prefix you use can be arbitrary, but must match this attributes
tag. The contents of the attribute are the editor's namespace.

@end table

@item @b{/level/protected}, @i{required, single occurrence} 
          
The protected node section contains all level data that derive from the author and
should not be modified by anyone else.

@item @b{/level/protected/info}, @i{required, single occurrence}

The info node section contains all level metadata. It is mandatory and described in 
detail at section @ref{Info metadata}.

@item @b{/level/protected/elements}, @i{optional, single occurrence} 

The elements node section is optional. It contains level description parts that
are given in a data-driven manner. Though the driving force is the support
for level editor programs, a level author may use any parts of this section he or she
likes.

@item @b{/level/protected/luamain}, @i{optional, single occurrence}

The luamain node section is the part to insert manually Lua level descriptions.
It is described in detail at section @ref{LUA code}.

@item @b{/level/protected/editor}, @i{optional, single occurrence} 

The editor node section is an open extension area for level editor programs.
They can add any additional information in this section that they need.
Enigma simply ignores this node section.

@item @b{/level/protected/i18n}, @i{required, single occurrence} 

The i18n node section contains English strings, native translations and comments
supplied by the author for the translators. This node section is mandatory 
and described in detail at section @ref{Internationalization (i18n)}.

@item @b{/level/public}, @i{optional, single occurrence} 

This public node section is an optional extension to the protected part. It
contains information that the author has not validated and may even be added
after the last author's review.

@item @b{/level/public/i18n}, @i{optional, single occurrence} 

This public i18n section contains further translations supplied for the level. They
may derive from the author or other sources. The translators  will
validate these translations, and they continue in use if the translators do not
supply corrected versions. See @ref{Internationalization (i18n)}.

@item @b{/level/public/upgrade}, @i{optional, single occurrence} 

This upgrade node is part of the @ref{Update and Upgrade} system.

@end table

@node Info metadata
@section Info metadata

The Info node contains all author-supplied metadata for the level. This is the
source of these data. All other parts of Enigma, such as level indices, simply contain
copies that will be automatically updated to the level's original data.

Let us look at all supported subnodes of info with typically used attributes:

@example
<@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
  <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
  <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
  <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}"/>
  <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
  <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
  <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
  <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
  <@i{el}:@b{comments}/>
  <@i{el}:@b{update} @i{el}:@b{url}="@var{http://@dots{}}"/>
  <@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://@dots{}}" @i{el}:@b{release}="@var{2}"/>
  <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
</@i{el}:@b{info}>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}, values = ``level'', ``library'', ``multilevel''
You may use the schema for single Enigma levels, libraries that contain level
description parts for reuse, and descriptions for multiple levels at once.

@samp{level} are all single level descriptions. It does not matter if you
edit them manually or with a level editor program, or which description elements you
use.

@samp{library} are level description parts that may be included in levels.
The library may consist simply of Lua code in the luamain node, or additional object
descriptions in the elements node. Libraries may make use of nearly all nodes besides
the @samp{/level/protected/info/score} and @samp{/level/*/i18n}, which both must be
provided, but will not be evaluated. Libraries are included in levels via
the dependency node-element. See @ref{<compatibility>}.

@samp{multilevel} are descriptions for multiple levels at once. The main purpose
is to support foreign game level formats, like the Sokoban level format, which
usually describes a whole set of level maps in a single file.

@item @b{quantity}, @i{optional}
The number of levels contained in a multilevel file.

@end table

@b{Contents - Elements:}

@table @asis
@item @b{identity}, @i{required}
The title, subtitle and the main level identification string. See @ref{<identity>}.

@item @b{version}, @i{required}
All aspects of the level @ref{<version>}.

@item @b{author}, @i{required} 
All information provided about the author him- or herself. See @ref{<author>}.

@item @b{copyright}, @i{required} 
The @ref{<copyright>} message for the level.

@item @b{license}, @i{required} 
Information about the @ref{<license>} conditions.

@item @b{compatibility}, @i{required} 
All information about @ref{<compatibility>} to Enigma releases, dependencies
from libraries, external data and the editor program that generated the level.

@item @b{modes}, @i{required} 
The @ref{<modes>} that the level supports, such as difficulty, network  and control.

@item @b{comments}, @i{optional} 
Optional comments, such as credits, dedication and code comments. See @ref{<comments>}.

@item @b{update}, @i{optional} 
@ref{Update and Upgrade}

@item @b{upgrade}, @i{optional} 
@ref{Update and Upgrade}

@item @b{score}, @i{required} 
The author's own @ref{<score>} of this level.

@end table

@menu
* <identity>::
* <version>::
* <author>::
* <copyright>::
* <license>::
* <compatibility>::
* <modes>::
* <comments>::
* <score>::
@end menu


@node <identity>
@subsection <identity>

The @samp{@b{identity}} element is required, since it provides the information for human
and system identification of the level. 

@example
<@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{title}, @i{required} 
The English title of the level. Make sure that the title is not too long, since Enigma
will use it on the level selection menu. Translations of the title can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{subtitle}, @i{optional}
An optional English subtitle. Used for title parts that are too long for the
main title, or for a short first hint. Enigma displays the subtitle on the level info
page and on the start of the level. Translations of the subtitle can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{id}, @i{required}
This is the central system identification string of the level that remains valid
for all time, independent of upcoming release updates. Enigma's single demand
on the id is that it is unique among all levels created by all authors
around the world.

Since you can edit levels with any text editor or different special Enigma level editors, there is no
control about the uniqueness. Thus, we have to provide a simple convention to avoid any
possible id clashes:

@var{@b{YYYYMMDDuserNNN}}

Where @samp{YYYY},@samp{MM},@samp{DD} is the date of the creation of the first
experimental version, @samp{user} stands for a user-specific name and @samp{NNN}
for a random number. For example, my level called @samp{Houdini} has the id 
@samp{20060816ral719}. Of course all levels created on the same day have to
differ in the random number part. The id is an Enigma level system id, and is 
never exposed to users.

For backward compatibility, legacy levels keep their former filename as the
new level id, and do not fit in the name schema given above. Still, that does no harm since the
only requirement is the uniqueness.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <version>
@subsection <version>

This element provides the versioning information for the system.

@example
<@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{score}, @i{required}
The score version is given as a positive integer number. New levels start with 
score verison ``1''. New level versions need to increase the
score version number if the level modifications cause different solutions with 
uncomparable score values. Of course, level authors should be very restrictive 
with such modifications.

During the development of a level, you should use the attribute @samp{@b{status}} to mark a
level as not released. When the author changes the @samp{@b{status}} to
@samp{released}, he has to check scoring compatibility and increase the score 
version if necessary.

This attribute is the logical equivalence to the Enigma 0.92 @samp{index.txt} attribute 
@samp{revision}.

@item @b{release}, @i{required} 
The technical release version is given as a positive integer number. New levels
start with release version ``1''. You must increase the release version number if
the level modifications cause either technical incompatibilities with previous Enigma releases,
or the scoring version has been increased.

The primary cause for technical incompatibilities should be the compensation 
of Enigma engine changes. Since such compensations will not run on the old Enigma
version, the level versions must be distinguished by a different release number.

In both cases, technical and scoring incompatibilities, the level file name must
be changed, too. This is necessary since different Enigma versions may be installed on some
systems at the same time. They have the need for both level versions at the same time. Internet
servers providing Enigma levels need to offer the different level release at the same time, too.

To enable people to assign different level release files to a level itself, we
strongly recommend the name convention for levels 
@var{AuthoridentifierLevelnumber_Releasenumber.Suffix}, where the levelnumber is at
least 2 digits; for example, @samp{ral01_2.xml}

@item @b{revision}, @i{required} 
The revision number is a simple, ever-increasing version number. Every published
version of the level should have a new revision number. The revision number is
independent from the scoring and release version number.

If Enigma finds two levelfiles in its data search paths with identical filenames,
id, score and release version, it will load the one with the higher revision number.
This feature guarantees that  an older level revision stored on the user's
home level directory cannot supercede a new revision of a level distributed with a new
Enigma release. Online updates will check the level revision numbers, too.

Although  the revision evaluates to a number, the attribute can take a second 
string format as the literal keyword @samp{$Revision$}. This 
@url{http://subversion.tigris.org/, Subversion} format allows level authors to 
let their Subversion repository automatically insert the level revision number. They must simply
set @samp{svn propset svn:keywords "Revision" level.xml} 
at their repository for every level file. Since the Subversion revision number is 
ever-increasing, it fulfills our criteria. Note that Enigma does not require that revision
numbers be consecutive.

@item @b{status}, @i{required}, values = ``released'', ``stable'', ``test'', ``experimental''
This attribute describes the quality of the level during development. Enigma
uses the status to protect the score database from being spoiled by unplanned solution
scores. It will record scores only for levels marked as @samp{released}.

As a level author, if you start to change a released level, you should first change the
status back to @samp{experimental}. Then make your changes and test 
the level. When you are definitively sure that you did not introduce any spoilers,
you can release the level again with a new revision and perhaps a new release or 
score version number.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <author>
@subsection <author>

The information about the author him/herself. Enigma requires the author element itself, but
all attributes are optional to allow an author to be anonymous. Please remember that level
administrators and translators may need to contact you as the author. So please provide a way
for them to contact you.

The author element node may look like:

@example
<@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}" @i{el}:@b{homepage}="@var{http://myhomepage.domain}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{name}, @i{optional}, default = ``anonymous''
The author's name as it will be displayed on the level info page and on the start
of the level. The name defaults to @samp{anonymous}.

@item @b{email}, @i{optional} 
The author's email address or a newsgroup or forum he monitors. In general, this is a
hint as to how to communicate with him or her. The value will simply be displayed as a string on
the level info page.

@item @b{homepage}, @i{optional} 
An address for the author or where the author publishes additional Enigma levels.
The value will simply be displayed as a string on the level info page.

@end table

@b{Contents:}

The element itself is empty; no content is allowed.

@node <copyright>
@subsection <copyright>

The standardized location for the author's copyright message:
@example
<@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
@end example

@b{Attributes:}

none

@b{Contents:}

The author's copyright notice.

@node <license>
@subsection <license>

Of course, every author is free to choose the license conditions for his/her levels.
However, the author must state the conditions. Thus, this node element and its
attributes are required:

@example
<@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}
A short license identifier of the license type, with an optional link address to
the license text or the string @samp{special}, if the author supplies his/her own 
license as the content of this element.

@item @b{open}, @i{required}
A boolean statement, whether the chosen license fulfills the criteria of the 
@url{http://www.opensource.org/, Open Source Initiative (OSI)}. Please note 
that a value of @samp{false} may prevent your level from being distributed
with Enigma.

@end table

@b{Contents:}

You may add a complete license text as the contents of this element. Please
use the type attribute to identify the level.

@node <compatibility>
@subsection <compatibility>

@example
<@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}" @i{el}:@b{engine}="@var{enigma}">
  <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{true}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/natmaze.xml}"/>
  <@i{el}:@b{externaldata} @i{el}:@b{path}="@var{./extfile}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/extdata.xml}"/>
  <@i{el}:@b{editor} @i{el}:@b{name}="@var{none}" @i{el}:@b{version}="@var{}"/>
</@i{el}:@b{compatibility}>
@end example

@b{Attributes:}

@table @asis
@item @b{enigma}, @i{required}
The minimal Enigma release number required for compatibility.

@item @b{engine}, @i{optional}, values = ``enigma'', ``oxyd1'', ``per.oxyd'', ``oxyd.extra'', ``oxyd.magnum''; default = ``enigma''
The required engine compatibility mode that influences the behavior of various
objects. This attribute is evaluated only for levels. Libraries ignore this
attribute.
@end table

@b{Contents - Elements:}

The compatibility element itself contains only subelements as content.

@table @asis
@item @b{dependency}, @i{optional, mutiple occurence}
You can use this element to specify any Enigma-Lua library this level depends on. You can
specify several libraries by multiple occurrence of this element. If you configure a library to be
preloaded, the engine will load it before it loads or executes any level Lua code. The load
sequence of several libraries conforms strictly to the sequence of their dependencies elements.

@b{Attributes:}
@table @asis
@item @b{path}, @i{required}
The resource path of the library without its suffix or any release extension.
Enigma stores most libraries in the @samp{lib} subdirectory of its 
@samp{levels} directory, in most cases the resource path will be like the one in 
the example above: @samp{lib/ant}. This is the valid path for the library file 
that may be either @samp{levels/lib/ant.xml} or @samp{levels/lib/ant.lua} or 
@samp{levels/lib/ant_1.xml}.

However, libraries can also be totally level pack-specific. In this case, you may use
a relative resource path, such as @samp{./mylib} and store the library in the level
pack directory itself.

@item @b{id}, @i{required}
The version independent id of the library, as specified in the library metadata.
Enigma will check it on load of the library to avoid problems, and may use 
it with the release number to detect relocated libraries.

@item @b{release}, @i{required}
Although different release versions of libraries must have different filenames, we require to
specify the library version.  Enigma will check it on load of the library to avoid problems, and
may use it with the release number to detect relocated libraries.

@item @b{preload}, @i{required}
A boolean statement that specifies whether the library should be preloaded. If
the library is not preloaded, you can still load it via Lua code statements. Yet
even those libraries must be declared since Enigma will checked them on conformance.
You should always preload your libraries if you make use of the @samp{elements}
section.

@item @b{url}, @i{optional}
This optional attribute allows you to specify a backup address for the library.
This will be useful for using new libraries that are not yet distributed
with the system. 

For the development and test phase of new libraries themselves, a developer can hand out test
levels with an empty @samp{library} resource path
attribute. The test levels will load the newest library version as published
at the given url.

@end table

@b{Contents:}

none.

@item @b{externaldata}, @i{optional, multiple occurence}
You can use this element to specify any external data file this level
depends on. You can specify several files by multiple occurrence of this 
element. Files declared can be read via the Lua interface.

This feature should support levels that simulate foreign games like Sokoban within Enigma. Due
to copyrights and license conditions, including some data within a level may not be possible.
However, distributing the data in the original unmodified format may be legal.

@b{Attributes:}
@table @asis
@item @b{path}, @i{optional}
The resource path of the external data file with its suffix. Since the data are usually level-
specific, you should store them with the level in the same levelpack directory. Thus, a relative
resource path, such as @samp{./datafile.ext} 
is preferable. 

@item @b{url}, @i{optional}
This optional attribute allows you to specify an online address for the external data
file. This method can access only well-formed xml data files.

You should use the online access method only as a backup address or due to very restrictive
license conditions that make it impossible to distribute the data file with Enigma.

@end table

@b{Contents:}

none.

@item @b{editor}, @i{optional, single occurence}
Special level editor programs use this element to store information about themselves.

@b{Attributes:}

@table @asis
@item @b{name}, @i{required}
The name of the level editor.

@item @b{version}, @i{required}
A version number of the editor, given as a string.
.
@end table

@b{Contents:}

none

@end table

@b{Contents:}

none

@node <modes>
@subsection <modes>

The modes element allows the author to declare the supported and the default
modes of his level. Enigma's engine checks that the level is used in supported
modes.

@example
<@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}" @i{el}:@b{control}="@var{force}" @i{el}:@b{scoreunit}="@var{duration}" @i{el}:@b{scoretarget}="@var{time}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}, values = ``true'', ``false''
If a level provides a second easy-difficulty mode, set this attribute to @samp{true}.
If only a one difficulty mode is supported, set this attribute to @samp{false}.

@item @b{single}, @i{required}, values = ``true'', ``false''
If a level provides a single player game as it is standard, set this attribute to
@samp{true}. Set this attribute to @samp{false} only if the level is a 2-player-network game.

@item @b{network}, @i{required}, values = ``true'', ``false''
If a level provides a 2-player-network game, set this attribute to @samp{true}.
If not, set this attribute to @samp{false}.

@item @b{control}, @i{optional}, values = ``force'', ``balance'', ``key'', ``other''; default = ``force''
This attribute defines the standard control mode of the level. You can play a level by using the
mouse to generate forces on the marbles, since it is the standard and was the only way up to
Enigma 0.92. Or you can play a level using the mouse, or other input devices to balance the
level-world with the marbles. Or you may use the keyboard with its cursor keys to move the
actor like in classic Sokoban games.

Although the user has always the last choice to define the input method he/she
currently wants to use, the author must define the standard control-mode that
the scoring system uses. Enigma will save and evaluate only scores achieved in the defined
control mode for high score lists.

@item @b{scoreunit}, @i{optional}, values = ``duration'', ``number''; default = ``duration''
This attribute defines the evaluation and display mode of score values. By the
default @samp{duration}, the score is interpreted as level solution time and displayed
in a @b{MM:SS} format. The @samp{number} mode displays scores as plain
numbers and lower numbers will be evaluated as better scores. This mode is appropriate
for counting pushes and moves.

@item @b{scoretarget}, @i{optional}, values = ``time'', ``pushes'', ``moves'', *; default = ``time''
The score target triggers the measuring of score values. @samp{time} will take the
solution time, @samp{pushes} counts the pushes of stones, @samp{moves} counts the
moves of the actor. Any other value will call a Lua function for score values.
The target is used as a short title for the score in user interface displays.

@end table

@b{Contents:}

none

@node <comments>
@subsection <comments>

The optional comments node allows the author to add a few comments and to determine how
they should be processed. Please note that internationalization support will not translate
comments.

@example
<@i{el}:@b{comments}>
    <@i{el}:@b{credits} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{Thanks to the author of my favorite libs}</@i{el}:@b{credits}>
    <@i{el}:@b{dedication} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{To a honorable or a beloved person}</@i{el}:@b{dedication}>
    <@i{el}:@b{code}>@var{some important general notes}</@i{el}:@b{code}>
</@i{el}:@b{comments}>
@end example

@b{Attributes:}
none

@b{Contents - Elements:}

The comments element itself contains only subelements as content.

@table @asis
@item @b{credits}, @i{optional, single occurence}
The place to honor people who helped to make your level run.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on the level info
page

@item @b{showstart}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The credits message itself. It may be broken into several lines. Whitespaces will
be collapsed before display.

@item @b{dedication}, @i{optional, single occurrence}
The place to dedicate the level to a honorable or a beloved person. Please use
this place instead of adding document-items within the level.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on the level info
page

@item @b{showstart}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The dedication message itself. It may be broken into several lines. Whitespaces will
be collapsed before display.

@item @b{code}, @i{optional, single occurence}

@b{Attributes:}

none.

@b{Contents:}

The main code comment, which may be an explanation of the @ref{<version>} status 
or a todo list. It may be broken into several lines. This comment will not be 
processed.

@end table

@node <score>
@subsection <score>

In this node, the author should provide his own scoring values as hints and
a challenge for other players. All values are related to the control mode defined
in @ref{<modes>}.

@example
<@i{el}:@b{score} @i{el}:@b{easy}="@var{01:07}" @i{el}:@b{difficult}="@var{-}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}
The solution time for the easy mode. The format is either @var{@b{MM:SS}}, where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level him/herself. For levels with a score unit mode @samp{number},
the value would be the number of marble moves or pushes.

@item @b{difficult}, @i{required}
The solution time for the difficult mode. The format is either @var{@b{MM:SS}}, where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level him/herself. For levels with a score unit mode @samp{number},
the value would be the number of marble moves or pushes.

@end table

@b{Contents:}

@node LUA code
@section LUA code

This element takes any Lua code as a single chunk with nearly no limitations:

@example
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

create_world( levelw, levelh)
draw_border("st-wood")
fill_floor("fl-leavesb", 0,0,levelw,levelh)

oxyd( 4,4)
oxyd( 14,4)

document(5,10,"hint1")
document(10,10,"hint2")
document(10,5,"Heureka!")
set_actor("ac-blackball", 4, 11)
    ]]></@i{el}:@b{luamain}>
@end example

@b{Attributes:}

none

@b{Contents:}

This element takes the main Lua code as its contents. 

All other possible libraries that are declared as dependencies, and Lua chunks 
supplied by XML elements are preloaded as described in @ref{<compatibility>}.
Generally there is no more need to use Lua functions like @samp{Require} to load
libraries. Just in case you need to control the point of execution were the
library must be loaded, you can declare the library with the attribute
@samp{el:preload="false"}. You should use the new function @ref{enigma.LoadLib}
to load the library.

The Lua code that is enclosed in a XML CDATA section. This limits the
Lua code not to use the reserved end marker @samp{]]>}. Any occurrence must be
substituted by @samp{]] >}. 

On the other hand, the XML format extends the Lua capabilities to the use of
encodings. You may use Lua strings and comments with Umlauts, but Lua identifiers are still
limited to pure US-ASCII. The benefit is that you can use Umlauts and
other non-ASCII characters within it-document hints.

@node Internationalization (i18n)
@section Internationalization (i18n)

The internationalization of levels is a driving force behind the level
format changes. As you may have noticed, there are two @samp{i18n} elements, one
in the author's protected section and one in the public. Let us review how to use
them for internationalization of the three documents of our @samp{demo_i18n.xml}
level:

@example
  <@i{el}:@b{protected} >
    <!-- elements ommited -->
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{title}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}"/>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{subtitle}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{true}"/>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{@"Ubersetzten oder @"ubersetzten lassen}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct">Read the right document}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Lies das rechte Dokument}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint2}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{the correct one and not the right positioned one}">@var{The right one, not the right one!}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Das rechte, nicht das rechte}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{Heureka!}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}">@var{Heureka!}</@i{el}:@b{english}>
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{fr}">@var{Lisez la document de droite}</@i{el}:@b{translation}> 
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{public}>
@end example

Two of the documents use key words to reference a string. The last one uses the
English string itself as the key. There are two additional reserved keys, 
@samp{title} and @samp{subtitle}.

For each string we like to translate or have translated, we define a @samp{string}
subelement of the protected section and add a @samp{english} subelement to the
@samp{string} element itself. The @samp{string} element just takes a single 
mandatory attribute, the key of the string. The @samp{english} element has a
single mandatory attribute @samp{translate} that defaults to @samp{true}, stating
the author's decision whether the string should be translated. If the author
does not want a string to be translated, he can and must simply add no @samp{string}
element for this string at all. Thus, the elements for the strings with the keys
@samp{title} and @samp{Heureka!} are optional and quite unusual.

@samp{title} and @samp{subtitle} display the English text in the @ref{<identity>}
element. All other strings referenced by keys need to add the
English text as the content of the @samp{english} element. @samp{hint1} and 
@samp{hint2} are examples.

Because we chose quite ambiguous English texts, it is very likely that translators
who do not play the game but just translate the text, may deliver a wrong
translation. To avoid mistakes, a level author may add a @samp{comment} attribute
to the @samp{english} element. The translator receives this comment with
the English string as we will see later.

If the author is not native English-speaking, he should add his own @samp{translation}
subelement to the @samp{string} element. The @samp{translation} element has a
single mandatory attribute @samp{lang} that takes the 2-character language
abbreviation. The contents of the element is the translation itself.

All translations added in the protected section take precedence over any translator's
translation and will work directly after addition without waiting for a translator's
translation.

Last but not least, we have an @samp{i18n} element in the public section. This element
takes translation suggestions. The author may add them him/herself for other
languages he/she knows. They may be added by others on the way to the user,
or even by the user himself.

Translations in this section will work immediately after addition without
waiting for a translator's translation. However, available translations, provided by translators,
will precede them.

The format is identical to the protected section, with the exception that no
@samp{english} element may be provided. The @samp{key} attribute in the 
@samp{string} element must match exactly the @samp{key} attribute in the corresponding
@samp{string} element in the protected section. One subtle difference exists,
due to technical and practical reasons. @samp{key} attributes in the public
section need to be XML identifiers; thus, you cannot provide public translations
for strings that use the English phrase as the key. Choose a keyword and provide
the English string in the public @samp{i18n} section to avoid these troubles.

The @samp{string} element in protected section and in the public section
must be unique concerning the attribute @samp{key} within the section. This means
you should add translations for all known languages for a string in @samp{string}
element in the protected and in the public section. The sequence does not matter.

Let us review what the translator receives for each string. Let us 
start with @samp{hint2} for the German translator:

@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{the correct one and not the right positioned one}"
#  @i{use}: "@var{Das rechte, nicht das rechte}"
#: po/level_i18n.cc:17
@b{msgid} "@var{The right one, not the right one!}"
@b{msgstr} ""
@end example

@samp{msgid} is the English string. @samp{msgstr} takes the German translation.
But the translator does not need to translate since the author provided the German translation
in the @samp{#  use:} line

As another example, @samp{hint1} for the French translator:
@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct}"
#  @i{check}: "@var{Lisez la document de droite}"
#: po/level_i18n.cc:14
@b{msgid} "@var{Read the right document}"
@b{msgstr} "@var{Lisez le document de droite}"
@end example

Here the author gives the public translation in the @samp{#  check:} line. Since it
contains at least one mistake, the translator will correct it, as shown in the @samp{msgstr}
string.

@node Usage
@section Usage

After all the theory, let's look at how to deal with the XML levelformat in
practice. Of course, you will not assemble all XML metadata from scratch for
every new level you write. You should use templates. You can start with any
existing level, for example, the @samp{demo_i18n.xml} supplied with this
documentation. Add your personal data to your template and store it as the basis for all new
levels you write.

Some level authors are very familiar with the Lua file format since their favorite editor supports
Lua files with syntax coloring. The XML file name and the XML elements will cause
their editor to use XML syntax coloring. Nevertheless, these authors are used
to supplying metadata in the header of their Lua levels as non-standardized Lua 
comments; we decided to support a similar Lua-compatible XML format. We call it 
``Lua commented XML'' since it simply comments out all XML lines with the Lua comment
@samp{--xml-- }. For example:

@example
--xml-- <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
--xml-- <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
--xml--   <el:protected >
--xml--     <el:info el:type="level">
--xml--       <el:identity el:title="Demo Simple" el:id="20060210ral001"/>
--xml--       <el:version el:score="1" el:release="1" el:revision="0" el:status="stable"/>
--xml--       <el:author  el:name="Ronald Lamprecht"/>
--xml--       <el:copyright>Copyright @copyright{} 2006 Ronald Lamprecht</el:copyright>
--xml--       <el:license el:type="GPL2" el:open="true">GPL v2.0 or above</el:license>
--xml--       <el:compatibility el:enigma="0.92"/>
--xml--       <el:modes el:easy="false" el:single="true" el:network="false"/>
--xml--       <el:score el:easy="-" el:difficult="-"/>
--xml--     </el:info>
--xml--     <el:luamain><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
--xml--     ]]></el:luamain>
--xml--     <el:i18n/>
--xml--   </el:protected>
--xml-- </el:level>
@end example

Please note that each XML metadata line must start exactly with @samp{--xml-- },
8 characters, including the space at the end! An additional limitation of the
Lua-commented XML format arises from Lua's capability of handling character
encodings. You need to limit yourself to @samp{UTF-8} or, of course @samp{US-ASCII}
to successfully use the Lua-commented XML format. Please remember, that
although the XML part is Lua-commented, it must still be evaluated and thus must be
valid.

Every level stored in this Lua-commented XML format as a file with extension
@samp{.lua} can be used locally for command line use as well as in any level
package that is stored on the Enigma user's home directory. However, Lua-commented XML
levels cannot be stored on Internet servers or be updated online. Thus,
this format is good for level development, but you should convert the levels
to the pure XML format for distribution. Please note that Enigma looks for XML levels
first, and uses Lua levels only if it can't find an XML level.

Another use of Lua-commented XML levels is the format backward compatibility to 
Enigma 0.92. If levels do not use new Enigma features, you can include
your levels in Enigma 0.92 level packages in this format.

Since you may need to convert levels several times between the XML and the Lua format,
we do provide tools for conversion: @samp{xml2lua} and @samp{lua2xml}. Both are
very simple Lua 5 scripts that you can execute as 
@samp{lua xml2lua demo_simple.xml > demo_simple.lua} with a properly installed
Lua 5 version. On Unix systems, you can mark the scripts as executables and
simply call @samp{xml2lua demo_simple.xml > demo_simple.lua}.

Of course you can add the conversion algorithms as simple macros for your favorite
editor. Please publish any editor macros you write.

As you fiddle with the XML metadata, you may produce syntactical errors, of course.
You can validate your level by trying to start it with Enigma. XML errors are
output as Lua errors are. If the error messages are too long to read, you may
want to start Enigma from the command line with the option @samp{--log} and read the
messages printed to the command line or written to the file @samp{stdout.txt} on
the current working directory for Windows systems.

Of course, you can use any external XML validation tool, too. You just need to
copy the schema file @samp{level.xsd} on the same directory as the level itself.
Possible validation tools are the Xerces-C sample application 
@samp{DOMPrint.exe -n -s -f -v=always level.xml} or validating editors, such as
@url{http://www.freexmleditor.com/, Exchanger XML Lite}. Such editors will provide
you with selections of all possible elements and attributes at each position.

@node Update and Upgrade
@section Update and Upgrade

Enigma is able to load new level versions since we provide all necessary 
attributes in the @ref{<version>} element.

If Enigma loads a new level version, which differs just in the @samp{@b{revision}}, we speak of
an @samp{@b{update}}. You can perform updates automatically and replace old versions with
the updates, since the author guarantees them to be compatible in scoring and
dependencies. The  author should provide a download address for automatic updates in the
protected info element:

@example
<@i{el}:@b{update} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_1.xml}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A long-term valid, complete address for update downloads of this level in the same score and
release version.

@end table

If the author of a level introduces incompatibilities into the level, he increases the release
version of the level and stores it with a new filename. We call the download of such a new level
version an @samp{@b{upgrade}}.

To publish the availability of an upgrade release, the author should update the previous release
with a final revision that simply adds an upgrade element that announces the new release:

@example
<@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_2.xml}" @i{el}:@b{release}="@var{2}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A long-term valid, complete address for upgrade downloads of this level. A path
to the new file.

@item @b{release}, @i{required}
The release version of the upgrade.

@end table

Since the author cannot update all distributed levels himself to announce the availability of the
new release, we added another upgrade element in the public section. Level administrators can
use this element for the same purpose, with the same syntax, without modifying the author's
protected section.

@node Libraries
@section Libraries

Libraries are collections of Lua functions for reuse in many levels. To use a library, you must
declare it as an dependency, as described in @ref{<compatibility>}. Preloading the library is all
you have to do to use the library. Otherwise, you can use the function @ref{enigma.LoadLib} to
load the library at a certain point of execution.

Enigma provides several very useful libraries. You will find them on the system
path in the subdirectory @samp{levels/lib}. Most of them are documented in-line.
You will find a separate documentation file
@samp{doc/ant_lua.txt} for @samp{ant}.

In this section, we will concentrate on the aspects of writing and maintaining
libraries:

@menu
* Writing a Library::
* Maintaining a Library::
@end menu

@node Writing a Library
@subsection Writing a Library

Library files are nearly identical to level files. The main difference is the
attribute @samp{el:type} in the @samp{info} element, which you should set to 
@samp{library}. You must provide all other elements and attributes as you
must for levels. Of course no scoring related attributes will ever be
evaluated and you should set them to default.

Libraries may depend on others, so you must provide an id and a release number.
Several releases of a library can coexist and you can update and upgrade them
if you provide the necessary information. Of course, libraries may contain document
strings that can be localized if you provide the @samp{i18n} elements.

The @samp{el:luamain} element takes the complete Lua code as it does for levels.
Let's look at the essential XML parts of a library:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{library}">
      <@i{el}:@b{identity} @i{el}:@b{title}="" @i{el}:@b{id}="@var{lib/ant}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{released}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Petr Machata}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2002-2003 Petr Machata}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}">
        <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{false}">
      </@i{el}:@b{compatibility}>      
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{false}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
    @dots{}
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

@node Maintaining a Library
@subsection Maintaining a Library

Libraries may exist in different releases and revisions. Library versions that differ simply  in the
revision, denote compatible versions. Library versions that introduce incompatibilities must
differ in the release number. However, since existing levels may depend on the legacy behavior
of the older release, you must maintain both library release versions and distribute them with
Enigma at the same time.

To coexist, these different library releases must follow a strict naming scheme. Every library has
a base name. In the example above it is @samp{lib/ant}.
The filename of a given release is the basename with the addition of an underscore and the
release number plus the suffix @samp{xml}. Thus, you must store release @samp{lib/ant} as
@samp{lib/ant_2.xml}.

If you look at the lib directory, you may wonder that Enigma stores most library files without
release number addition to the basename. This is due to 0.92 Lua level format compatibility
support. You can store one, and of course only one, release of each library without release
number addition to the basename. Enigma will load this version from pure Lua levels that do
not provide any information of the required library release.

If a library file with a complete filename is not present, the default library file without release
number addition will be loaded for XML load requests, too. Yet the future belongs to the new
naming scheme, and every new library should follow it from the beginning.


@c ===================  Paradigm  =======================
@node Enigma Paradigm
@chapter Enigma Paradigm

Now that you have learned about the formal declarative XML part of a level you
should be eager to understand the basic principles of the participants of an
Enigma level world. In this chapter we explain all the fundamental concepts and
the terms used in the following chapters that describe the level author's view
of a level.

Please note that we describe the features of the new API of Enigma 1.10. The
API of the earlier releases does not provide all the features and differs in
several aspects.

@menu
* The World's Structure:: 
* Object Description::
* Methods of Interaction::
* The Lifecycle of a Level::
@end menu

@node The World's Structure
@section The World's Structure

We speak of a level as the opus as a whole that describes the initial composition
of a gaming world and its dynamic behaviour during the game play. Let us look
at the participating objects in details.

@menu
* World's Shape and Coordinates::    Grid Positions and Tiles
* Object Layers::                    Floors, Items, Stones, Actors and Others
* Global World Attributes::          Friction, Brittleness, Modes and Co.
@end menu

@c ----------------- World's Shape and Coordinates -------------------- 

@node World's Shape and Coordinates
@subsection World's Shape and Coordinates

Having played a few levels you will have noticed that every screen shows
quadratic tiles, 20 ones in the horizontal and 13 ones in the vertical direction.
Even if it is difficult for a player to map together all rooms and screens of a 
large level, every level world has the shape of a rectangle in whole. 
Nevertheless some parts may never be visible to the player due to walls of 
stones or oceans of water.

@cindex onescreener
On the creation of a world the level author has to give its size in measure of
tiles. The given width and height of the world are fixed and cannot be changed
lateron. A common size is 20x13 for a @dfn{Onescreener}. But there are no limits.
You can even build levels smaller than a screen. Note that for larger levels
you have to take into account that one tile row or column is usually shared
between two screens on scrolling. Thus a level of 2x2 screens has a size of
39x25 tiles, a 3x4 screen level has 58x49 tiles,...

@cindex position
Looking at the edges of all the tiles we get a grid that spans our world. We
define the upper left corner of our world as the @dfn{position} @{0,@ 0@}. The first
coordinate is the horizontal offset to the right, the second coordinate the
vertical offset to the bottom. For a Onescreener level the tile in the lower
right corner is located at position @{19,@ 12@}, whereas the corner itself is at
the position @{20,@ 13@} (Note that this point is actually not part of the level
anymore).

A position of an actor like the black marble needs to be given by two floating
numbers as coordinates like @{1.5,@ 2.5@} for an actor positioned in the center
of the tile that is one column right and two rows down of the upper left corner
tile.

@cindex grid position
But most objects like stones can only be placed on the fixed integral grid
positions. Even if you try to put a stone on @{1.5,@ 2.5@} it will be put on
on the grid position @{1,@ 2@}. Thus we speak of a @dfn{grid position} if just the
integral part is taken into account. You may note that a tile is positioned
according to its upper left corner. Actually the upper and the left edge are
part of a tile, whereas the right and lower edge belong to the neighbour tiles.

@cindex tile
Finally let us look more precisly on the tile itself. On one grid position you
may place a floor, an item, a stone and even several actors. The combination
of all objects on one grid position is called a @dfn{tile}. It is a common 
technique to declare these object combinations once in so called tile 
definitions. As many grid positions share the same combination of objects these
tiles can be reused very efficiently.

@node Object Layers
@subsection Object Layers

@cindex layer
On every grid position you may set a floor, an item and a stone. But just one
of each. If you set a second stone the first one will be replaced. Floor, item
and stone have a unique physical arrangement with the floor always being below
an item and a stone always being on top of the others. Thus we speak of three
object @dfn{layers} - the floor layer, the item layer and the stone layer.

@cindex default floor
The floor layer has a unique prerequisite. Every grid position needs to be
covered by a floor. You can define a default tile which contains a
@dfn{default floor} that gets automatically set on every grid where you set
no other floor. Even if you @dfn{kill} a floor, that means removing a floor
without setting a replacement floor, a default floor will be set for you.

The floors provide two elementary features to the game: friction and adhesion.
The friction slows down actors and the adhesion enables you to accelerate
actors with your mouse. A floor may additionally cause a directed flat force
that gives the user the feeling of a slope. And last but not least a floor
may burn. A whole set of attributes let you control the details of the fire
behaviour.

The item layer is shared between items that an actor can pick up and items that
are static. The first category are items like keys, banana, etc. Static items
are bombs, landmines, triggers, hollows and items that will only be set by the
system itself like laserbeams, fire animations, ash, etc. As only one item can
be positioned of every grid position a marble can not drop an item on such a
static item. This is the technical reason that you can not intercept a laser
beam by dropping an item. But as an level author you are free to add any item
you like to the initial grid tile.

The stone layer is straight forward. The level author can choose a stone out
of the repository per grid. Of course most grid positions should be kept free
for the actors to move around. Even if most levels have a stone wall at the 
border of the world that visually limits the area this is not mandatory. Without
a stone wall the marbles will be bounced at the physically boundary of the world.

The actors live in another layer that is not grid based. The actors can be 
placed at any position. Actors that pass a stone will be displayed below the
stone.

As a certain exception rubberbands that connect an actor with another one or 
with a stone will simply be added to the world and will be displayed above any
stone.

@node Global World Attributes
@subsection Global World Attributes

Friction, Brittleness, Modes and Co., Scrollmodes

@c ----------------- Object Description -------------------- 

@node Object Description
@section Object Description

Knowing where to place objects it is time to know how to select an object type,
how to specify the details of the object and how to reference it later on.

@menu
* Object Kind::
* Object Reference::
* Object Naming::
* Object Attributes::
@end menu

@node Object Kind
@subsection Object Kind

@cindex abstact kind
Up to now we have spoken about object kinds of floor @samp{fl}, item 
@samp{it}, stone @samp{st} and actor @samp{ac}. All these kinds are called
@dfn{abstract}. You can check if a given object is of such a kind, but you can
not instantiate an abstract kind.

To create an object you need to give a specific kind name like 
@samp{st_switch}. You will find all object kinds described in the chapters
starting with @ref{Floor Objects}. All these kind names with at least one 
underscore can be instantiated.

Most kinds provide subkinds like @samp{st_switch_black} and 
@samp{st_switch_white}. In case of the switches you get a color independent
switch if you do not append a suffix. In other cases like @samp{st_chess}
the super kind will result in a default @samp{st_chess_black} as no colorless
chess stone exists.

If you request an object for its kind it will always return the most specific
kind. This means that a fresh generated @samp{st_chess} returns the kind
@samp{st_chess_black}, whereas an @samp{st_switch} reports its name
unchanged.

Objects can change their kind by level code statements or by user actions. You 
may set a color on a switch or a marble may cause a color change on a chess 
stone by hitting it with a revealed wand. The object will report the new kind on 
subsequent requests.

A few special object kinds do exist only for setting a new object. They are
usually named with a suffix @samp{_new}. These objects will never report their
initial kind name but change to a standard kind immediately.

If you are not interested in the specific subkind you can check an object for
conformity to any super kind. E.g. any switch stone of whatever color will 
return true if checked for @samp{st_switch}.

@node Object Reference
@subsection Object Reference

Having set objects to the various layers a level author sometimes has the need
of referencing them lateron. On callbacks the engine provides references to
sender objects. But the author can request any grid object anytime by its 
position.

With an object reference, that is of a special Lua type @samp{object}, you can
request the objects on its current state and attributes, modify the
object, send messages or perform any supported methods of the object.

Objects can be grouped for efficient handling of common operations on
all affected objects. E.g. if you can send a message to a group of objects
all objects will receive the message in turn. The sequence of several objects
in a group is constant and guaranteed to be observed in processing common
operations.

As objects can ceize to exist you have to be aware that the references are
volatile, too. You can check every object reference for existance. But in many
cases the validity of the reference is unimportant as Enigma 1.10 is very 
tolerant on invalid object references access. The operations will simply be
ignored and requests will return default values.

As a general thumb rule you should request and keep object references just
for the time of a local call. As long as your level code is processed in
sequence without the running world simulation giving the player a chance to
kill objects by marble actions, objects should ceize to exist just due to your
own direct statements.

To gain access to an object later on a subsequent call you can address it via 
two methods. First you can address it via its position. But as many objects are
movable the position is not constant. Therefore you can address an object by
name. @xref{Object Naming}.

@node Object Naming
@subsection Object Naming

For addressing objects on a longterm valid basis every object can individually 
be tagged by a name. Assigning a name to an object is as simple as setting
the attribute @samp{name} with a unique string on this object. Of course you
can request an objects name by reading the attribute @samp{name}.

The name is a string that should be made up of characters @samp{a..z}, 
@samp{A..Z}, numbers @samp{0..9} and the underscore @samp{_}. Other special
charcters are only allowed as far as they are explained in the following text.

@cindex auto naming
It is up to you to ensure unique names. Reusage of an already assigned name
will unname the prior object and assign the name to the new object. To simplify
the naming of larger groups of similar objects you can add the hash sign 
@samp{#} as the last character to a name, e.g. @samp{mydoor#}. This causes Enigma
to add a unique random number to the given string. Thus an auto named object
will never unname another prior auto named object. But if you delete an 
auto named object that has been named e.g. @samp{mydoor#103284} the number and
the same name may be assigned to another that is created lateron.

All named objects are registered by the @dfn{named object} repository. The API
provides a variable @samp{no} that allows you to retrieve any named object, e.g.
@samp{no["mylaser_a"]}. You get an @ref{Object Reference} or @samp{nil}, if no
object is registered by the given name.

As you can auto name groups of objects you are allowed to use the wildcard
characters @samp{?} and @samp{*}. The question mark replaces a single 
arbitrary character, the asterix any number of arbitrary characters. E.g.
@samp{no["mydoor#*"]} retrieves all auto named @samp{mydoor} objects in a single
object group.

Many object attributes like @samp{target}, @samp{destination} need object
references to other objects. Besides a volatile @ref{Object Reference} you always
can provide a name string as a longterm valid object reference. If the attribute
allows several objects to be given you can either give a group of object
references, a table of object names or a object name with wildcards. Thus
the string @samp{"mydoor#*"} is a valid target.

@cindex nearest object
Often switches are located near by their target object. As a major shortcut
you can reference the nearest object out of a group by prefixing its name
with an @samp{@@} character.

@example
ti["F"] = @{"st_floppy", target="@@door#*"@}
ti["D"] = @{"st_blocker", name="door#"@}
@end example

With this tile declaration you can describe arbitrary number of floppy switches
and nearby blocker doors in a world map all by the same two tile key characters.
Every floppy switch will target the nearest blocker door. If two target are
given within the same distance the one located in the south will win. If the
targets are additionally horizontally aligned the one located in east will win.
In the rare case of objects located on the same position stones will preceed
items, floors and actors. The chosen target or destination depends just on the
location of these objects and their type, but nothing else. Thus you can rely
on a stable selection mechanism. @ref{Nearest Object Clustering} may help you in
case of unexpected selected equidistant targets. 

Auto naming and nearest object features help you to reduce the number
of needed tile declarations. Resolvers like @ref{res.autotile} and
@ref{res.composer} are other feature for reducing the need of tile declarations.

Another unique feature of object names is their late on access evaluation. This
allows you to reference an object prior to its existence. E.g. if you want to
set two vortices each declaring the other one as its destination, object names
are the favorite solution:

@example
wo[@{3,4@}]  = @{"it_vortex", name="vortex1", destination="vortex2"@}
wo[@{15,9@}] = @{"it_vortex", name="vortex2", destination="vortex1"@}
@end example

In general you will need to use object name references within any tile 
declarations as none of the referenced objects will yet exist at the point of
tile declarations.

Objects do change over time. Doors do open, a chess may be recolored, a blocker
stone may shrink to a blocker item. This means that the kind of the objects
will change. But in many cases this means that the volatile object reference
will brake, too. For the sake of the level authors the identity of the object
will be transfered even if the reference gets invalid. And like the user
attributes the name is part of the object identity. Thus if you name an 
@ref{st_blocker} and it it shrinks to an @ref{it_blocker} you will retrieve this
item if you ask the name object repository for the named object.

When an object like a door is completly killed, e.g. by an @ref{it_seed},
it can no longer be targeted by active objects like switches. A still existing
reference to a no longer existing object does not cause problems on 
@ref{Messages}. But what about the nearest object references? To avoid problems
due to killed objects the standard nearest object reference with just one 
@samp{@@} as prefix are finalized on @ref{Level Initialization}. This means that
they get substituted by the unique name of the nearest object that exists after
the creation of all objects and before the user takes action and can kill a
candidate.

But sometimes you may like a dynamic nearest object target or destination. One
that is evaluated when it gets accessed. By prefixing a name with @samp{@@@@}
the reference will not get finalized on initialization but remains dynamic.

@example
ti["c"] = @{it_coin_s", "magic#"@}
ti["v"] = @{it_vortex", destination="@@@@magic#*"@}
@end example

Setting three magic coins and one vortex in your map will teleport the marble
to the grid of that coin that is nearest to the vortex at the moment of 
teleportation.

To avoid unexpected problems with invalid object references a few critical
objects are internally autonamed if the level author does not provide a name.
But these unique names should never interfere with the user assigned object
names.

@node Object Attributes
@subsection Object Attributes

One of the key concepts for the versatility of Enigma is possibility to fine
tune objects by means of attributes. The level author is not limited to a fixed
set of preconfigured objects as given by the object kind.

An attribute is a name, a string, with an assigned value. E.g. 
@samp{obj["inverse"]=true} sets a single object attribute to a boolean value
and @samp{@{"it_magnet", range=6.5@}} describes a magnet item with an initial set
floating point attribute.

The scope of values is manifold. Most Lua types and a bunch of Enigma specific
types can be assigned:
@itemize @bullet
@item bool
@item int
@item double
@item string
@item nil, DEFAULT
@item position
@item object
@item group
@item tokens
@end itemize

If we speak of a bool value we do it in the sense of Lua 5, that means with the
possible values @samp{true} and @samp{false}. 

Many enumerated values like directions and colors are covered by the integer
numbers.

Of special interest is the value @samp{nil}. Just a few attributes make direct
use of the value @samp{nil}, e.g. "color" on some objects. If you set an 
attribute to value @samp{nil} you do actually reset its value to the default
value. E.g. if you set the attribute "orientation" of @ref{st_boulder} to 
@samp{nil} it will be set to its default, which is actually @samp{NORTH}, an
enumerated direction value. A subsequent read of the attribute will return this
value. Just those attributes that allow a nil value will ever return @samp{nil}
on a read access. As a direct consequence these attributes always default to 
@samp{nil}.

The authors of Lua did decide to prohibit the usage of @samp{nil} as a value
in Lua tables. As we make heavy usage of anonymous tables as object 
declarations, you would not be able to set such attributes to @samp{nil}. You
would need to set such attributes explicitly. As a workaround we added a custom
value @samp{DEFAULT} that can be used anywhere to set attributes - even within
Lua tables.

@example
mySwitch["color"] = nil
mySwitch["color"] = DEFAULT
wo[{3,6}] = @{"ac_marble_black", player=DEFAULT@}
@end example

Note that @samp{DEFAULT} is not equal to @samp{nil}. They are different values
concerning Lua. They just result both in attributes reset to their default. If
you request a nil valued attribute you will always receive the Lua value
@samp{nil}. @samp{DEFAULT} will never be returned by the engine.

A group is an ordered set of @ref{Object Reference}s. As all contained objects
must exist this value is seldomly used for attributes in object declarations.
But is is very useful for postprocessing of objects and for usage within
@ref{Callback Function}s.

The most complex attribute value type are the tokens. Their purpose is the
specification of one or many objects. As Enigma provides several means to do
that this value type combines and mix all possibilities. A tokens value may 
be a string, representing an object name, an object reference, a group or a
table with any of these basic types in any sequence and number. E.g. the 
following right sides are all valid tokens for the attribute @samp{target}:

@example
obj1["target"] = "mydoor"
obj2["target"] = myobject
obj3["target"] = grp(ojb1, obj2, obj3)
obj4["target"] = @{"mydoor", myobject@}
obj5["target"] = @{grp(ojb1, obj2, obj3), "mydoor", myobject, "anotherdoor"@}
@end example

This versatility is useful to set tokens attributes independent of the given
object reference types.

The chapter @ref{Common Attributes and Messages} and its followers describe
the existing object attributes in detail.

Besides these predefined attributes the level author can store own information
on objects for later retrieval. Any name starting with an underscore @samp{_}
can be used for level specific purposes. This prefix has been chosen as the
resulting names are still valid Lua names. Common usage patterns are switches
or triggers with callback functions. These functions provide the sender, the
switch or trigger, as an argument. If you attach the same function to number of
senders you can store the necessary context information within the sender.

The internal engine uses object attributes as well. Such unaccessable attributes
are named with a leading dollar sign @samp{$}. They may appear in the documentation
for C++ developers information. Level authors should ignore these attributes.

In some cases you may observe a different behaviour on setting an attribute
within the object definition and setting the same attribute while the object
is already on the grid. E.g. a door @samp{@{"st_door_h", state = OPEN@}} is 
opened from the very beginning. Whereas @samp{mydoor["state"] = OPEN} on a
closed door will start opening the door. This takes a short time until the
door is really open. You find more details on these as aspects in the section
@ref{The Lifecycle of a Level}.

If you ever look into the C++ code you may wonder about the implementation of
attributes. They are not all directly stored in a map. Some of them are hold
in object instance variables, other do not exist at all. Objects attributes
are an abstract concept that unifies several internal features within a
common simple API for level description code. Within the C++ engine subtle
reasons like performance optimization forces a much more complex handling.

@c ----------------- Methods of Interaction -------------------- 

@node Methods of Interaction
@section Methods of Interaction

Having looked at the description of the initial object composition of a
level world we still need to undestand how to configure the dynamic behaviour
of a level.

@menu
* Messages::             Asking objects to do something
* Target - Action::      Automatic reactions on an event
* Callback Function::    Lua hooks to react on events
* Object State::
@end menu

@node Messages
@subsection Messages

You can generate an initially open door by setting its attributes. But how
can a switch stone open a door when it is hit by a marble? It simply sends
a message @samp{open} to the door. Another switch may send a message
@samp{on} to a laser or @samp{ignite} to an @ref{it_dynamite}. On explosion
the dynamite will in turn send automatically @samp{ignite} messages to the
neighbour grid positions.

Messages are a simple universal function or from the receiver object and the
Lua level authors point of view a "method". It takes two arguments - the message
name, a string, and an optional value. E.g.

@example
mydoor:message("open")
myboulder:message("orientate", NORTH)

mydoor:open()
myboulder:orientate(NORTH)
@end example

The last two examples are a common abbreviation of the first two ones.

Messages may return a value. But most messages just return @samp{nil}.

You can send any message to any object. Not supported messages are silently
ignored. This is the reason that an exploding dynamite can send @samp{ignite}
messages to its neighbours without knowing if the objects can be ignited at all.
Furtheron the dynamite has not to bother with the recipients of the messages.
Due to messages the sender and the receiver objects are totally decoupled
concerning the code base. Thus the level author just needs one method that
allows sending arbitrary messages to arbitrary objects.

You should not send a message during initialization of the level. You configure
the switch to send an @samp{open} message to the door by @ref{Target - Action}.
Within a Lua @ref{Callback Function} you may send messages during runtime to
any object.

All messages are listed and described in @ref{Common Messages} and the 
subsequent chapters.

@node Target - Action
@subsection Target - Action

The "target action paradigm" is a classical object oriented method that allows
you to easily plug together objects. One object is triggered by a function
call or by an event like an actor hitting a stone, crossing over or applying an
item. You simply plug this object to another target object and tell it to send
an action message. Everytime the first object is triggered it will send the 
message to its target.

You configure such a target action by setting the attributes @samp{target}
and @samp{action} on the first object. E.g. a for a switch stone that should
open a door named @samp{mydoor} you can write:

@example
@{st_switch, target="mydoor", action="open"@}
@end example

Objects like the switch can be triggered on and off. Each time they will
perform the action. If you would like the door to open and close in turn to
the switch you need another action than @samp{open}. The universal message for
changing targets in their alternate states is @samp{toggle}.

@example
@{st_switch, target="mydoor", action="toggle"@}
@{st_switch, target="mydoor"@}
@end example

Now the door will toggle in sync with the switch between its open and closed
state. The message @ref{toggle} can be used quite independent of the target 
object. In fact it is the default action message. As a default you may omit
the action in this case as it is demonstrated by the second example.

But keep in mind that toggling just changes the state of the target. If you
start with a switch in off state and an open door, the door will close when
the switch in turned on. They will not sync. If you configure two switches
both targeting the same door, you will have no clear relationship between the
switch states and the door.

As you remember messages can take a value. Action messages are no exception.
Every object sends its actions with a value, usually a bool value. A switch
sends a value @samp{true} if it just switched on, and a value @samp{false} if
it just switched off. The appropriate message for the door would be the 
universal message @samp{signal}:

@example
@{st_switch, target="mydoor", action="signal"@}
@end example

Now the door will open when the switch is turned on and close if the switch is
turned off.

The message @ref{signal} takes an integer value of @samp{0} or @samp{1}. 
Indeed the action value does not match. But in this as in many other cases 
the messages and values are designed in a way that they are autoconverted to
the appropriated type. This compatibility is the basis for a seamless plugging
of objects.

In many cases authors face the task of triggering two or more objects by a
single object. @samp{target} and @samp{action} are both able to take 
multiple values.  @samp{target} is of type tokens, as described in 
@ref{Object Attributes}, whereas @samp{action} can be a string or a table
of strings.

@example
@{st_switch, target=@{grp(ojb1, obj2, obj3), "mydoor", myobject, "anotherdoor"@},
            action=@{"toggle",              "open",   "turn",   "close"@}@}
@end example

All objects described by a token receive the related message in the action
table. If not enough messages are listed the default action @samp{toggle}
will be sent.

@node Callback Function
@subsection Callback Function



@node Object State
@subsection Object State

A key concept for the ability to plug together objects like switches and doors
are the very simple state machines of these objects. Most objects are described
by simple machines with just 2 states like @samp{ON},@samp{OFF} or @samp{OPEN},
@samp{CLOSED}. These objects can be plugged together by just few common messages.
Furtheron these simple state machines are suited to the gamers who do not want
to read manuals but want to explore the objects by playing with just a few tests.

Even though states are usally named by appropriate uppercase names like above,
the states are integer numbers starting with @samp{0} usually related to the
default state. But some objects use another mapping due to historic reasons.
E.g. states that are direction related use the state @samp{3} representing
@samp{NORTH} usually as the default and number the directions clockwise down to
@samp{0} representing @samp{WEST}.

In most cases it is sufficient to perform a state independent common action
like @ref{toggle}. Even two stated objects can be easily sychronized by the
standard action @ref{signal}. But sometimes you may want to perform very state
specific actions. Let us look how this can be done.

E.g. let us take an @ref{st_fourswitch}, that has four states, and two 
@ref{st_laser} which should be switched on and off. Both lasers should emit
their beams while the fourswitch is in 3 of its states. But one of them should
be off just while the fourswitch is in the @samp{EAST} state and the other
should be off just while the fourswitch is in the @samp{WEST} state. 
This can be done by usage of state dependent target and actions:

@example
@{st_fourswitch, target_3="laser#2", action_3="on",
                target_2="laser#1", action_2="off",
                target_1="laser#1", action_1="on",
                target_0="laser#2", action_0="off"@}
@end example

Adding a number as suffix to @samp{target_} and @samp{action_} gives you 
special target and action attributes that will take precedence over the general
@samp{target} and @samp{action} attributes if the state value equals the suffix
number. An alternative declaration would be:

@example
@{st_fourswitch, target=@{"laser#1", "laser#2"@},
              action_3=@{"nop",     "on"@},
              action_2=@{"off",     "nop"@},
              action_1=@{"on",      "nop"@},
              action_0=@{"nop",     "off"@}@}
@end example

Here we do address both lasers in all states. But one of them receives a 
@ref{nop} message that stands for "no operation". In fact this message will
never be send. It is just a dummy message that we have need of for syntax
reasons in the case above.

Another example are two @ref{it_trigger} that switch a laser. An object pressing
the first trigger should switch the laser on, an object pressing the second
trigger should switch it off. But a trigger is two stated and performs one
action on being pressed and another on being released. Thus we want to block
the actions on trigger release events:

@example
@{it_trigger, name="on_trigger",  target="laser#1", action_1="on", action_0="nop"@}
@{it_trigger, name="off_trigger", target="laser#1", action_1="off", action_0="nop"@}
@end example

The blocking of @samp{action_0} is essential and can not be omitted, as 
otherwise the default action would be performed. This would be a @samp{toggle}
message that would switch the laser.

As this useful default mechanism can sometimes be annoying you can switch off
the default message by setting the @ref{nopaction} attribute to true.

@example
@{it_trigger, name="on_trigger",  target="laser#1", action_1="on", nopaction=true@}
@{it_trigger, name="off_trigger", target="laser#1", action_1="off", nopaction=true@}
@end example

When an objects leaves a trigger the state @samp{0} action will be performed.
As neither @samp{action_0} nor @samp{action} is specified the default action
will be performed, which is now @samp{nop}.

If you ever look into the C++ code you may note that many objects do have much
more complex state machines than you expect from the level authors and gamers
view. This is due to running animations, timers, etc.. The C++ objects map their
complex internal state set to the much simpler external state set. This is the
main reason that some features that level authors request can not be provided
in the Lua API.

@c ----------------- The Lifecycle of a Level -------------------- 

@node The Lifecycle of a Level
@section The Lifecycle of a Level


Snapshot
Levelloading, Initialization, Runtime Callbacks, 
Ending Conditions - the mystery of Oxyds and Meditation
@menu
* Library Preloading:: 
* Snapshot Principle:: 
* Level Initialization:: 
* Runtime Ticks and Callbacks:: 
* Ending Conditions:: 
@end menu

@node Library Preloading
@subsection Library Preloading

@node Snapshot Principle
@subsection Snapshot Principle

Most levels contain objects that take influence on each other. A switch might
toggle a door by @ref{Target - Action}, marbles may press a trigger, or a laser
might activate a laserswitch or transform a hammer into a sword. Of course it is
essential to know how to set up such objects to get the desired start 
configuration without the objects changing unexpected on level initialization.

The snapshot principle is a simple thumb rule that you can rely on in describing
the level as snapshot of object at a given point of time. Every object has just
to be configured as it should be at the given time. All interactions that would
take place in a running game do not take place while setting objects during
initialization.

E.g. if a switch toggles a door and the switch should be initially on and the
door should be initially open you describe the object with exactly these
attributes:

@example
@{"st_switch", target="mydoor", state=ON@}
@{"st_door_v", name="mydoor", state=OPEN@}
@end example

A laser that is initially on that illuminates a laserswitch needs an initially
active laserswitch. But of course no attribute exists that would allow you to
set a laserwitch active. The snapshot principle includes the rule that all
internal states are updated without external actions. This means that the
laserswitch will show up active without causing an action on its target.

@example
@{"st_laser", state=ON@}
@{"st_laserswitch", target="mydoor"@}
@end example

What about objects that transform on laser light. The snapshot principle keeps
the object from transforming during initialization. A hammer that is set in
an initially existing laser beam will not transform to a sword. It remains as
a hammer that will transform on any subsequent new laser light during the game.

Of course it cannot be allowed to describe impossible initial level states.
Objects like dynamite do explode immediatly on a laser beam hit. Thus a 
dynamite item in an initial laser beam is a fault that causes an exception.
The snapshot principle forces you in this case to set an explosion item instead
of the dynamite.

Some objects do process internal state transformations that cannot be configured
by attributes. But some of these states may be of interest on describing a
snapshot of a level. Where possible a special object subkind exists with a suffix
of @samp{_new}. These objects can be used in the initial level description to
set objects in special initial states. E.g. @ref{it_blocker} provides such a
special subkind. Note that these objects will never report their initial
subkind on a kind request as they come into existance as a standard object.


@node Level Initialization
@subsection Level Initialization

global variables
tile declarations
world init
oxyd shuffle
postinit()

@node Runtime Ticks and Callbacks
@subsection Runtime Ticks and Callbacks

@node Ending Conditions
@subsection Ending Conditions


@c ===================  Lua API  =======================
@node Lua API
@chapter Lua API

Read API Concept Draft

@menu
* Lua Example:: 
* Enigma Lua Types::   
* Object Definitions and Tiles::
* Lua Positions::
* World Creation and Resolver Chaining::
* Custom Resolver::

@end menu

@c ----------------- Lua Example -------------------- 

@node Lua Example
@section Lua Example

@c ----------------- Enigma Lua Types -------------------- 

@node Enigma Lua Types
@section Enigma Lua Types



@c -------------- Object Definitions and Tiles ----------------- 

@node Object Definitions and Tiles
@section Object Definitions and Tiles

@c ----------------- Lua Positions -------------------- 

@node Lua Positions
@section Lua Positions
@c ----------------- World Creation and Resolver Chaining -------------------- 

@node World Creation and Resolver Chaining
@section World Creation and Resolver Chaining

Once all parameters have been set and all tiles have been declared it is time
to create the level world with all its objects. This is done by the following
constructor that appears in two variations.

@table @asis
@item @b{Syntax:}
width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{map})

width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{width}, @i{height})

@table @asis
@item @i{topresolver} = @code{ti} | @i{resolver} | @i{localresolver}
Every tile in the world is given by a key that needs to be resolved to its
declaration. This can be done either by the tiles repository @samp{ti}, or
by given library @ref{Resolvers} or by local @ref{Custom Resolver} function.
This argument takes the top resolver that is requested first.
@item @i{defaultkey}
A string that defines the key that should be taken as default. It is taken
if no other key is given and it is added to a tile if a floor object is
missing. The character length of this key defines the key size within the map
@item @i{map}
A table of strings. Each string describes a row of tiles by its tile keys.
If a map is given, the worlds size is determined from the longest string and
the number of rows.
@item @i{width}
As an argument that is given instead of a map it describes the width of the
desired world.
@item @i{height}
As an argument that is given instead of a map it describes the height of the
desired world.
@end table

@item @b{Syntax Samples:}
@example
w, h = wo(ti, "  ", 20, 13)
w, h = wo(resolver, " ", {
       "                    ",
       ...
       "                    "})
@end example

@item @b{Details:}
This world constructor may just be called once. Every subsequent call causes
an error. This call sets the size of the world to fixed values that are reported
by its two return values. The world size can lateron be retrieved by the world
attributes @ref{Width} and @ref{Height}, too.

A mapless world is filled with default tiles. Rows in a given map that are
shorter than others are filled with default tiles, too. Any tile that does
not define a floor object will add the floor object of the default tile.

Every key is resolved to its tile declaration via the given resolver chain.
The top resolver is given to this call as a parameter. If it is @samp{ti} the
chain consists just of one element and the tile delaration stored in the tiles
repository at the given key is taken. But there exist several useful 
@ref{Resolvers} that may simplify the task of level writing or provide dynamic
features like randomness, mazes, etc. If you like to use one or several of them
you provide the instance of the resolver to be requested first in this 
constructor. The instance that should be requested next is set in the top
resolver as first argument, and so on. The last library resolver takes usually
@samp{ti} as its subresolver. For even more flexibility you can provide an
own @ref{Custom Resolver} function within the level to take influence on the key
interpretation. This function has to be the last resolver in the chain.

@item @b{Example:}
@example
ti["~"] = @{"fl_water"@}
ti["s"] = @{"fl_sahara"@}
ti["t"] = @{"fl_tigris"@}
ti["1"] = @{"ac-blackball", 0, 0.5@}

ti["template_trigger"] = @{"it_trigger", target="myoxyd%%", action="open"@}
ti["template_oxyd"]    = ti["~"] .. @{"st_oxyd", "myoxyd%%"@}

myrandom = res.random(ti, " ", @{"s", "t"@})

myautotile = res.autotile(myrandom, @{"a", "h", "template_trigger"@}, 
                              @{"A", "H", "template_oxyd"@})
                                    
w, h = wo(myautotile, " ", @{
"A~                ~E",
"~~                ~~",
"~~   h        b   ~~",
"~~                ~~",
"B~     c    d     ~F",
"~~                ~~",
"~~        1       ~~",
"~~                ~~",
"C~     f    e     ~G",
"~~                ~~",
"~~   g        a   ~~",
"~~                ~~",
"D~                ~H"
@})

wo:shuffleOxyd()
@end example
@end table

@c ----------------- Custom Resolver -------------------- 

@node Custom Resolver
@section Custom Resolver

A customer resolver is a function in the level that allows a dynamic remapping
of tiles. When this function is registered in the resolver chain it is called
once for every tile to be set. The tile that this function return will be set.

Typical use cases are design patterns that are easy to calculate, but tedious
to draw in the map and dynamic generated levels that differ slightly on every
restart.

@table @asis
@item @b{Syntax:}
tile = @b{myresolver}(@i{key}, @i{x}, @i{y})

@table @asis
@item @i{key}
String that contains the tile key to be resolved.
@item @i{x}
The world x coordinate of the tile.
@item @i{y}
The world y coordinate of the tile.
@end table

@item @b{Details:}
A custom resolver function is the last resolver that is called in the chain.
It has to return the final tile that should be drawn at the given position.
This can be done by statement @samp{return ti["k"]}, which references the tile
already declared in the tiles map.

If no suited tile is already declared you can alternatively return a new tile
like @samp{return ti(@{"st_switch", state=ON@})}.

If you decide not to draw any tile at all, you must return an empty tile
declaration: @samp{return ti(@{@})}.

@samp{return nil} indicates an error of usage of an unknown tile key.

@item @b{Example:}
@example
ti["r"] = @{"fl_rough_red"@}
ti["b"] = @{"fl_rough_blue"@}
ti["1"] = @{"#ac-blackball"@}

ti["x"] = @{"it_cross"@}

function myresolver(key, x, y)
    if key == " " then
        local center = ((x%3) * (y%3))%2 
        local checker = ((math.modf(x/3) %2) + (math.modf(y/3) %2))%2
        if center + checker == 1 then
            return ti["r"]
        else
            return ti["b"]
        end
    else
        return ti[key]
    end
end

w, h = wo(myresolver, " ", @{
"                    ",
"                    ",
"                    ",
"      x x           ",
"       x            ",
"      x x           ",
"                    ",
"          1         ",
"                    ",
"                    ",
"                    ",
"                    ",
"                    "
@})
@end example
@end table

@c ===================  Commons  =======================
@node Common Attributes and Messages
@chapter Common Attributes and Messages

Some attributes and messages are common to many objects or even supported
by all objects. We describe them here in detail. The following chapters will
just reference them or even skip them when they are generally supported and
used in the default manner.

@menu
* Common Attributes:: 
* Common Messages::   
* Global Attributes::
@end menu

@node Common Attributes
@section Common Attributes

@menu
* name:: 
* state:: 
* target::
* action::
* nopaction::
* inverse::
* destination::
* movable::
* hit_*::
@end menu

@node name
@subsection name

The attribute of @ref{Object Naming} that allows you to name any object for 
reference purposes. It is up to you to ensure the uniqueness of the names. But
the engine supports you by autonumbering names ending on a @samp{#} sign 
(@pxref{Object Naming}). If you reuse an already used name the first object will
be unnamed and all name references will point to the new named object. If you
have need of naming an object you should do it with the object creation as
a few objects have need of names and will otherwise be named by the engine with
unique names.

Note that is attribute is not listed in the individual object descriptions.

@table @asis
@item @b{Type:} @ @ string
@item @b{Values:} @ @ @{a-zA-Z0-9_@}+
A sequence of characters of the given characters plus special characters as
mentioned in the text above.
@item @b{Default:} @ @ @code{nil}
Some objects will be autonamed if no name is defined.
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by all objects
@end table

@node state
@subsection state

The central attribute of any object that describes the current state of an 
object in its standard life cycle. This @ref{Object State} is described by
a simple number. Most dynamic objects have just 2 states. Others may have more.
The available states are listed with each object. This universal attribute
allows common messages like @ref{toggle}, @ref{signal}, @ref{on}, @ref{off},
@ref{open}, @ref{close}. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ dependent on the individual object
Please use the given upper case constants.
@item @b{Default:} @ @ @code{0}
@item @b{Access:} @ @ read/sometimes write
While it is common to set the state attribute on object creation, it is 
preferable to change the object state later on by messages.
@item @b{Support:} @ @ by all objects
@end table

@node target
@subsection target

All active objects react on being triggered by performing an action on their
targets. This attribute is part of the @ref{Target - Action} paradigm that 
guarantees pluggability of objects. You can either set a general @samp{target}
attribute for an object, or you can set @ref{state} dependent attributes 
@samp{target_0}, @samp{target_1},... (@pxref{Object State}). They all have the
same syntax:

@table @asis
@item @b{Type:} @ @ string, object, group, tokens @ @ @xref{Object Description}
Single targets may be declared by their object name or their reference. Multiple
targets can be declared by usage of groups and tokens.
@item @b{Values:} @ @ @xref{Object Attributes}
@example
target = "myDoor"
target = myObject
target = @{"myDoor", myObject@}
target = @{grp(obj1, obj2), "myDoor", myObject@}
@end example

@item @b{Default:} @ @ @code{nil}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by all objects
@end table

@node action
@subsection action

All active objects react on being triggered by performing an action on their
targets. This attribute is part of the @ref{Target - Action} paradigm that 
guarantees pluggability of objects. You can either set a general @samp{action}
attribute for an object, or you can set @ref{state} dependent attributes 
@samp{action_0}, @samp{action_1},... (@pxref{Object State}). They all have the
same syntax:

@table @asis
@item @b{Type:} @ @ string, tokens of strings @ @ @xref{Target - Action}
A single action may be declared by its message string. Multiple actions that
match multiple targets can be declared by tokens of strings.
@item @b{Values:} @ @ @xref{Object Attributes}
@example
action = "open"
action = @{"open", "turn", "toggle"@}
@end example

@item @b{Default:} @ @ @code{nil}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by all objects
@end table

@node nopaction
@subsection nopaction

A very special addition to the @ref{Target - Action} paradigm that allows
in case of state specific actions to deny the sending of default messages
(@pxref{Object State}).

@table @asis
@item @b{Type:} @ @ bool
@item @b{Values:} @ @ @code{true}, @code{false}
@item @b{Default:} @ @ @code{false}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by all objects
@end table

@node inverse
@subsection inverse

An attribute that requests an invertion of the action value. It is supported by
all objects with boolean action values.

Note that this attribute is not listed in the individual object description
if the object has boolean action values.

@table @asis
@item @b{Type:} @ @ bool
@item @b{Values:} @ @ @code{true}, @code{false}
@item @b{Default:} @ @ @code{false}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by most objects
All objects with boolean action values will support this attribute. Additionally
some objects with other invertable action value types like directions will
support the invertion of their attributes as stated in the individual object
descriptions.
@end table

@node destination
@subsection destination

An attribute that describes one or several destinations. It is used by objects
like @ref{it_vortex} and @ref{it_wormhole} to describe their teleporting
destination.

Note that this attribute is only supported if it is listed in the individual
description.

@table @asis
@item @b{Type:} @ @ tokens or a single position
Just a single position for a first destination is allowed. Use tokens to
define multiple destination.
@item @b{Values:} @ @ @xref{Object Attributes}
@example
destination = po(3.0, 4.7)
destination = "myFloor"
destination = myObject
destination = @{"vortex2","vortex3","vortex4"@}
@end example
Note that objects like @samp{it_wormhole} that have just a single destination
do take the first token object.
@item @b{Default:} @ @ @code{nil}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by teleporting objects
@end table

@node movable
@subsection movable

An attribute that describes if a stone is movable by actor impulses. It is 
supported by all stones.

Note that this attribute is not listed in the individual stone description
if the stone is generally not movable.

@table @asis
@item @b{Type:} @ @ bool
@item @b{Values:} @ @ @code{true}, @code{false}
@item @b{Default:} @ @ usually @code{false}
If a stone exists only in a movable variant this attribute will default to
@samp{true}.
@item @b{Access:} @ @ read/sometimes write
This attribute is only writable for objects that exist in both variations.
@item @b{Support:} @ @ by all stones
@end table

@node hit_*
@subsection hit_*

A set of attributes that allow you to distort hit forces. Objects like 
@ref{st_flash}, @ref{st_spitter} and @ref{st_actorimpulse} apply forces that
are either based on the hit velocity or the position. 

By usage of a simple @samp{hit_factor} you can increase, decrease or invert the
default factor. Note that you must not set this attribute, if you want to use
the default.

By setting the four attributes @samp{hit_distortion_xx}, @samp{hit_distortion_xy},
@samp{hit_distortion_yx} and @samp{hit_distortion_yy} you can describe a 
matrix to set up a new direction. These attributes default to 1, 0, 0, 1. 
A 90 degree clockwise turn is described by 0, 1, -1, 0.

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ 
@item @b{Default:} @ @ factor - @code{nil}, xx, yy - @code{1}, xy, yx - @code{0}
By default no hit factor is applied. The hit matrix is the neutral one.
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ by some stones
@end table


@node Common Messages
@section Common Messages

@menu
* toggle:: 
* nop::
* signal::
* on::
* off::
* open::
* close::
@end menu

@node toggle
@subsection toggle

This is the default message that is always taken if no other message is provided.
It toggles the @ref{Object State} quite independent of the very nature of the
state. Two-stated objects like switches will toggle their state form @samp{ON}
to @samp{OFF} or from @samp{OFF} to @samp{ON}. Door like objects will toggle 
their state from @samp{OPEN} to @samp{CLOSED} or from @samp{CLOSED} to 
@samp{OPEN}. Other objects like @ref{st_fourswitch} will turn into the next
direction. Generally the object will toggle to its next state.

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by nearly all objects which use the @samp{state} attribute
@end table

@node nop
@subsection nop

A dummy message that just does nothing: no operation. You may need it in cases
of state dependent actions to block an otherwise sent default @samp{toggle}
message (@pxref{Object State}).

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by all objects
@end table

@node signal
@subsection signal

A signal message tries to set the object to the state 0 (@samp{OFF}, 
@samp{CLOSED}) or state 1 (@samp{ON}, @samp{OPEN}) according to its value. This
message allows you to keep the states of an action source and a receiving object
in sync. Note that values like @samp{true}, @samp{false} and direction values
like @samp{WEST} to @samp{NORTH} are converted to 0 and 1. This allows you to
use @samp{signal} as action message on most objects.

@table @asis
@item @b{Value:} @ @ @code{0}, @code{1}
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by nearly all objects which use the @samp{state} attribute
@end table

@node on
@subsection on

This message is just supported by objects that can be switched on and off. Just
objects in state @samp{OFF} will be switched on. An object in state @samp{ON}
remains unchanged in its state.

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by objects that can be switched on and off
@end table

@node off
@subsection off

This message is just supported by objects that can be switched on and off. Just
objects in state @samp{ON} will be switched off. An object in state @samp{OFF}
remains unchanged in its state.

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by objects that can be switched on and off
@end table

@node open
@subsection open

This message is just supported by door like objects that can be opened and closed.
Just objects in state @samp{CLOSED} will be opened. An object in state 
@samp{OPEN} remains unchanged in its state.

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by door like objects that can be opened and closed
@end table

@node close
@subsection close

This message is just supported by door like objects that can be opened and closed.
Just objects in state @samp{OPEN} will be closed. An object in state 
@samp{CLOSED} remains unchanged in its state.

@table @asis
@item @b{Value:} @ @ -
@item @b{Returns:} @ @ -
@item @b{Support:} @ @ by door like objects that can be opened and closed
@end table

@node Global Attributes
@section Global Attributes

@menu
* ActorimpulseStrength::
* ExtralifeGlasses::
* FollowAction::
* FollowGrid::
* FollowMethod::
* FollowThreshold::
* Height::
* IsDifficult:: 
* MagnetRange:: 
* MagnetStrength::
* MaxOxydColor::
* Width::
* WormholeRange:: 
* WormholeStrength:: 
@end menu

@node ActorimpulseStrength
@subsection ActorimpulseStrength

A global scalar default factor for the actorimpulse stone bumping force. This 
global value is only used if no object specific value is set. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ float number
@item @b{Default:} @ @ @code{+200.0}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{st_actorimpulse}
@end table

@node ExtralifeGlasses
@subsection ExtralifeGlasses

A global variable that defines the @ref{it_glasses} type that is generated on
the laser light convertion of an @ref{it_extralife}

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ positive integer number
A sum out of the constants @samp{SPOT_DEATH}, @samp{SPOT_HOLLOW},
@samp{SPOT_ACTORIMPULSE}, @samp{SPOT_SENSOR}, @samp{SPOT_LIGHTPASSENGER}, 
@samp{SPOT_TRAP}
@item @b{Default:} @ @ @code{SPOT_DEATH + SPOT_HOLLOW + SPOT_LIGHTPASSENGER}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{it_extralife}
@end table

@node FollowAction
@subsection FollowAction

A global variable that describes the action of the display on relocation. This
attribute is introduced for future extensions, but is currently just partially
supported. Just the values listed below are used. Please use this attribute
just as explained in @ref{Display Follow Strategy}.

@table @asis
@item @b{Type:} @ @ number or position
@item @b{Values:} @ @ @code{0}, @code{FOLLOW_FULLSCREEN}, @code{HALFSCREEN}
The distance of display readjustment. Positions are used to supply different 
values for x and y. The value @samp{@{19, 12@}} is a standard full screen move.
The value @samp{@{9.5, 6@}} is a standard half screen move. A value @samp{0}
is a minimal smooth move or the default value for grid based moves.
@item @b{Default:} @ @ @code{@{19, 12@}}
Actually the default is mode based (@pxref{Display Follow Strategy}).
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ no objects
@end table


@node FollowGrid
@subsection FollowGrid

A global variable that determines if the display is fixed in its static
positions to grids or if it can be scrolled to any pixel position 
(@pxref{Display Follow Strategy}).

@table @asis
@item @b{Type:} @ @ bool
@item @b{Values:} @ @ @code{true}, @code{false}
@item @b{Default:} @ @ @code{true}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ no objects
@end table

@node FollowMethod
@subsection FollowMethod

A global variable that describes the method how the display moves, either not
at all, by pixelwise scrolling, or by flipping to another screen or region
(@pxref{Display Follow Strategy}).

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ @code{FOLLOW_NO}, @code{FOLLOW_SCROLL}, @code{FOLLOW_FLIP}
@item @b{Default:} @ @ @code{FOLLOW_FLIP}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ no objects
@end table

@node FollowThreshold
@subsection FollowThreshold

A global variable that describes the threshold at which a crossing active marble
triggers the display to relocate. It is given as the distance to the screen
boundary (@pxref{Display Follow Strategy}).

@table @asis
@item @b{Type:} @ @ number or position
@item @b{Values:} @ @ 0 or positive number, or a pair of two positive numbers
The distance from the screen boundary at which the displays readjusts. Positions
are used to supply different values for x and y. All values need to be less
than half of the screen size.
@item @b{Default:} @ @ @code{0.5}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ no objects
@end table


@node Height
@subsection Height

A global read only variable reports the height of the world in grid units.
This is set by the initial world constructor call 
(@pxref{World Creation and Resolver Chaining}).

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ positive integer number
@item @b{Default:} @ @ @code{?}
@item @b{Access:} @ @ read only
@item @b{Support:} @ @ object independent
@end table

@node IsDifficult
@subsection IsDifficult

A global read only variable that defines the current diffculty mode selected
by the user. All differences of easy and difficult mode within the level should
be coded solely in dependence of this flag. If a level that supports an easy
mode the author needs to declare it in the XML header in the element 
@ref{<modes>}.

@table @asis
@item @b{Type:} @ @ bool
@item @b{Values:} @ @ @code{true}, @code{false}
@item @b{Default:} @ @ @code{true}
@item @b{Access:} @ @ read only
@item @b{Support:} @ @ object independent
@end table

@node MagnetRange
@subsection MagnetRange

A global default distance up to which magnets apply forces to actors. This
global value is only used if no object specific value is set. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ positive float number or zero
@item @b{Default:} @ @ @code{10.0}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{it_magnet}
@end table

@node MagnetStrength
@subsection MagnetStrength

A global scalar default factor for magnet forces. Positive numbers are 
attracting forces where as negative numbers are repelling forces. This global 
value is only used if no object specific value is set. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ float number
@item @b{Default:} @ @ @code{30.0}
Positve number are attracting, negative numbers are repelling.
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{it_magnet}
@end table

@node MaxOxydColor
@subsection MaxOxydColor

A global variable that limits the number of colors assigned to autocolored
@ref{st_oxyd}. Be careful with increasing this value beyond its default.

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ @code{OXYD_BLUE}, ... @code{OXYD_BROWN}
@item @b{Default:} @ @ @code{OXYD_BLACK}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{st_oxyd}
@end table

@node Width
@subsection Width

A global read only variable reports the width of the world in grid units.
This is set by the initial world constructor call 
(@pxref{World Creation and Resolver Chaining}).

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ positiv integer number
@item @b{Default:} @ @ @code{?}
@item @b{Access:} @ @ read only
@item @b{Support:} @ @ object independent
@end table


@node WormholeRange
@subsection WormholeRange

A global default distance up to which wormholes apply forces to actors. This
global value is only used if no object specific value is set. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ positive float number or zero
@item @b{Default:} @ @ @code{10.0}
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{it_wormhole}
@end table

@node WormholeStrength
@subsection WormholeStrength

A global scalar default factor for wormhole forces. Positive numbers are 
attracting forces where as negative numbers are repelling forces. This global 
value is only used if no object specific value is set. 

@table @asis
@item @b{Type:} @ @ number
@item @b{Values:} @ @ float number
@item @b{Default:} @ @ @code{30.0}
Positive number are attracting, negative numbers are repelling.
@item @b{Access:} @ @ read/write
@item @b{Support:} @ @ @ref{it_wormhole}
@end table

@c ===================  Floors  =======================

@node Floor Objects
@chapter Floor Objects
@c ===================  Items  =======================

@node Item Objects
@chapter Item Objects

@menu
* Standard Items:: 
@end menu

@node Standard Items
@section Standard Items

@menu
* it_blocker::         Shrinked Blocker Stone
* it_brush::           
* it_coin::            Enigma's currency
* it_cross::           Floor switch for patient Actors
* it_death::           Unpassable grid blocker
* it_extralife::
* it_floppy::          
* it_glasses::         Glasses to spot certain objects
* it_hammer::
* it_key::             
* it_landmine::        
* it_magnet::
* it_sensor::          Floor Switch for passing Actors
* it_sword::
* it_trap::            
* it_trigger::         Floor Switch for Actors and Stones
* it_umbrella::        Death Protection Item
* it_vortex::          Teleport of Marbels
* it_wormhole::        Teleport of Actors
* it_wrench::          
@end menu


@c ----------------- Blocker Item -------------------- 
@node it_blocker
@subsection it_blocker
@obindex it_blocker

A door like object that grows to @ref{st_blocker} when an @ref{st_boulder}
passes. When the boulder did shrink and pass the blocker again it stays in its
item like open state until it is passed again by a boulder which causes it to 
grow again to a blocker stone.

It fully supports the messages of any door like object and can be opened and
closed by any switch like object. Note that due to the transformation between
stone and item during opening and closing you should name the blocker
(@pxref{name}) and address the blocker by this name. The complete identity
with all attributes including any user attributes will be transfered between
stone and item. E.g. @code{@{it_switch, target="myblocker", action="toggle"@}}
will open and close a given blocker multiple times.

Note that the blocker is the only door object that allows a stone to be pushed
through. Just boulders cause the growing. Any other stone keeps the open state.

Another unique door feature is the closing of a blocker item caused by a 
passing actor if the autoclose attribute is set to true.

Note that a dropped @ref{it_brake} destroys this item.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{0}, @code{1}; @ @ @i{default}: @code{1} @ @ @xref{state}
Use CLOSED and OPEN macros as values. The item represents the open state
and will always return state 1. But you can set its state what is equivalent
to sending an open message in case of value 1 and a close message in case of
value 0.

@atindex autoclose
@item @b{autoclose} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
A true value causes any actor passing this item to close and grow the blocker.

@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
A signal of value 1 sends an open message, a signal of value 0 sends a close
message.
@item @b{toggle} @ @ @xref{toggle}
A toggle causes a close message.
@item @b{close} @ @ @xref{close}
A close message take immediate effect if the item is not covered by a stone.
The item transforms to a new growing @ref{st_blocker}. If it is covered by a
stone of whatever kind it will be marked as unlocked. The closing process starts
when the stone moves away.
@item @b{open} @ @ @xref{open}
As the item is open this message takes only effect if it is currently covered
by a stone and marked as unlocked. That means it should grow as soon as the
stone moves away what happens when an @ref{st_boulder} passes an idle blocker
item. In this case an open message locks the blocker again to avoid a growing
when the stone moves away.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}
Sends an action at the moment the blocker reaches the open state. That means
an @ref{st_blocker} did open and did generate this blocker item as its
successor. The value will be @code{true} to express the open state.

@item @b{Variants:}
@table @asis
@item @b{it_blocker}
A standard blocker item.
@item @b{it_blocker_new}
A blocker that just finished shrinking. Mainly used internally as the direct
successor of an @ref{st_blocker}. But it may be useful to generate an initial
snapshot of a moving boulder over a blocker line, too. See example levels.
@end table

@end table

@c ----------------- Brush Item -------------------- 
@node it_brush
@subsection it_brush
@obindex it_brush

TBD

@table @asis

@item @b{Attributes:} none

@item @b{Messages:} none

@end table

@c ----------------- Coin Item -------------------- 
@node it_coin
@subsection it_coin
@obindex it_coin

A coin activates an @ref{st_coinslot} when inserted by hitting the stone with
the coin as first item in the players inventory. The time interval of activity 
of the coinslot depends on the coin type that is represented by its 
@samp{state}. Small, medium and large coin variants do exist.

When hit by a moving stone the coin type changes from small to medium and
from medium to large.

A laser beam transforms a small coin into an @ref{it_umbrella}, a medium coin
into an @ref{it_hammer} and a large coin into an @ref{it_extralife}.

A coin that comes into existence on an illuminated grid position will not
transform due to already existing laser beams. But it will transform on the first
additional beam and on laser beams that are switched off and on again.

@table @asis

@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{0}, @code{1}, @code{2}; @ @ @i{access}: @code{read only} @ @ @xref{state}
Represents the coin type with 0 being a small coin, 1 being a medium coin and
2 being a large coin.
@end table

@item @b{Messages:} none

@item @b{Variants:}
@table @asis
@item @b{it_coin}
A small coin.
@item @b{it_coin_s}
A small coin.
@item @b{it_coin_m}
A medium coin.
@item @b{it_coin_l}
A large coin.
@end table

@end table

@c ----------------- Cross Item -------------------- 
@node it_cross
@subsection it_cross
@obindex it_cross

An eye-catching cross spot that can detect actors staying on it for a given
time. When an actor remains on top of the cross for the given @samp{interval}
without any other actor leaving or passing the cross grid the cross will perform
its action. Similar, but instant sensors for actors are @ref{it_sensor} and
@ref{it_trigger}

A cross can be drawn with an @ref{it_pencil} and it can be removed with an
@ref{it_brush}.

An @ref{st_lightpassenger} moving onto a cross item will switch off.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{0}, @code{1}; @ @ @i{access}: @code{read only} @ @ @xref{state}
The current state - @samp{0} for the last event being an actor leaving the cross,
@samp{1} for the last event being an actor entering the cross.

@item @b{interval} @ @ @i{values}: positive number; @ @ @i{default}: @code{10.0}
Number of seconds that the actor must stay on the sensor to cause an action.

@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Death Item -------------------- 
@node it_death
@subsection it_death
@obindex it_death

This item shatters any marble that tries to pass the grid. Even jumping marbles
will be shattered. Just marbles protected by an activated @ref{it_umbrella} can
pass without taking harm. Apart from that an @samp{it_death} barrier can only be 
passed by walking around the complete barrier or by warping through an
@ref{it_vortex}, an @ref{it_wormhole} or by means of an @ref{it_ring}.

The death item is the most secure barrier object. Comparable objects are
@ref{it_booze_broken}, @ref{fl_abyss}, @ref{fl_water}, @ref{it_trap} or simply
any solid wall of stones. Usually these alternatives should be favored. The
death item should mainly be used when all other alternatives are too unsecure.

@table @asis

@item @b{Attributes:} none

@item @b{Messages:} none

@end table

@c ----------------- Extralife Item -------------------- 
@node it_extralife
@subsection it_extralife
@obindex it_extralife

An extralife transforms into @ref{it_glasses} when hit by a laser beam and is
itself a laser transformation result of an @samp{it_coin_l} (@pxref{it_coin}).
The global variable @ref{ExtralifeGlasses} describes what the new glasses are
able to spot.

An extralife that comes into existence on an illuminated grid position will not
be destroyed due to already existing laser beams. But it will be destroyed on
the first additional beam and on laser beams that are switched off and on again.

If another item transforms into an extralife this new extralife will be immune to
light destruction for a short latency period to avoid repeated item 
transformations.

@table @asis

@item @b{Variants:}
@table @asis
@item @b{it_extralife}
A standard extralife item.
@item @b{it_extralife_new}
An extralife that is immune to light destruction for a short latency period.
@end table

@end table

@c ----------------- Floppy Item -------------------- 
@node it_floppy
@subsection it_floppy
@obindex it_floppy

A floppy activates an @ref{st_floppy} when inserted by hitting the stone with
the floppy as first item in the players inventory.

@table @asis

@item @b{Attributes:} none

@item @b{Messages:} none

@end table

@c ----------------- Glasses Item -------------------- 
@node it_glasses
@subsection it_glasses
@obindex it_glasses

Glasses help a marble to spot certain other objects that are otherwise invisible
or indistinguishable. 

To be effective glasses must be hold in the top level of a players inventory.
That means that the glasses must be shown in the inventory and not be burried
in an @ref{it_bag} that is part of the inventory. Of course glasses just help
those actors that are attached to the player wearing the glasses.

Glasses can make invisible @ref{st_death} visible, can uncover invisible
passages by making hollow stones transparent, can make inactive
@ref{st_lightpassenger} be distinguishable from @ref{st_glass}, can make
invisble @ref{it_sensor}, @ref{it_trap} and @ref{st_actorimpulse} be visible.

All these features are configurable by the constants @samp{SPOT_DEATH},
@samp{SPOT_HOLLOW}, @samp{SPOT_LIGHTPASSENGER}, @samp{SPOT_SENSOR}, 
@samp{SPOT_TRAP} and @samp{SPOT_ACTORIMPULSE}. You can set the @samp{state} 
attribute to a sum of these constants that should apply to given glasses. The 
default is for  backward compatibility 
@samp{SPOT_DEATH + SPOT_HOLLOW + SPOT_LIGHTPASSENGER}. When a player wears 
several glasses he spots everything that any of the glasses could spot.

Glasses break when a stone is pushed over them. Broken glasses spot nothing.

Glasses result from the laser light transformation of @ref{it_extralife}. The
features of such new glasses are determined by the global variable 
@ref{ExtralifeGlasses}.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: positive numbers; @ @ @i{default}: @code{SPOT_DEATH + SPOT_HOLLOW + SPOT_LIGHTPASSENGER} @ @ @xref{state}
A sum of the constants @samp{SPOT_DEATH}, @samp{SPOT_HOLLOW}, 
@samp{SPOT_LIGHTPASSENGER}, @samp{SPOT_SENSOR}, @samp{SPOT_ACTORIMPULSE},
@samp{SPOT_TRAP}. @samp{SPOT_NOTHING} is the state of a broken glasses.
@end table

@item @b{Messages:} none

@item @b{Variants:}
@table @asis
@item @b{it_glasses}
Active glasses item.
@item @b{it_glasses_broken}
Broken glasses that spot nothing.
@end table

@end table

@c ----------------- Hammer Item -------------------- 
@node it_hammer
@subsection it_hammer
@obindex it_hammer

The hammer is used to destroy some stones, see @ref{Breakable Stones} and 
@ref{st_lightpassenger}. 

It transforms into @ref{it_sword} when hit by a laser beam and is itself a
laser transformation result of an @ref{it_sword} and an @samp{it_coin_m} 
(@pxref{it_coin}).

An hammer that comes into existence on an illuminated grid position will not
transform due to already existing laser beams. But it will transform on the first
additional beam and on laser beams that are switched off and on again.

If another item transforms into an hammer this new hammer will be immune to
further light transformations for a short latency period to avoid unstable
flickering of repeated item transformations.

@table @asis

@item @b{Variants:}
@table @asis
@item @b{it_hammer}
A standard hammer item.
@item @b{it_hammer_new}
A hammer that is immune to light transformations for a short latency period.
@end table

@end table

@c ----------------- Key Item -------------------- 
@node it_key
@subsection it_key
@obindex it_key

A key activates an @ref{st_key} when inserted by hitting the stone with
the key as first item in the players inventory.

@table @asis

@item @b{Attributes:} none

@table @asis
@item @b{code}, @ @ @i{values}: number; @ @ @i{default}: @code{1}
The code of a key must match that of an @ref{st_key} to unlock it.
@end table

@item @b{Messages:} none

@end table

@c ----------------- Landmine Item -------------------- 
@node it_landmine
@subsection it_landmine
@obindex it_landmine

A static item that explodes on actors stepping onto its critical center part and
on stones being pushed onto the mine.

The landmine explodes shattering nearby marbles on the same grid and leaves an
@ref{it_hollow} behind.

Actors can jump over a landmine and pass carefully between two adjacent 
landmines without activying the mines. Landmines do neither react on nearby
explosions, nor fire, nor laserbeams.

@table @asis
@item @b{Attributes:} none

@item @b{Messages:} none

@item @b{Action:} none

@end table

@c ----------------- Magnet Item -------------------- 
@node it_magnet
@subsection it_magnet
@obindex it_magnet

Attracts or repells actors in its @samp{range} with a force proportional to the
@samp{strength} and the inverse of the squared distance. A magnet can be 
switched @samp{ON} and @samp{OFF}.

Note that no forces are applied to actors at a distance smaller than 0.05 grids
to avoid extraordinary large forces.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
The current magnet state - @samp{ON} for an active magnet, @samp{OFF} for an
inactive magnet.

@item @b{range} @ @ @i{values}: float number greater or equal 0; @ @ @i{default}: @code{10.0} @ @ @xref{MagnetRange}
The distance up to which the magnet applies forces to actors.

@item @b{strength} @ @ @i{values}: float number; @ @ @i{default}: @code{+30.0} @ @ @xref{MagnetStrength}
A scalar factor for magnet forces. Positive numbers are attracting forces
where as negative numbers are repelling forces.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
A signal of value 1 switches the magnet on, a value of 0 switches the magnet off.
@item @b{toggle} @ @ @xref{toggle}
A toggle causes a change in the magnet activity state.
@item @b{on} @ @ @xref{on}
Switches the magnet on.
@item @b{off} @ @ @xref{off}
Switches the magnet off.
@end table

@item @b{Action:}
none

@item @b{Variants:}
@table @asis
@item @b{it_magnet}
A magnet in state @samp{OFF}.
@item @b{it_magnet_on}
A magnet in state @samp{ON}.
@item @b{it_magnet_off}
A magnet in state @samp{OFF}.
@end table

@end table

@c ----------------- Sensor Item -------------------- 
@node it_sensor
@subsection it_sensor
@obindex it_sensor

The sensor item is a switch on top of a floor that reacts on actors passing it.
It just performs actions on actors entering the sensors grid. It will
send an action value of @samp{true} but of course the @ref{inverse} attribute
can be used to send an action value of @samp{false} instead.

Any actors passing the grid, either on the floor or jumping over it will be
detected.

Sensors do not cause any noise. Visible sensors will nevertheless flash on
passing actors. You can make the trigger invisible by setting its attribute. 
Be aware that the user will still notice that actors cannot drop items onto the
same grid position. 

The level author can configure @ref{it_glasses} by addition of 
@samp{SPOT_SENSOR} to show invisible sensor items. An actor with such an
@ref{it_glasses} in its inventory will be able to spot invisible sensor items.
With the global attribute @ref{ExtralifeGlasses} even glasses generated by laser
lighting an @ref{it_extralife} can be configured not to show invisible sensor 
items.

Alternative objects that react on actors are @ref{it_trigger} and 
@ref{it_cross}.

@table @asis
@item @b{Attributes:}

@table @asis

@item @b{invisible} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
An invisible sensor is totally transparent. But the user may notice it, as actors
cannot drop items onto the same grid position.

@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table


@c ----------------- Sword Item -------------------- 
@node it_sword
@subsection it_sword
@obindex it_sword

The sword is used to neutralize @ref{st_knight}. 

It transforms into @ref{it_hammer} when hit by a laser beam and is itself a
laser transformation result of an @ref{it_hammer}.

A sword that comes into existence on an illuminated grid position will not
transform due to already existing laser beams. But it will transform on the first
additional beam and on laser beams that are switched off and on again.

If another item transforms into a sword this new sword will be immune to
further light transformations for a short latency period to avoid unstable
flickering of repeated item transformations.

@table @asis

@item @b{Variants:}
@table @asis
@item @b{it_sword}
A standard sword item.
@item @b{it_sword_new}
A sword that is immune to light transformations for a short latency period.
@end table

@end table

@c ----------------- Trap Item -------------------- 
@node it_trap
@subsection it_trap
@obindex it_trap

A classical trap that is camouflaged by a floor image. Any marble stepping onto
this trap will break the trap and fall into the trap's abyss. But marbles can
jump unharmed over a trap. Movable stones can be pushed over a trap without any
reaction.

Any marble falling into a trap causes it to break and to become visible by the
remanents of the trap. The trap can be opened by messages, too.

The level author can configure @ref{it_glasses} by addition of 
@samp{SPOT_TRAP} to show invisible traps. An actor with such an
@ref{it_glasses} in its inventory will be able to spot invisible traps.
With the global attribute @ref{ExtralifeGlasses} even glasses generated by laser
lighting an @ref{it_extralife} can be configured not to show invisible traps.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{CLOSED}, @code{OPEN}; @ @ @i{default}: @code{CLOSED} @ @ @xref{state}
A @samp{CLOSED} trap is intact and invisible, an @samp{OPEN} trap is broken and
visible.
@end table
@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Opens the trap on value @samp{1}
@item @b{toggle} @ @ @xref{toggle}
Opens the trap.
@item @b{open} @ @ @xref{open}
Opens the trap.
@end table

@end table

@c ----------------- Trigger Item -------------------- 
@node it_trigger
@subsection it_trigger
@obindex it_trigger

The trigger item is a switch on top of a floor that reacts on actors and
stones on top of it that may press it. It performs actions when it is initially
pressed and again when it releases after the last object left it. A pressed 
trigger is in state @samp{ON} and will send an action value of @samp{true}, a 
released trigger is in state @samp{OFF} and will send an action value of 
@samp{false}.

Only actors moving on the floor will press triggers. An actor jumping over a
trigger will not press it. An actor jumping on a trigger will release and press
it again.

Just solid stones will press the trigger when pushed onto it. Floating, hollow
stones will generally not press the trigger with the exception of the hollow,
central puzzle stone (@pxref st_puzzle).

There is no way to set the state of a trigger manually. But the state can
nevertheless be read. At initialization a trigger that is pressed by objects 
will start in state @samp{ON} without sending actions due to the 
@ref{Snapshot Principle}.

You can make the trigger invisible by setting its attribute. Be aware that it
still produces its click-sounds and the user will notice that actors cannot drop
items onto the same grid position.

Alternative objects that react just on actors are @ref{it_sensor} and
@ref{it_cross}.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{access}: @code{read only} @ @ @xref{state}
The current switch state - @samp{ON} for a pressed trigger, @samp{OFF} for a
released trigger.

@item @b{invisible} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
An invisible trigger is totally transparent. But the user may notice it, as actors
cannot drop items onto the same grid position.

@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table


@c ----------------- Umbrella Item -------------------- 
@node it_umbrella
@subsection it_umbrella
@obindex it_umbrella

An activated umbrella temporarily protects a marble from @ref{st_death},
@ref{st_knight}, @ref{st_thief}, @ref{fl_abyss}, @ref{fl_water},
@ref{fl_swamp}, @ref{fl_thief}, @ref{it_death}, @ref{it_abyss},
@ref{it_booze_broken}, explosions, moving stones and the @samp{shatter}
and @samp{fall} messages; in other words, from all lethal situations and
thieves.

An umbrella gets destroyed when hit by a laser beam and is itself a
laser transformation result of an @samp{it_coin_s}(@pxref{it_coin}).

An umbrella that comes into existence on an illuminated grid position will not
be destroyed due to already existing laser beams. But it will be destroyed on
the first additional beam and on laser beams that are switched off and on again.

If another item transforms into an umbrella this new umbrella will be immune to
light destruction for a short latency period to avoid repeated item 
transformations.

@table @asis

@item @b{Variants:}
@table @asis
@item @b{it_umbrella}
A standard umbrella item.
@item @b{it_umbrella_new}
An umbrella that is immune to light destruction for a short latency period.
@end table

@end table

@c ----------------- Vortex Item -------------------- 
@node it_vortex
@subsection it_vortex
@obindex it_vortex

Teleports marbles to a given @samp{destination}. Unlike @ref{it_wormhole} it
does not teleport other actors.

In the simplest case, a vortex is connected to a single destination given by
an object or a position. If the destination is not blocked by a stone the
marble will be teleported to the destination.

If there multiple destination addresses are given, the marble will be teleported
to the single destinations in sequence. Blocked destinations are indicated by
sparkles. Finally the marble exists on the first unblocked destination. If no
unblocked destination exists the marble exists on the starting vortex. A level
author can write nice puzzle which require the user to block destinations to
reach the final destination of a vortex.

Vortices can be open or closed. Of course a marble can enter just an open
vortex. Closed vortices at the destination are opened automatically. By default
such vortices remain open. By usage of the attribute @samp{autoclose} you can
configure a vortex to close after a marble has been emitted.

Marbles are emitted by vortices in a jumping fashion. The user can accelerate
the marble for a short period and the marble may jump out of a vortex into a
desired direction.

Vortex teleportation take a short amount of time and the involved vortices are
blocked for other teleporting request during this process. Thus it is no problem
to set up destinations of vortices that build a cycle.

Rubberbands bound to teleported actors are cut by default. The attribute
@samp{scissor} allows you to control the cutting behaviour.


@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{OPEN}, @code{CLOSED}; @ @ @i{default}: @code{OPEN} @ @ @xref{state}
The visual state of a vortex. An @samp{OPEN} vortex may still be busy due
to ongoing teleportations and may not accept a marble.

@item @b{destination}, @ @ @i{values}: tokens or position; @ @ @i{default}: @code{nil} @ @ @xref{destination}
The destination of the teleport given by an object or a position.

@item @b{autoclose}, @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
Flag that indicates whether the vortex should be closed after a teleport.

@item @b{scissor}, @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{true}
Rubberband cutting behaviour on teleporting.

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Opens the vortex on value @samp{1}, and closes the vortex on value @samp{0}.
@item @b{toggle} @ @ @xref{toggle}
Opens a closed vortex and closes an open vortex if possible.
@item @b{open} @ @ @xref{open}
Tries to open the vortex.
@item @b{close} @ @ @xref{close}
Tries to close the vortex.
@end table

@item @b{Action:}
none

@item @b{Variants:}
@table @asis
@item @b{it_vortex}
A vortex in state @samp{OPEN}.
@item @b{it_vortex_open}
A vortex in state @samp{OPEN}.
@item @b{it_vortex_closed}
A vortex in state @samp{CLOSED}.
@end table


@end table

@c ----------------- Wormhole Item -------------------- 
@node it_wormhole
@subsection it_wormhole
@obindex it_wormhole

Teleports actors of any kind to a given @samp{destination}. Unlike 
@ref{it_vortex} every wormhole has a unique destination. But of course the
destination may be another wormhole which instantly teleports the actor again.
An infinite circle of wormholes that are connected by destinations is forbidden.

A wormhole can attract or repell actors in its @samp{range} with a force
proportional to the @samp{strength} and the inverse of the squared distance.
The force can be switched @samp{ON} and @samp{OFF} and is represented by its
external @samp{state}. Note that no forces are applied to actors at a distance
smaller than 0.05 grids to avoid extraordinary large forces.

Rubberbands bound to teleported actors are cut by default. The attribute
@samp{scissor} allows you to control the cutting behaviour.

After teleporting an actor, the wormhole's teleporting ability may be switched
off for a short latency period given by @samp{interval}. A latency separates
actors travelling through a wormhole and avoids overlapping actors at the
destination.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
The current force state - @samp{ON} for a force applying wormholes, @samp{OFF}
for force neutral wormholes.

@item @b{destination}, @ @ @i{values}: tokens or position; @ @ @i{default}: @code{nil} @ @ @xref{destination}
The destination of the teleport given by an object or a position.

@item @b{range} @ @ @i{values}: float number greater or equal 0; @ @ @i{default}: @code{10.0} @ @ @xref{WormholeRange}
The distance up to which the wormhole applies forces to actors.

@item @b{strength} @ @ @i{values}: float number; @ @ @i{default}: @code{+30.0} @ @ @xref{WormholeStrength}
A scalar factor for the wormhole force. Positive numbers are attracting forces
where as negative numbers are repelling forces.
@end table

@item @b{scissor}, @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{true}
Rubberband cutting behaviour on teleporting.

@item @b{interval} @ @ @i{values}: float number greater or equal 0; @ @ @i{default}: @code{0.0}
The latency time after a teleport during which no further teleports take place.


@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
A signal of value 1 switches the wormhole force on, a value of 0 switches the
wormhole force off.
@item @b{toggle} @ @ @xref{toggle}
A toggle causes a change in the wormhle force activity state.
@item @b{on} @ @ @xref{on}
Switches the wormhole on.
@item @b{off} @ @ @xref{off}
Switches the wormhole off.
@end table

@item @b{Action:}
none

@item @b{Variants:}
@table @asis
@item @b{it_wormhole}
A wormhole in state @samp{OFF}.
@item @b{it_wormhole_on}
A wormhole in state @samp{ON}.
@item @b{it_wormhole_off}
A wormhole in state @samp{OFF}.
@end table

@end table

@c ----------------- Wrench Item -------------------- 
@node it_wrench
@subsection it_wrench
@obindex it_wrench

A wrench wielded as first item in the players inventory causes some objects
to react on actor hits. An @ref{st_rotator} changes its turning direction.
An green @ref{st_turnstile} rotates backwards when hit. An @ref{st_window}
face pushed with an wrench will swap to the opposite side of the stone if
possible.

@table @asis

@item @b{Attributes:} none

@item @b{Messages:} none

@end table

@c ===================  Stones  =======================
@node Stone Objects
@chapter Stone Objects

@menu
* Simple Stones::
* Cluster Stones::
* Transparent Stones::
* Breakable Stones::
* Special Stones::
@end menu


@node Simple Stones
@section Simple Stones

@node Cluster Stones
@section Cluster Stones

A cluster stone is a passive wall stone like a simple stone. But several
cluster stones adjacent to each other can visually build a cluster and look
like a single big stone with a one common outer face.

@menu
* Cluster Features::   Common Attributes and Features
* st_bluesand::        big sand stone look
* st_brick::           brick wall look
* st_panel::           wooden panel look
@end menu

@c ----------------- Cluster Features -------------------- 
@node Cluster Features
@subsection Cluster Features

For each cluster stone there exist 16 different variations that represent all
needed combinations of inner and outer faces to build arbitrary shaped big
blocks. 

There exist two methods of describing a special variation. You can either give
the inner faces, the @samp{connections}, those sides that should be adjacent to
other stones of the same cluster. Or you can give the outer faces, the 
@samp{faces}, that build the common outer face of the resulting big block.

As it is a tedious work to set up larger blocks by their single stones with
appropriate faces you can rely on an automatical clustering feature. Just
set the @samp{cluster} attribute of all single stones of a big block to the
same number and the faces will be set up automatically to form a large block.

You can build a screen of arbitrary big blocks and it is proven that there will
never be the need of more than 4 different cluster numbers (the "4 color 
theorem"). But for convenience you are free to use additional cluster numbers
as you like. Note that the autoclustering is quite dynamic. A single cluster
stone with fitting cluster number that is swapped at the side of an existing
block with the same cluster number will melt and join the block like seen in
"Terminator 2".

We recommend making use of the autoclustering feature by setting the 
@samp{cluster} attribute and using the @samp{faces} attribute where necessary.
@samp{connections} attribute and explicit naming of variations by a suffix 
are deprecated, but will continue to be supported.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{connections}, @ @ @i{values}: string; @ @ @i{default}: @code{nil}
Describes the inner faces of stone. The string is a substring of @code{"nesw"}
listing the inner faces. The sequence of the sides, north, east, south, west,
is guaranteed on read access but arbitrary on write access.

@item @b{faces} @ @ @i{values}: string; @ @ @i{default}: @code{nil}
Describes the outer faces of stone. The string is a substring of @code{"nesw"}
listing the outer faces. The sequence of the sides, north, east, south, west,
is guaranteed on read access but arbitrary on write access.

@item @b{cluster} @ @ @i{values}: number; @ @ @i{default}: @code{nil}
If set to a number all adjacent cluster stones of the same base type with
the identical cluster number will build a big block. This attribute superceds
any explicitly given face description.

@end table
@end table

@c ----------------- Bluesand Stone -------------------- 
@node st_bluesand
@subsection st_bluesand
@obindex st_bluesand

A standard cluster stone with the @ref{Cluster Features}. It is recommended
to use @samp{st_bluesand} with the attributes @samp{cluster} and @samp{faces}.

@table @asis
@item @b{Variants:}
@table @asis
@item @b{st_bluesand}: connections = @code{""}
@item @b{st_bluesand_w}: connections = @code{"w"}
@item @b{st_bluesand_s}: connections = @code{"s"}
@item @b{st_bluesand_sw}: connections = @code{"sw"}
@item @b{st_bluesand_e}: connections = @code{"e"}
@item @b{st_bluesand_ew}: connections = @code{"ew"}
@item @b{st_bluesand_es}: connections = @code{"es"}
@item @b{st_bluesand_esw}: connections = @code{"esw"}
@item @b{st_bluesand_n}: connections = @code{"n"}
@item @b{st_bluesand_nw}: connections = @code{"nw"}
@item @b{st_bluesand_ns}: connections = @code{"ns"}
@item @b{st_bluesand_nsw}: connections = @code{"nsw"}
@item @b{st_bluesand_ne}: connections = @code{"ne"}
@item @b{st_bluesand_new}: connections = @code{"new"}
@item @b{st_bluesand_nes}: connections = @code{"nes"}
@item @b{st_bluesand_nesw}: connections = @code{"nesw"}

@end table

@end table

@c ----------------- Brick Stone -------------------- 
@node st_brick
@subsection st_brick
@obindex st_brick

A standard cluster stone with the @ref{Cluster Features}. It is recommended
to use @samp{st_brick} with the attributes @samp{cluster} and @samp{faces}.

@table @asis
@item @b{Variants:}
@table @asis
@item @b{st_brick}: connections = @code{""}
@item @b{st_brick_w}: connections = @code{"w"}
@item @b{st_brick_s}: connections = @code{"s"}
@item @b{st_brick_sw}: connections = @code{"sw"}
@item @b{st_brick_e}: connections = @code{"e"}
@item @b{st_brick_ew}: connections = @code{"ew"}
@item @b{st_brick_es}: connections = @code{"es"}
@item @b{st_brick_esw}: connections = @code{"esw"}
@item @b{st_brick_n}: connections = @code{"n"}
@item @b{st_brick_nw}: connections = @code{"nw"}
@item @b{st_brick_ns}: connections = @code{"ns"}
@item @b{st_brick_nsw}: connections = @code{"nsw"}
@item @b{st_brick_ne}: connections = @code{"ne"}
@item @b{st_brick_new}: connections = @code{"new"}
@item @b{st_brick_nes}: connections = @code{"nes"}
@item @b{st_brick_nesw}: connections = @code{"nesw"}

@end table

@end table
@c ----------------- Panel Stone -------------------- 
@node st_panel
@subsection st_panel
@obindex st_panel

A standard cluster stone with the @ref{Cluster Features}. It is recommended
to use @samp{st_panel} with the attributes @samp{cluster} and @samp{faces}.

@table @asis
@item @b{Variants:}
@table @asis
@item @b{st_panel}: connections = @code{""}
@item @b{st_panel_w}: connections = @code{"w"}
@item @b{st_panel_s}: connections = @code{"s"}
@item @b{st_panel_sw}: connections = @code{"sw"}
@item @b{st_panel_e}: connections = @code{"e"}
@item @b{st_panel_ew}: connections = @code{"ew"}
@item @b{st_panel_es}: connections = @code{"es"}
@item @b{st_panel_esw}: connections = @code{"esw"}
@item @b{st_panel_n}: connections = @code{"n"}
@item @b{st_panel_nw}: connections = @code{"nw"}
@item @b{st_panel_ns}: connections = @code{"ns"}
@item @b{st_panel_nsw}: connections = @code{"nsw"}
@item @b{st_panel_ne}: connections = @code{"ne"}
@item @b{st_panel_new}: connections = @code{"new"}
@item @b{st_panel_nes}: connections = @code{"nes"}
@item @b{st_panel_nesw}: connections = @code{"nesw"}

@end table

@end table


@node Transparent Stones
@section Transparent Stones
@node Breakable Stones
@section Breakable Stones
@node Special Stones
@section Special Stones

@menu
* st_actorimpulse::    Bumper Stone
* st_blocker::         Shrinkable Blocker
* st_boulder::         Moving Arrow Boulder
* st_chess::           Movable Chess Knight Stone
* st_coinslot::        Coin Driven Switch
* st_death::           Skull Stone
* st_floppy::          Floppy Driven Switch
* st_fourswitch::      Four Direction Switch
* st_key::             Key Driven Switch
* st_laser::           Lightemitting Laser
* st_laserflop::       Lightsensitive Monoflop
* st_laserswitch::     Lightsensitive Switch
* st_lightpassenger::  Stone pushed by Light
* st_mirror::          Mirrors of all flavors
* st_monoflop::        Monoflop Switch
* st_oxyd::            Game Target Stone
* st_polarswitch::     Transparency Switch for Light Beams
* st_rotator::         Rotating Stone Impulser
* st_switch::          Classical on/off Switch
* st_timer::           Animated Timer
* st_window::          Faced Window
@end menu


@c ----------------- Actorimpulse Stone -------------------- 
@node st_actorimpulse
@subsection st_actorimpulse
@obindex st_actorimpulse

An active bumper for actors and some stones like @ref{st_boulder}. The 
actorimpulse stone can be made invisible while idle to introduce some surprise
effects.

Actors that hit this stone will not be reflected just passively. An additional
force will be applied to them that can even be distorted. By default the actors
are just pushed away from the center of the stone. A global attribute
@ref{ActorimpulseStrength} gives a default force that can be overridden by the 
stone attribute @samp{strength}.

For sophisticated usage you can distort this force by usage of the @ref{hit_*}
attributes. Note that the @samp{hit_factor} overrides a @samp{strength}
attribute.

An actorimpulse stone can be configured by the @samp{invisible} attribute to
be hidden while being idle. While pulsing any actorimpulse is visible. An
invisible actorimpulse can be made permanently visible by hitting it with a
revealed @ref{it_brush} in the player's inventory. The level author can configure
@ref{it_glasses} by addition of @samp{SPOT_ACTORIMPULSE} to show otherwise
invisible actorimpulse stones. With the global attribute @ref{ExtralifeGlasses}
even glasses generated by laser lighting an @ref{it_extralife} can be configured
to show invisible actorimpulse stones.

An @ref{st_boulder} hitting an actorimpulse stone will revert its direction
and return in the incoming direction.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{invisible} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
An invisible actorimpulse stone is totally transparent. But the user will
notice it, as actors will bounce with additional impulses.
@item @b{strength} @ @ @i{values}: float number; @ @ @i{default}: @code{+200.0} @ @ @xref{ActorimpulseStrength}
A scalar factor for the impulse force. Positive numbers are attracting forces
where as negative numbers are repelling forces.
@item @b{hit_factor} @ @ @i{values}: float number; @ @ @i{default}: @code{nil} @ @ @xref{hit_*}
A @samp{hit_factor} overrides a given @samp{strength} attribute.
@item @b{hit_distortion_xx} @ @ @i{values}: float number; @ @ @i{default}: @code{+1.0} @ @ @xref{hit_*}
@item @b{hit_distortion_xy} @ @ @i{values}: float number; @ @ @i{default}: @code{0.0} @ @ @xref{hit_*}
@item @b{hit_distortion_yx} @ @ @i{values}: float number; @ @ @i{default}: @code{0.0} @ @ @xref{hit_*}
@item @b{hit_distortion_yy} @ @ @i{values}: float number; @ @ @i{default}: @code{+1.0} @ @ @xref{hit_*}
@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@item @b{Variants:}

@table @asis
@item @b{st_actorimpulse}: invisible = @code{false}
@item @b{st_actorimpulse_invisible}: invisible = @code{true}
@end table

@end table

@c ----------------- Blocker Stone -------------------- 
@node st_blocker
@subsection st_blocker
@obindex st_blocker

A door like object that shrinks to @ref{it_blocker} when hit by an
@ref{st_boulder}. When the boulder did pass the blocker stays in its item like
open state until it is passed again by a boulder which causes it to grow again
to a blocker stone.

It fully supports the messages of any door like object and can be opened and
closed by any switch like object. Note that due to the transformation between
stone and item during opening and closing you should name the blocker
(@pxref{name}) and address the blocker by this name. The complete identity
with all attributes including any user attributes will be transfered between
stone and item. E.g. @samp{@{st_switch, target="myblocker", action="toggle"@}}
will open and close a given blocker multiple times.

Note that the blocker is the only door object that allows a stone to be pushed
through. Just boulders cause the growing. Any other stone keeps the open state.

Be aware that the @ref{it_brake} destroys an @ref{it_blocker}.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{OPEN}, @code{CLOSED}; @ @ @i{default}: @code{CLOSED} @ @ @xref{state}
The stone represents the closed state and will always return state @samp{CLOSED}.
But you can set its state what is equivalent to sending an open message in case
of value @samp{OPEN} and a close message in case of value @samp{CLOSED}.

@atindex autoclose
@item @b{autoclose} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
This attribute is irrelevant to the blocker stone itself. But it is transferred
to the @ref{it_blocker} when the blocker opens.

@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
A signal of value 1 sends an open message, a signal of value 0 sends a close
message.
@item @b{toggle} @ @ @xref{toggle}
A toggle causes an open unless the blocker stone is in the shrinking process.
In this case it causes a close message.
@item @b{open} @ @ @xref{open}
Starts an opening by shrinking the blocker. Note that during the shrinking
process the blocker still reports to be closed. The shrinking process can
be reverted by a close message.
@item @b{close} @ @ @xref{close}
A close message takes only effect on a blocker stone that is in the shrinking
process. The shrinking is stopped immediately and reverted to grow the blocker
again to full size.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}
Sends an action at the moment the blocker reaches the closing state. That means
an @ref{it_blocker} did close and did generate this blocker stone as its
successor. The value will be @samp{false} to express the closing state.

@item @b{Variants:}
@table @asis
@item @b{st_blocker}
A standard blocker stone.
@item @b{st_blocker_new}
A blocker that just starts growing. Mainly used internally as the direct
successor of an @ref{it_blocker}. But it may be useful to generate an initial
snapshot of a moving boulder over a blocker line, too. See example levels.
@end table

@end table

@c ----------------- Boulder Stone -------------------- 
@node st_boulder
@subsection st_boulder
@obindex st_boulder

This solid stone moves into the direction shown by the arrow on its picture.
A marble blocking its way is shattered. When a stone blocks its way, the boulder
triggers it by a sequence of two internal messages. Some stones give way like 
@ref{st_blocker}, others change their state like @ref{st_oxyd}, 
@ref{st_stoneimpulse}, @ref{st_fart}, @ref{st_mirror}, @ref{st_fourswitch},
@ref{st_volcano}. A third category switches temporarily into another state on the
first message sent when the boulder reaches a grid and switches back on the
second message sent when the boulder gives up like @ref{st_[black/white]},
@ref{st_plain}, @ref{st_lightpassenger}.

Items getting beneath a moving boulder may react like on any other stone move
on top of them. Additionally @ref{it_blocker} will be released to grow again
to a blocking stone.

Boulder stones fall into @ref{fl_abyss}, but cross @ref{fl_water}
unchanged.

@ref{it_magicwand} and lasers reverse its direction. An @ref{st_actorimpulse}
reverts the direction if the boulder hits it frontally. An @ref{st_rotator}
changes its direction according to the rotator's direction. An 
@ref{st_stoneimpulse} pushes a boulder away.

@table @asis
@item @b{Attributes:}

@table @asis
@atindex orientation
@item @b{orientation}, @ @ @i{values}: @code{NORTH}, @code{EAST}, @code{SOUTH}, @code{WEST}; @ @ @i{default}: @code{NORTH}
The orientation of the boulder that is shown by its arrow. It determines the
direction that the boulder will take on its next move.
@item @b{counterclockwise} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
The standard turning direction is clockwise. Use this attribute to revert the
direction.
@end table

@item @b{Messages:}

@table @asis
@msindex orientate
@item @b{orientate}, @ @ @i{value type}: direction
Change the orientation to the given direction value. The @ref{st_fourswitch}
provides a compatible action which allows you to set a boulder as
target and this message as action.
@item @b{turn}
Turn orientation in turning direction as defined by attribute 
@samp{counterclockwise}.
@item @b{turnback}
Turn orientation in opposite turning direction as defined by attribute 
@samp{counterclockwise}.
@end table

@item @b{Action:}
none

@item @b{Variants:}

@table @asis
@item @b{st_boulder}
@item @b{st_boulder_n}: orientation = @code{NORTH}
@item @b{st_boulder_e}: orientation = @code{EAST}
@item @b{st_boulder_s}: orientation = @code{SOUTH}
@item @b{st_boulder_w}: orientation = @code{WEST}
@end table

@end table

@c ----------------- Chess Stone -------------------- 
@node st_chess
@subsection st_chess
@obindex st_chess

A chess stone is like a chess knight. It exists in the two colors black and
white, it can jump and make a chess knight move. It can even beat stones at
the target position.

A black chess can only be moved with a black marble, a white one with white
marbles. The jump direction is given by the marble hit direction. It moves
two grid steps into the direction, into which other movable stones move just one
grid, plus one grid step vertical. The vertical direction is given by the
marbles vertical velocity component.

When there is a chess stone of opposite color or an @ref{st_thief} at the target
position of a knight move, this stone is captured and destroyed.

When hit with a revealed @ref{it_wand}, a chess stone changes color. 

Chess stones fall into @ref{fl_abyss} and sink in @ref{fl_swamp}, but cross
@ref{fl_water} undamaged. 

A chess stone that jumps onto a @ref{fl_thief} captures and inactivates the 
thief.

Chess stones can't jump over or into fire (see The 1.0-Fire System). At least, 
a chess knight is brave enough not to panic when fire starts to burn beneath. 
Note that fire can't ignite the floor below a chess stone. In this
context it acts like an immovable stone. In the same sense, they don't act on 
stone impulses of @ref{st_stoneimpulse} or @ref{it_puller}. 

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{color} @ @ @i{values}: @code{BLACK}, @code{WHITE}; @ @ @i{default}: @code{BLACK}
The color of the chess stone
@item @b{movable} @ @ @i{values}: @code{true}; @ @ @i{default}: @code{true} @ @ @xref{movable}
Read only attribute that states the movability of a chess stone.
@end table

@item @b{Messages:}

@table @asis
@item @b{flip}
Flip the color of the stone.
@item @b{move}, @ @ @i{value type}: position; @ @ @i{values}: @code{NNE}, @code{NEE}, @code{SEE}, @code{SSE}, @code{SSW}, @code{SWW}, @code{NWW}, @code{NNW}
Jump into the given dirction.
@end table

@item @b{Action:}  none

@item @b{Variants:}

@table @asis
@item @b{st_chess}: color = @code{BLACK}
@item @b{st_chess_black}: color = @code{BLACK}
@item @b{st_chess_white}: color = @code{WHITE}
@end table

@end table

@c ----------------- Coinslot Stone -------------------- 
@node st_coinslot
@subsection st_coinslot
@obindex st_coinslot

A switch that is activated by insertion of an @ref{it_coin}. Just actors
assigned to a player can insert coins out of their item inventory by hitting
the coinslot with the coin being the first item. Depending on the coin type the
coinslot remains in state @samp{ON} for a given @samp{interval} before switching
back to state @samp{OFF}. Multiple inserted coins do prolong the activity 
interval.

Standard not @samp{instant} coinslots do activate after the insertion process
of the coin. No additional coins can be inserted while another coin is being
inserted. This prevents unintended multiple coin insertions. On the other hand
the player has to insert additional coins early enough to prolong the active
state without temporaryly switching back to @samp{OFF} state. If the first
interval runs off while the next coin did not yet finish its insertion the
coinslot will first switch @samp{OFF} and switch @samp{ON} when the next coin
is completly inserted.

Coinslots configured as @samp{instant} do activate immediatly when the actor
hits the stone. On every actor hit a coin is inserted independent of the last
insertion.

The @samp{state} of a coinslot can be requested but it can not be set, neither
by attribute nor by messages.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @i{access}: @code{read only}  @ @ @xref{state}
Current activity state of the coinslot.
@item @b{instant} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
A default coinslot switches to active state after insertion of a coin and allows
the insertion of just one coin at a time.
@item @b{interval_s} @ @ @i{values}: positive number; @ @ @i{default}: @code{3.0}
Number of additional active seconds on insertion of a small @ref{it_coin}.
@item @b{interval_m} @ @ @i{values}: positive number; @ @ @i{default}: @code{6.0}
Number of additional active seconds on insertion of a medium @ref{it_coin}.
@item @b{interval_l} @ @ @i{values}: positive number; @ @ @i{default}: @code{12.0}
Number of additional active seconds on insertion of a large @ref{it_coin}.
@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@item @b{Variants:}

@table @asis
@item @b{st_coinslot}: instant = @code{false}
@item @b{st_coinslot_instant}: instant = @code{true}
@end table

@end table

@c ----------------- Death Stone -------------------- 
@node st_death
@subsection st_death
@obindex st_death

Shatters any marble that hits or even just touches it. Just marbles protected
by an activated @ref{it_umbrella} will bounce unharmed as other actors do which
will not die anyway.

Death stones can be configured by the @samp{invisible} attribute to
be hidden while being idle. When hit by an actor any death stone becomes
temporary visible. An actor with unbroken standard @ref{it_glasses} in its
inventory will be able to spot invisible death stones.

The level author can configure @ref{it_glasses} by elimination of 
@samp{SPOT_DEATH} not to show invisible death stones. With the global attribute
@ref{ExtralifeGlasses} even glasses generated by laser lighting an 
@ref{it_extralife} can be configured not to show invisible actorimpulse stones.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @i{access}: @code{read only}  @ @ @xref{state}
Current activity state of the death stone. A stone is usually activated by
a hitting actor.
@item @b{invisible} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
Invisible death stones show only when hit by an actor or been toggled by a message.

@item @b{Messages:}
@table @asis
@item @b{toggle} @ @ @xref{toggle}
Temporarily activy the stone to show its animation and to get visible for this
period.
@end table

@item @b{Action:} none

@item @b{Variants:}

@table @asis
@item @b{st_death}: invisible = @code{false}
@item @b{st_death_invisible}: invisible = @code{true}
@end table

@end table


@c ----------------- Floppy Stone -------------------- 
@node st_floppy
@subsection st_floppy
@obindex st_floppy

A switch that is activated by insertion of an @ref{it_floppy}. Just actors
assigned to a player can insert a floppy out of their item inventory by hitting
the floppy switch with a floppy being the first item. 

On a second hit the switch is deactivated and the inserted floppy is returned
to the players inventory.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}: @ @ @xref{state}
Current activity state of the floppy stone.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}, and off at values @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Fourswitch Stone -------------------- 
@node st_fourswitch
@subsection st_fourswitch
@obindex st_fourswitch

A switch that points to one of the four directions turning on every switching
event. The most common event is an actor hitting this stone. But @ref{st_boulder}
will trigger this switch, too. Of course other objects can send messages on
actions to make this switch turning.

When turning its pointer on a switching event it performs the action given by
the @samp{action/target}-pair. This can be either a common pair or a 
state/direction dependent pair allowing you to issue different messages
dependent on the pointing direction.

@table @asis
@item @b{Attributes:}

@table @asis
@atindex state
@item @b{state}, @ @ @i{values}: @code{NORTH}, @code{EAST}, @code{SOUTH}, @code{WEST}; @ @ @i{default}: @code{NORTH} @ @ @xref{state}
@item @b{counterclockwise} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
The standard turning direction is clockwise. Use this attribute to revert the
direction.
@item @b{inverse} @ @ @xref{inverse}
Note that the action value is inverted in its boolean interpretation. This means
that an inverted action value is @emph{not} the reverse direction and should not
be used as a direction value at all.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Note that the fourswitch reacts just on value @code{1}. Values of @code{0} are
simply ignored. Use message toggle if you need turns on any message value.
@item @b{toggle} @ @ @xref{toggle}
Note that a toggle turns the fourswitch independent of a message value.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}
Performs an action on each turn. If just a pair of global @samp{target/action}
attributes are given, the action message is sent to the target with a 
direction value of the new orientation. This value suits any message of the
target that expects a direction value, and the @ref{signal} message, that 
translates the direction to a 1 for @samp{NORTH}, @samp{SOUTH} and a 0 for 
@samp{EAST}, @samp{WEST}.

If state dependent target/action pairs are given instead, namely
@samp{target_0/action_0} for the state @samp{WEST},... , @samp{target_3/action_3} 
for the state @samp{NORTH}, two actions will be perfomed: first for the state 
representing the old orientation the given action messages will be sent with
a value of 0, then for the state representing the new orientation the given
action messages will be sent with a value of 1. This allows you to switch on
and off alternative sources by a fourswitch.
@end table

@c ----------------- Key Stone -------------------- 
@node st_key
@subsection st_key
@obindex st_key

A switch that is activated by insertion of an @ref{it_key}. Just actors
assigned to a player can insert a key out of their item inventory by hitting
the key switch with a key being the first item. Just keys with a matching
@samp{code} are accepted.

On a second hit the switch is deactivated and the inserted key is returned
to the player's inventory.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @ @ @xref{state}
Current activity state of the key stone.
@item @b{code}, @ @ @i{values}: number; @ @ @i{default}: @code{1}:
The code that is required to activate this switch.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}, and off at values @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table
@c ----------------- Laser Stone -------------------- 
@node st_laser
@subsection st_laser
@obindex st_laser

The laser stone is the only object that is capable of emitting light beams.
Per default laser stones are switched off. The @samp{state} attribute represents
the activity of the laser and can be set initially to @samp{ON}. A laser is
orientated to one direction in which the light will be emitted.

Lasers have a latency that protect them from infinite fast switching cycles. This
allows you to toggle a laser with an @ref{st_laserswitch} that is illuminated
by the laser itself. During the latency period pending switch requests will be
registered but will be executed with a certain small delay. Note that several
pending requests may even neutralize are revoke each other.

An initially switched on laser will not cause actions with its light beam due
to the @ref{Snapshot Principle}. If you have need of the actions you may switch
on the laser by a message in the @samp{postinit} function 
(@xref{Level Initialization}). E.g. a flickering laser caused by a laser that
illuminates a @ref{st_laserswitch} which toggles the laser needs to be switched
on by a message.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
@item @b{orientation}, @ @ @i{values}: @code{NORTH}, @code{EAST}, @code{SOUTH}, @code{WEST}; @ @ @i{default}: @code{NORTH}
The orientation of the laser. It determines the direction that the laser will
emit light if it is switched on.
@item @b{counterclockwise} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
The standard turning direction is clockwise. Use this attribute to revert the
direction.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switch the laser on at value @samp{1} and off at value @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@item @b{turn}
Turn orientation in turning direction as defined by attribute 
@samp{counterclockwise}.
@item @b{turnback}
Turn orientation in opposite turning direction as defined by attribute 
@samp{counterclockwise}.
@end table

@item @b{Action:} none

@item @b{Variants:}

@table @asis
@item @b{st_laser}
@item @b{st_laser_w}: orientation = @code{WEST}
@item @b{st_laser_s}: orientation = @code{SOUTH}
@item @b{st_laser_e}: orientation = @code{EAST}
@item @b{st_laser_n}: orientation = @code{NORTH}
@end table

@end table

@c ----------------- Laserflop Stone -------------------- 
@node st_laserflop
@subsection st_laserflop
@obindex st_laserflop

A switch that is triggered by actor hits and laser light. It switches instantly 
to state @samp{ON} and when it is no longer illuminated it switches back to
state @samp{OFF} after a given @samp{interval}. Repeatitive actor hits and 
continuing laser light will prolong the @samp{ON} state untill a trailing 
@samp{interval} after the last hit has been expired. A similar object without
light sensitiveness is the @ref{st_monoflop}.

The single state cycle, called monoflop, can be initiated by @samp{on} and
@samp{signal} messages. But an activated monoflop cannot be stopped by
messages or state setting.

At initialization a laserflop that is exposed to laser light will start in state
@samp{ON} without sending actions due to the @ref{Snapshot Principle}.

A laserflop that is moved or swapped in or out of a laser beam will act on
the light change with proper actions.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @ @ @xref{state}
Represents the activity state. The state of a new object can be set, but an
active laserflop cannot be set to state @samp{OFF}.
@item @b{interval} @ @ @i{values}: positive number; @ @ @i{default}: @code{1.8}
Number of seconds to return to state @samp{OFF} after the last hit.

@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}. A value of @samp{0} is ignored.
@item @b{on} @ @ @xref{on}
Switches the laserflop on like on an actor hit.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Laserswitch Stone -------------------- 
@node st_laserswitch
@subsection st_laserswitch
@obindex st_laserswitch

A switch that is exclusively triggered by laser light. It switches instantly to
state @samp{ON} when a laser beam hits the stone from any direction. It switches
instantly back to state @samp{OFF} when it is no longer illuminated.

There is no way to set the state of this stone manually. But the state
can nevertheless be read. At initialization a laserswitch that is exposed to
laser light will start in state @samp{ON} without sending actions due to the
@ref{Snapshot Principle}.

A laserswitch that is moved or swapped in or out of a laser beam will act on
the light change with proper actions.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @i{access}: @code{read only} @ @ @xref{state}

@end table

@item @b{Messages:} none

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Lightpassenger Stone -------------------- 

@node st_lightpassenger
@subsection st_lightpassenger
@obindex st_lightpassenger

The light passenger skates on a laser beam, and may push up to one
movable stone in front of it. Opposing laser beams are ignored.
When another laser beam crosses the actual laser beam on which the
passenger skates, the passenger switches beams. If it is initially
lighted by two rectangular beams, one of them will be chosen by
random. The light passenger's skating ability can be turned off
and on.

When a stone is in its way, the passenger sends an impulse to the
blocking stone, which may move it, but it may also have other effects;
e.g., a turnstile turns around and an impulse-stone starts pulsing,
but it does not open oxyds (this is intended).

The light passenger can't be pushed by actors, but, e.g., by
@ref{st_stoneimpulse}.

The speed of the light passenger can be changed with the
@samp{interval}-attribute (default 50 ms, which is quite fast) and may
include the floor friction and local gradient via
@samp{friction} and @samp{gradient}. The resulting interval results as

@example
interval  =  base * (1 + stone_friction * floor_friction) / (1 + stone_gradient * floor_gradient)
@end example

with @samp{base} the value of the @samp{interval}-attribute,
@samp{floor_friction} the friction of the floor below the light passenger,
and @floor{floor_gradient} the parallel part of the force of the floor,
i.e., the sum of gradient-force and @code{force_x/y}-attributes.

The light passenger can be switched on and off by messages (see below), and 
appears as @samp{st_glass2} when inactive. A player with an @ref{it_glasses}
in his inventory that includes the @samp{SPOT_LIGHTPASSENGER} feature is able
to distinguish the switched off lightpassenger from an @samp{st_glass2}.
The variant @samp{st_lightpassenger_off} is deactivated from the beginning.
A lightpassenger that moves onto an @ref{it_cross} switches off immediatly. A
switchted off lightpassenger can be switched on by an actor hit with a revealed
@ref{it_brush} in the inventory. Such a touch with a brush does wipe out a
cross beneath the lightpassenger, too.

An @ref{st_boulder} hitting a lightpassenger toggles the lightpassenger's state
for a short period.

When an active @samp{st_lightpassenger} is trapped between exactly two
opposing light beams or light beams from all four directions, it
starts blinking.  In this state, it can be destroyed with
@ref{it_hammer}.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{ON}; @ @ @xref{state}
Represents the activity state.
@item @b{interval} @ @ @i{values}: positive number; @ @ @i{default}: @code{0.05}
The base interval for movements.
@item @b{friction} @ @ @i{values}: positive number; @ @ @i{default}: @code{0.0}
Stone friction of the speed of the light passenger.
@item @b{gradient} @ @ @i{values}: positive number; @ @ @i{default}: @code{0.0}
Stone gradient of the speed of the light passenger.

@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}. A values of @samp{0} is ignored.
@item @b{on} @ @ @xref{on}
Switch the lightpassenger on.
@item @b{off} @ @ @xref{off}
Switch the lightpassenger off.
@end table

@item @b{Variants:}

@table @asis
@item @b{st_lightpassenger}: state = @code{ON}
@item @b{st_lightpassenger_on}: state = @code{ON}
@item @b{st_lightpassenger_off}: state = @code{OFF}
@end table

@end table

@c ----------------- Mirror Stone -------------------- 
@node st_mirror
@subsection st_mirror
@obindex st_mirror

Mirror stones redirect and fork laser beams. They exist in different shapes.
You can set the shape by the attribute @samp{flavor} or by using the 
appropriate subkind. There are two planar versions called @samp{slab} and 
@samp{sheets}, and a @samp{triangle} version.

The mirror panes can either be non-transparent or semi-transparent. Even though
you set this feature with the attribute @samp{transparent} you should be aware
that even with a value of @samp{true} the mirror is not fully transparent. E.g.
a @samp{slab} mirror will block any laser light that is parallel to its shape
as the short ends are no mirrors at all. For this reason we provide the second
planar version called @samp{sheets}, which lets light parallel to its sheets
pass.

Mirrors hit by an actor or impulsed by an @ref{st_stoneimpulse} will move if
their attribute @samp{movable} is set to true. Mirrors that are not movable
will differ slightly in a darker color.

Mirros hit or just touched will turn their mirror panes by 90 degrees. The 
standard turning direction is clockwise. But this standard can be changed with
by the attribute @samp{counterclockwise}. An @ref{st_boulder} hitting a mirror
will turn it in its standard direction, too.

A mirror can be turned into the opposite direction either by a message 
@samp{turnback} or by an actor with a revealed @ref{it_wrench} in its 
inventory.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{flavor} @ @ @i{values}: @code{"slab"}, @code{"sheets"}, @code{"triangle"}; @ @ @i{default}: @code{"slab"}
Mirror panes either set up as an triangle or as a side intransparent slab or
as a mandatory semi-transparent pair of sheets.
@item @b{state}, @ @ @i{values}: @code{NORTH}, @code{EAST}, @code{SOUTH}, @code{WEST}; @ @ @i{default}: @code{NORTH}; @ @ @xref{state}
The orientation of the mirror. For a triangle mirror it is the triangles 
pointing direction. For a planar mirror it the reflection direction of an 
incoming northbound beam.
@item @b{orientation}, @ @ @i{values}: @code{NORTH}, @code{EAST}, @code{SOUTH}, @code{WEST}; @ @ @i{default}: @code{NORTH}
The orientation of the mirror. For a triangle mirror it is the triangles 
pointing direction. For a planar mirror it the reflection direction of an 
incoing northbound beam.
@item @b{transparent} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
Semitransparency of the mirror panes.
@item @b{movable} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false} @ @ @xref{movable}
Movability on actor hits and stone impulses.
@item @b{counterclockwise} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
The standard turning direction is clockwise. Use this attribute to revert the
direction.
@end table

@item @b{Messages:}

@table @asis
@msindex orientate
@item @b{orientate}, @ @ @i{value type}: direction
Change the orientation to the given direction value. The @ref{st_fourswitch}
provides a compatible action which allows you to set a boulder as
target and this message as action.
@item @b{turn}
Turn the orientation in turning direction as defined by attribute 
@samp{counterclockwise}.
@item @b{turnback}
Turn the orientation in opposite turning direction as defined by attribute 
@samp{counterclockwise}.
@item @b{signal} @ @ @xref{signal}
Turn the orientation in turning direction as defined by attribute 
@samp{counterclockwise} on at value @samp{1}. A values of @samp{0} is ignored.

@end table

@item @b{Action:} none

@table @asis
@item @b{st_mirror}: flavor=@code{slab}, state = @code{NORTH}
@item @b{st_mirror_slab}: flavor=@code{slab}, state = @code{NORTH}
@item @b{st_mirror_sheets}: flavor=@code{sheets}, state = @code{NORTH}
@item @b{st_mirror_triangle}: flavor=@code{triangle}, state = @code{NORTH}
@end table

@end table

@c ----------------- Monoflop Stone -------------------- 
@node st_monoflop
@subsection st_monoflop
@obindex st_monoflop

A switch that is triggered by actor hits. It switches instantly to
state @samp{ON} and after a given @samp{interval} back to state @samp{OFF}.
Repetitive actor hits will prolong the @samp{ON} state until a trailing 
@samp{interval} after the last hit has been expired. A switch similar to
the monoflop is the @ref{st_laserflop}, which is additionally light sensitive.

The single state cycle, called monoflop, can be initiated by @samp{on} and
@samp{signal} messages. But an activated monoflop cannot be stopped by
messages or state setting.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF}; @ @ @xref{state}
Represents the activity state. The state of a new object can be set, but an
active monoflop cannot be set to state @samp{OFF}.
@item @b{interval} @ @ @i{values}: positive number; @ @ @i{default}: @code{1.8}
Number of seconds to return to state @samp{OFF} after the last hit.

@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}. A values of @samp{0} is ignored.
@item @b{on} @ @ @xref{on}
Switch the monoflop on like on an actor hit.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Oxyd Stone -------------------- 
@node st_oxyd
@subsection st_oxyd
@obindex st_oxyd

The main target stones of the game. Opening all regular oxyd stones is the
standard goal of the existing @ref{Ending Conditions}. Regular oxyds stones show
a color spot when opening. Pairs of same colored stones have to be opened in
sequence, otherwise the first one closes again.

Even though most levels make use of just a single pair of each color, there
is no limit on a single color. If you like you can define 3 pairs of blue oxyds
together with 2 yellow pairs. You do this by setting explicit @samp{oxydcolor}
attributes to the oxyds.

For standard levels the @samp{oxydcolor} can be set to its default @samp{OXYD_AUTO}.
This causes an automatic coloring by pairs of colors in the standard color
sequence.

There is no limit on the number of used oxyd pairs. There exist 12 different
regular colors for oxyds. But per default just the first 8 colors will be
assigned to @samp{OXYD_AUTO} colored oxyds. The colors will repeat from the
9th pair giving the user the possibility to build arbitrary couples within a
single color. With the world attribute @ref{MaxOxydColor} you can lower or
increase this limit. By setting this attribute to @samp{OXYD_GREEN} you can
enforce the engine to assign just the first three colors. Be careful in usage
of more than 8 colors as levels can get incredibly difficult. Uneven number of
regular colored oxyds are not allowed.

Usually oxyds are shuffled by a @samp{wo:shuffleOxyd()} statement after setting
of all oxyds. All @samp{CLOSED} oxyds that are not explicitly excluded by the
@samp{noshuffle} attribute take place in shuffling. But you can define
arbitrary rules to limit and influence the shuffling process to guarantee
solvabitlity and fairness (@pxref{shuffleOxyd}).

Oxyds are opened either by an actor hit, an additional laser beam, an
@ref{st_boulder} triggering or a message call. A single opened oxyd is in the
state @samp{OPEN}. If a matching second oxyd is opened both switch to the state
@samp{OXYDPAIR}. Note that this state can be requested, but it can not be set
directly.

Single opened oxyds close on a not matching partner oxyd being opened and on 
@samp{close} messages and state setting operations. But oxyds being part of
an opened pair will not be closed this way.

All oxyds including pairs will close on the @samp{closeall} messages that is
issued by @ref{st_fart} and oxyds colored @samp{OXYD_FART} on actor hits.

Closed oxyds can have different looks. Their visual representation is defined
by their @samp{flavor}. For each flavor exists an identical looking simple
stone: @ref{st_likeoxyd_a}, @ref{st_likeoxyd_b}, @ref{st_likeoxyd_c},
@ref{st_likeoxyd_d}. If you like an identical looking pseudo stone that takes
part in the oxyd shuffling you can use an oxyd of color @samp{OXYD_FAKE}.

During the game oxyds can be reshuffled. Just those oxyds that are still closed
will take part in the new shuffle process. Oxyd shuffling rules will still be
guranteed for these partial in game reshuffles. It can be initiated either
by a @samp{shuffle} message that is send to any of the oxyd objects, or by
usage of an oxyd of color @samp{OXYD_BOLD}. If such a special oxyd is opened,
e.g. by an actor hit, it shuffles all remaining oxyds including itself.

At initialization an oxyd that is exposed to laser light will start in state
@samp{CLOSED}. As it is the gaming target it is a certain exception to the
@ref{Snapshot Principle}.

An oxyd that is swapped in or out of a laser beam will act on the light change
with proper actions.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{CLOSED}, @code{OPEN}, @code{OXYDPAIR}; @ @ @i{default}: @code{CLOSED} @ @ @xref{state}

@item @b{flavor}, @ @ @i{values}: @code{"a"}, @code{"b"}, @code{"c"}, @code{"d"}; @ @ @i{default}: @code{"b"}
The flavor only affects the visual representation of the stone. Mainly the 
closed state and the way of opening differ in the following way:
@table @asis
@item @code{"a"} bronze, pyramid like stone that opens like a flower
@item @code{"b"} black, flat stone that opens by a fade animation
@item @code{"c"} blue, flat stone that opens by a concentric animation
@item @code{"d"} dark blue, pyramid like stone that opens like a flower
@end table
@item @b{oxydcolor}, @ @ @i{values}: @code{OXYD_AUTO}, @code{OXYD_FAKE}, @code{OXYD_FART}, @code{OXYD_BOLD}, @code{OXYD_BLUE}, @code{OXYD_RED}, @code{OXYD_GREEN}, @code{OXYD_YELLOW}, @code{OXYD_CYAN}, @code{OXYD_PURPLE}, @code{OXYD_WHITE}, @code{OXYD_BLACK}, @code{OXYD_GREY}, @code{OXYD_ORANGE}, @code{OXYD_PINE}, @code{OXYD_BROWN}; @ @ @i{default}: @code{OXYD_AUTO}
@item @b{noshuffle} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
@item @b{static} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
Static oxyds are neither swappable nor pullable.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Try open at value @samp{1}, and close at values @samp{0}.
@item @b{open} @ @ @xref{open}
@item @b{close} @ @ @xref{close}
@item @b{closeall}
Closes all opened oxyds if send to any object instance.
@item @b{shuffle}
Reshuffles all closed oxyds if send to any object instance.
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}
Values 0, 1.

@item @b{Variants:}

@table @asis
@item @b{st_oxyd}: flavor = @code{"b"}
@item @b{st_oxyd_a}: flavor = @code{"a"}
@item @b{st_oxyd_b}: flavor = @code{"b"}
@item @b{st_oxyd_c}: flavor = @code{"c"}
@item @b{st_oxyd_d}: flavor = @code{"d"}
@end table

@end table

@c ----------------- Polarswitch Stone -------------------- 
@node st_polarswitch
@subsection st_polarswitch
@obindex st_polarswitch

A special on/off switch that toggles its state on actors hitting the stone.
Of course other objects can send messages on actions to make this switch turning.

The main purpose of this switch is its ability to switch crossing laser beams.
While the switch is not transparent in its default off state, it switches to
a transparent on state.

The switch looks like an @ref{st_glass2} in its intransparent off state and like
an @ref{st_glass1} in its transparent on state. Like other @ref{Glasstones} it
is passable for invisible actors.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
An @samp{OFF} state is not transparent, an @samp{ON} state is transparent. 
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}, and off at values @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@end table

@c ----------------- Rotator Stone -------------------- 
@node st_rotator
@subsection st_rotator
@obindex st_rotator

Rotators send impulses to neighboring stones, thus pushing them in the direction
given by the rotation. @ref{st_boulder} additionally change their direction to
the one they are pushed to.

Rotators can either rotate in clockwise or counterclockwise direction. They can
be movable or unmovable.

The rotator changes its rotation direction when hit by an actor with a revealed
@ref{it_wrench} and by laser beams. Every additional laser beam causes a change
in the rotation direction.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{CW}, @code{CCW}; @ @ @i{default}: @code{CW} @ @ @xref{state}
The rotation direction - @samp{CW} for clockwise as default, or @samp{CCW} for
counter clockwise. 
@item @b{counterclockwise} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
The standard rotation direction is clockwise. Use this attribute to revert the
direction.
@item @b{movable} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false} @ @ @xref{movable}
@end table

@item @b{Messages:}

@table @asis
@item @b{toggle} @ @ @xref{toggle}
Switches the rotation direction.
@end table

@item @b{Variants:}

@table @asis
@item @b{st_rotator}: state = @code{CW}
@item @b{st_rotator_cw}: state = @code{CW}
@item @b{st_rotator_ccw}: state = @code{CCW}
@end table


@end table

@c ----------------- Switch Stone -------------------- 
@node st_switch
@subsection st_switch
@obindex st_switch

A classical on/off switch that toggles its state on actors hitting the stone.
Of course other objects can send messages on actions to make this switch turning.

Three variants of the switch do exist. A neutral, gray colored one that reacts
on any actor hits, and a black and a white colored switch. These last switches
will react only if hit by marbles of matching color.

If a switch turns on or off there will be a short delay until it reaches the
new state and performs it actions. If you need a switch without delay you
need to set the @samp{instant} attribute.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
@item @b{color} @ @ @i{values}: @code{nil}, @code{BLACK}, @code{WHITE}; @ @ @i{default}: @code{nil}
The color of the switch that needs to match the hitting actor to cause a toggle.
The default @samp{nil} color is a grey switch that matches all actors, marbles
of any color as well as all other actors.
@item @b{instant} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
A default switch requires a short time equivalent to the animation until the
new state is reached and the actions are performed. An instant switch jumps
directly into the new state.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}, and off at values @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}

@item @b{Variants:}

@table @asis
@item @b{st_switch}
@item @b{st_switch_black}: color = @code{BLACK}
@item @b{st_switch_white}: color = @code{WHITE}
@end table

@end table

@c ----------------- Timer Stone -------------------- 
@node st_timer
@subsection st_timer
@obindex st_timer

This stone can be used to trigger a delayed single or periodic events. An
active, switched on timer is usually visualized by an animation. An inactive,
switched off timer shows a static image.

Note that this is an exceptional object as its default state is @samp{ON} to
support the most common case of immediatly runnning timers.

A single shot, not looping timer will send an action value of @samp{true}. A
looping timer will alternate the boolean action values starting with value 
@samp{true}. You can use @ref{inverse} to start with a value of @samp{false}.

If you stop a timer by switching it off, no further events will be performed.
Restarting the timer by switching it on again will restart the timer like
a new timer.

The time interval to the first event and between subsequent events can be relied
on to an accuracy of 0.01 seconds. But due to performance reasons and visibility
of the reactions timers should not be set to intervals below 0.1 seconds. An
interval of less than 0.01 seconds is not valid for a looping timer.

@table @asis
@item @b{Attributes:}

@table @asis
@item @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{ON} @ @ @xref{state}
An @samp{ON} state timer is running. A timer in state @samp{OFF} is reset and
waiting for reactivation.
@item @b{invisible} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
An invisible timer is totally transparent. But the user may notice it, as actors
cannot pass and other stones cannot be moved onto the same grid position.
@item @b{interval} @ @ @i{values}: positive number; @ @ @i{default}: @code{1.0}
Number of seconds until the first and between subsequent events. The interval
must be larger or equal 0.01 seconds for looping timers.
@item @b{loop} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{true}
A looping timer will send periodic events.
@end table

@item @b{Messages:}

@table @asis
@item @b{signal} @ @ @xref{signal}
Switches on at value @samp{1}, and off at values @samp{0}.
@item @b{on} @ @ @xref{on}
@item @b{off} @ @ @xref{off}
@end table

@item @b{Action:} @ @ @xref{target}, @ @ @xref{action}
The action value starts with @samp{true} and alternates on every event between
@samp{false} and @samp{true}. A timer that is reset starts again with value 
@samp{true}
@end table


@c ----------------- Window Stone -------------------- 
@node st_window
@subsection st_window
@obindex st_window

A stone made up just of glass window faces. All combinations of window faces with
at least one face are possible. There exist two versions of windows, normal
blue colored glass and green colored safety glass, that is nearly undistructable.
Safety glass is seleted by setting the attribute @samp{secure} to @samp{true}.
Every glass face can be weakened by @samp{scratches} which are visible in the
shadows.

All windows are transparent to laser light.

Slowly moving actors will bounce from window faces on any side. They can freely
move within the inner part of the window stone. Invisible actors can even pass
the normal blue window faces, but not the green safety glass faces.

Fast moving actors can blast normal blue window faces into smithereens. But too
strong hits will cause marbles to shatter themselves. An actor can lower the
required speed by adding @ref{it_weight}, by revealing an @ref{it_hammer}, or by
weakening the window faces by prior scratching it with an @ref{it_ring}. Green
safty glass windows will never break on actor attacks.

Bomb explosions can shatter window faces, too. Normal blue window faces adjacent
to a bomb explosion will break. Green safety glass faces will break only if 
prior weakened by an @ref{it_ring} scratch.

Window faces can be rearranged by actors with a revealed @ref{it_wrench}.
Pushing a face from the outside may move it to the opposite side of the window.
But it will only move to the opposite side if there is not already a window face.
And additionally the grid position adjacent to the opposite side must be free
of a stone. Just another window stone without an adjacent window face is allowed
on this position. The reason is, that the moving window face will push
non static items and any actors positioned on the affected window grid to the
next grid. If this grid is already occupied by an item, the window grid item
will be @ref{it_squashed}.

Window face rearrangements can also be initiated by an @ref{it_puller} dropped 
within the window and by the message @samp{inner_pull}.


@table @asis
@item @b{Attributes:}

@table @asis
@item @b{faces} @ @ @i{values}: string; @ @ @i{default}: @code{"s"}
Describes the window faces of the stone. The string is a substring of 
@code{"nesw"} listing the faces. The sequence of the sides, north, east, south,
west, is guaranteed on read access but arbitrary on write access.
@item @b{secure} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
Green safety glass is secure, whereas normal blue is not.
@item @b{scatches} @ @ @i{values}: string; @ @ @i{default}: @code{""}
Describes the scratched window faces of the stone. The string is a substring of 
@code{"nesw"} listing the affected faces. The sequence of the sides, north, east,
south, west, is guaranteed on read access but arbitrary on write access.
@end table

@item @b{Messages:}

@table @asis
@item @b{inner_pull}, @ @ @i{value type}: direction
Tries to tear the opposite window face into the given direction.
@end table

@item @b{Variants:}
@table @asis
@item @b{st_window}: faces = @code{"s"}
@item @b{st_window_w}: faces = @code{"w"}
@item @b{st_window_s}: faces = @code{"s"}
@item @b{st_window_sw}: faces = @code{"sw"}
@item @b{st_window_e}: faces = @code{"e"}
@item @b{st_window_ew}: faces = @code{"ew"}
@item @b{st_window_es}: faces = @code{"es"}
@item @b{st_window_esw}: faces = @code{"esw"}
@item @b{st_window_n}: faces = @code{"n"}
@item @b{st_window_nw}: faces = @code{"nw"}
@item @b{st_window_ns}: faces = @code{"ns"}
@item @b{st_window_nsw}: faces = @code{"nsw"}
@item @b{st_window_ne}: faces = @code{"ne"}
@item @b{st_window_new}: faces = @code{"new"}
@item @b{st_window_nes}: faces = @code{"nes"}
@item @b{st_window_nesw}: faces = @code{"nesw"}

@end table

@end table


@c ===================  Actors  =======================

@node Actor Objects
@chapter Actor Objects

@c ===================  Other Objects  =======================

@node Other Objects
@chapter Other Objects

@c ===================  Advanced Features  =======================

@node Advanced Features
@chapter Advanced Features

@menu 
* World Advanced Methods::  Additional features provided by the world
* Resolvers::               Standard tools for interpretation of tile maps
* General Features::        Special features by various objects
* Tips and Tricks::         Simple patterns that are valuable like a feature
@end menu

@node World Advanced Methods
@section World Advanced Methods

@menu 
* drawBorder::   
* drawMap::      
* drawRect::     
* shuffleOxyd::  Oxyd Shuffling Rules
@end menu

@c ----------------- drawBorder -------------------- 
@node drawBorder
@subsection drawBorder

Draw a border around a rectangle out of given tiles.

@table @asis
@item @b{Syntax:}
@b{wo:drawBorder}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})

@b{wo:drawBorder}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})

@table @asis
@item @i{upperleft_edge}
Upper left anchor position of the rectangle. 
@item @i{lowerright_edge}
Lower right end position of the rectangle. 
@item @i{width}
Width of the rectangle. 
@item @i{height}
Height of the rectangle. 
@end table

@item @b{Syntax Samples:}
@example
wo:drawBorder(po(0, 0), wo["Width"], wo["Height"], ti["#"])
wo:drawBorder(no["myRectUL"], no["myRectLR"], @{"st_grate1"@})
@end example

@item @b{Details:}



@item @b{Full Example:}
@example
@end example
@end table

@c ----------------- drawMap -------------------- 
@node drawMap
@subsection drawMap

Even if the world is initialized by a map on creation of the world 
(@pxref{World Creation and Resolver Chaining}), it is sometime useful to 
be able to draw smaller submaps either as part of the initialization or as
dynamic level changes within @ref{Callback Function}. Of course the main purpose
of @samp{drawMap} is the drawing of repeating patterns.

@table @asis
@item @b{Syntax:}

@b{wo:drawMap}(@i{resolver}, @i{anchor}, @i{ignore}, @i{map})

@table @asis
@item @i{subresolver}
Resolver to which unresolved requests should be forwarded. May be @samp{ti}
as the final resolver of the resolver chain.
@item @i{anchor}
The anchor position where the upper left tile of the map should be drawn.
@item @i{ignore}
A tile key string that should be ignored. This key string is mandatory, even
if it not used within the map.
@item @i{map}
A table of strings. Each string describes a row of tiles by its tile keys.
@end table

@item @b{Syntax Samples:}
@example
wo:drawMap(ti, po(5, 7), "-", @{"abcabc"@})
wo:drawMap(ti, anchor_object, "--", @{"--##--##","##--##"@})
@end example

@item @b{Details:}
The syntax is similar to the world creation call. But there are two essential
difference you need to be aware of. First the map is drawn in the already
existing world. Thus we need to define the position. This is done via the
anchor position, which can be an already existing object, too.

The second difference is in the definition of a tile key string for tiles in 
the map that should be ignored. Remember that the world initialization requested
a default tile key string. This default is still valid. But with the given 
ignore key string we can draw arbitrary shaped patterns by filling unused
grids in the map with this key.

The length of the ignore key defines the map key length. It is strongly
recommended to use the same key length as in the world map.

The rows of the supplied map are drawn from the anchor position. The rows may
be of different length and may start with ignore tile keys. The anchor must be
the position composed of the smallest x and smallest y coordinate within the
pattern.

You can use drawMap anywhere after the world creation. You are even allowed to
use it within the world creation in a resolver.

@item @b{Full Example:}
@example
ti[" "] = @{"fl-plank"@}
ti["X"] = @{"st_oxyd"@}
ti["B"] = @{"st-black3"@}
ti["W"] = @{"st-white3"@}
ti["y"] = @{"it-yinyang"@}
ti["1"] = ti["y"] .. @{"#ac-blackball"@}
ti["2"] = ti["y"] .. @{"#ac-whiteball"@}

function myresolver(key, x, y)
    if key == "w" then
        wo:drawMap(ti, po(x-1, y-1), "-", @{"-W-",
                                           "WXW",
                                           "-W-"@})
        return ti(@{@})
    elseif key == "b" then
        wo:drawMap(ti, po(x-1, y-1), "-", @{"-B",
                                           "BXB",
                                           "-B"@})
        return ti(@{@})
    else
        return ti[key]
    end
end

w, h = wo(myresolver, " ", @{
"                    ",
"  b         b       ",
"       w       w    ",
"                    ",
"                    ",
"   w                ",
"         12      b  ",
"              w     ",
"         w          ",
"      b             ",
"   w           b    ",
"         b          ",
"                    "
@})
wo:shuffleOxyd()
@end example
@end table

@c ----------------- drawRect -------------------- 
@node drawRect
@subsection drawRect

@table @asis
@item @b{Syntax:}
@b{wo:drawRect}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})

@b{wo:drawRect}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})

@table @asis
@item @i{upperleft_edge}
Upper left anchor position of the rectangle. 
@item @i{lowerright_edge}
Lower right end position of the rectangle. 
@item @i{width}
Width of the rectangle. 
@item @i{height}
Height of the rectangle. 
@end table

@item @b{Syntax Samples:}
@example
wo:drawRect(po(0, 0), wo["Width"], wo["Height"], ti[" "])
wo:drawRect(no["myRectUL"], no["myRectLR"], @{"fl_water"@})
@end example

@item @b{Details:}
@item @b{Full Example:}
@example
@end example
@end table


@c ----------------- shuffleOxyd -------------------- 
@node shuffleOxyd
@subsection shuffleOxyd

Shuffling the color distribution of the @ref{st_oxyd} makes every level, that
is no meditation, a bit generic. On every level start the level looks a little
bit different and the user has to solve a modified level. This provides long
term amusement. Thus the call of this method is part of most levels.

Many levels just call this method without any arguments. This results in a
shuffling of all @ref{st_oxyd} that are not exclude by an @samp{noshuffle}
attribute.

But sometimes levels need to influence the shuffling, either for ensuring that
the level remains solvable, or simply to ensure fairness. Imagine a level that
has two @ref{st_oxyd}s in every corner. If by chance a user gets a distribution
where he has in each corner a pair of same colored oxyds, the level might be
trivial. Another level may have a passage that the marble can pass just a few
times. With 5 or more oxyds on each side of the passage you need to ensure that
the marble never needs to pass the passage more often than possible. Both 
situations can be handled by providing proper rules as arguments to this method.

@table @asis
@item @b{Syntax:}

@b{wo:shuffleOxyd}(@i{rules})

@table @asis
@item @i{rules} = @i{rule}, @i{rule},...
No rule or as many as you like, all seperated by a comma.
@item @i{rule} = @{@i{group1}, @i{group2}, @i{maxrule}, @i{minrule}, @i{circularrule}, @i{linearrule}, @i{log}@}
Each rule is a table with a subset of the listed entries. The @i{group1} entry
is mandatory. All other entries are optional and can be added in any combination.
@item @i{group1} = @i{group} | @i{objectreference} | @i{objectspecifier}
A description of oxyd objects that are part of the first rule group. Either
a group or a single object reference or a string specifier that resolves to a
single or via wildcard to several oxyd objects are legal descriptors.
@item @i{group2} = @i{group} | @i{objectreference} | @i{objectspecifier}
A description of oxyd objects that are part of the second rule group. Either
a group or a single object reference or a string specifier that resolves to a 
single or via wildcard to several oxyd objects are legal descriptors.
@item @i{maxrule} = @code{max = }@i{number}
The maximum number of oxyd pairs.
@item @i{minrule} = @code{min = }@i{number}
The minimum number of oxyd pairs.
@item @i{circularrule} = @code{circular = true}
Avoid any pair of neighboring oxyds in group1. Avoid an oxyd pair of first and
last oxyd in group1, too.
@item @i{linearrule} = @code{linear = true}
Avoid any pair of neighboring oxyds in group1.
@item @i{log} = @code{log = } @ @  @code{"solution"} |@code{"count"} |@code{"all"} 
Log additional information to the log stream for debugging purposes and 
security checks by the level author.
@end table

@item @b{Syntax Samples:}
@example
wo:shuffleOxyd()
wo:shuffleOxyd(@{"borderoxyds#*", circular=true@})
wo:shuffleOxyd(@{"leftoxyds#*","rightoxyds#*", min=3@}, @{"islandoxyds#*", max=0@})
@end example

@item @b{Details:}

Any call of @samp{wo:shuffleOxyd()} must occur after all @ref{st_oxyd} have been
set. That means that it must follow the standard world initialzation 
(@pxref{World Creation and Resolver Chaining}). As a side effect shuffleOxyd 
will assign colors to all @samp{OXYD_AUTO} colored @ref{st_oxyd}. 

Once called the given shuffling rules remain valid. Any further reshuffling
must be done by messages @samp{closeall} and @samp{shuffle} to one arbitrary
@ref{st_oxyd} instance. No addition of an @ref{st_oxyd} or subsequent 
@samp{wo:shuffleOxyd()} calls are possible without disturbing and deleting the
given rules.

Rule based shuffling is limited to a maximum of one pair of each standard oxyd
color plus any combination of additional special fake, fart or bold oxyds 
summing up to a maximum of 32 oxyds. If more than 32 oxyds or 2 or more pairs
of a single standard color are set, all oxyds will be shuffled by random
ignoring any provided rules.

There are basically two different types of rules. Those with one group and those
with two groups of oxyds (Note that group is the general API expression for
a set of oxyds and not a mathematical group). For a single group the rules apply
to the oxyd instances within this group. For two groups the rules apply to oxyd
pairs with one oxyd in the first group and the other in the second group.

E.g. @samp{@{"islandoxyds#*", max=0@}} requests that there is no pair within
this group of oxyds. Whereas @samp{@{"leftoxyds#*","rightoxyds#*", min=3@}} 
requests that there are 3 different oxyd pairs, each with one oxyd out of the
leftoxyd group and the second out of the rightoxyd group.

Linear and circular rules can only be applied to a single group. They are
shortcuts for the most common rules that are applied to oxyds arranged on a
line or a circle. In both cases they avoid pairs of neighboring oxyds. They
are equivalent to @samp{n-1} res. @samp{n} rules with all possible neighboring
oxyds pairs as two groups and a rule of @samp{max=0}.

Note that you can apply several rules at once to given groups. E.g. you can
apply a minrule and a maxrule within one rule!

The shuffling process consists always of two stages. The most important first
stage generates a valid oxyd pair distribution. That means that we settle which
pairs will have the same color. But the color itself is assigned in an
independent second stage. As for the examination of given rules just the pair
distribution is relevant, we do just count and log these different distributions
ignoring the colors.

With 16 oxyds of 8 different colors and no restricting rules you have 2027025
(15 * 13 * 11 * 9 * 7 * 5 * 3) different valid distributions. Keep in mind
that useful rules should always keep hundreds or thousands of different valid
distributions for a level.

For debugging purposes you can add a log parameter to one of the rules (it does
not matter to which one). If you request the log of @samp{solution} the
pair distribution will be printed to the log stream. 

In case of @samp{count} the number of different oxyd distributions will be 
counted and logged. It is recommended to check the count on complex rules to 
ensure that enough distributions remain for a varying game. But be careful 
applying count on trivial rules. With 16 oxyds there may be as many as
... distributions and it may take a standard PC up to 30 seconds to count them!

Be very, very cautious in usage of logging @samp{all}. This call tries to print
all solutions. It takes ages if there are to many solutions. First check the
count before trying to log the solutions.

@item @b{Full Example:}
@example
wo["ConserveLevel"] = false

ti["~"] = @{"fl_water"@}
ti[" "] = @{"fl_plank"@}
ti["c"] = @{"it_crack3", brittleness=0@}
ti["^"] = @{"st_oneway_n"@}
ti["1"] = @{"ac_marble_black", 0, 0.5}

ti["x"] = @{"st_oxyd", "island#"@}
ti["y"] = @{"st_oxyd", "left#"@}
ti["z"] = @{"st_oxyd", "right#"@}

w, h = wo(ti, " ", @{
"~~x  x  x  x  x  x~~",
"~~                ~~",
"~~~~^~~~~~~~~~~^~~~~",
"y       ~~~~       z",
"~       cccc       ~",
"y       ~~~~       z",
"~       cccc       ~",
"y       ~~~~       z",
"~       cccc       ~",
"y       ~~~~       z",
"~~~~c~~~~~~~~~~c~~~~",
"~~                ~~",
"~~        1       ~~"
@})

wo:shuffleOxyd(@{"island#*", min=3, linear=true@}, @{"left#*","right#*", max=2, min=2@})
@end example

This level uses 14 oxyds. The 6 oxyds in the upper row are on an island that
can not be left once the marble entered it through one of the oneways. Thus
we need 3 pairs of oxyds on this island, which are enforced by the min rule.
To avoid trivial neighboring pairs on the island, we do add a linear rule, too.
The marble can pass just three times between the left and right islands. This
allows a first look on the color oxyds with one pass and opening one pair on
each of the two following passes. Thus we limit the number of pairs by a max
rule to 2. To avoid trivial oxyd pair distributions, like two pairs on the left
and two pairs on the right side, we do add a min rule that enforces that two
shared pairs of oxyds do exist.
@end table

@node Resolvers
@section Resolvers

@menu 
* res.autotile::  Generate tiles from given template declarations
* res.composer::  Compose tiles from given base tiles
* res.maze::      Generate arbitrary chaped mazes
* res.random::    Choosing random tiles in a given distribution
@end menu

@c ----------------- Autotile Resolver -------------------- 

@node res.autotile
@subsection res.autotile

Autotiling reduces the number of required tile declarations by generating them
according to given simple rules. The most common application are a bunch of
identical switch like objects that target all target the same type of object
like a door or a laser. As each of them has its individual target object it
would require to write a separate tile declaration with a unique tile key, e.g.

@example
ti["A"] = @{"st_floppy", target="laserA"@} 
ti["B"] = @{"st_floppy", target="laserB"@} 
ti["C"] = @{"st_floppy", target="laserC"@} 
ti["a"] = @{"st_laser", name="laserA"@} 
ti["b"] = @{"st_laser", name="laserB"@} 
ti["c"] = @{"st_laser", name="laserC"@} 
@end example

Autotiling requires just one template tile of each type and substitutes any
pattern @samp{%%} by a unique substitution.

@example
ti["template_switch"] = @{"st_floppy", target="laser%%"@} 
ti["template_laser"]  = @{"st_laser", name="laser%%"@} 
@end example

Independent on the number of required unique objects you have just one template.
You just declare the used ranged of tile keys by a rule and are free to use
them within your level map.

@table @asis
@item @b{Syntax:}

@b{res.autotile}(@i{subresolver}, @i{rules})

@table @asis
@item @i{subresolver}
Resolver to which unresolved requests should be forwarded. May be @samp{ti}
as the final resolver of the resolver chain.
@item @i{rules} = @i{rule}, @i{rule},...
One rule or as many as you like, all seperated by a comma.
@item @i{rule} = @i{prefixrule} | @i{rangerule}
Each rule can be either a prefixrule or a rangerule in any mixture
@item @i{prefixrule} = @{@i{prefix}, @i{template}@}
A table with two entries. First a prefix string that is common to all tile
keys that should be handeled followed by key string of the template tile.
@item @i{rangerule} = @{@i{first}, @i{last}, @i{template}@}
A table with three entries. A string with the first key to be handled, followed
by a string with the last key to be handled. The third value is the key string
of the template tile.
@end table

@item @b{Syntax Samples:}
@example
res.autotile(ti, @{"A", "template_switch"@}, @{"L", "template_laser@})
res.autotile(ti, @{"a", "e", "template_trigger@}, @{"A", "E", "template_door"@}
@end example

@item @b{Details:}
Prefix rules need a key length of at least 2. You can not use it with maps
of just one character per tile. The resolver will create a tile declaration for
any tile key in the map that matches the given prefix. A copy of the template
will be taken and all occurences of the two characters @samp{%%} will be
substituted by a single percent sign followed by the suffix of the used tile
key. Thus a key of @samp{AD} will target the laser @samp{laser%D}. You need to
use the key @samp{LD} in the map for the matching laser.

Rangerules match any tile key in the given range. It can well be used in one
character key maps. But it can be used in multicharacter maps, too. In this case
the given first and last keys may just differ in the last character. Again a
copy of the template rule will be generated and the @samp{%%} patterns will be
substituted. But in this case the substitution is composed of a single percent
sign followed by an integer number that counts the key position within the
given range. Thus a key of @samp{c} will target the door @samp{door%3}. 
You need to use the key @samp{C} in the map for the matching door.

The template tile definitions can well be composed of several concatenated 
tiles even with references of base tiles. The pattern substitution takes place
on any attribute value containing string descriptions. A valid template would
be:
@example
ti["template"] = ti["~"] .. ti(@{"it_trigger", target=@{"door%%#*","laser%%"@}@}) .. @{"st_grate1"@}
@end example

@item @b{Full Example:}
@example
ti[" "] = @{"fl-sahara"@}

ti["template_a"] = @{"st_floppy", target=@{"door%%#*","laser%%"@}@}
ti["template_A"] = @{"st_blocker", "door%%#"@}
ti["template_1"] = @{"st_laser_s", "laser%%"@}

ti["x"] = @{"#ac-blackball"@} .. ti(@{"it_floppy"@})

local resolver = res.autotile(ti, @{"a", "e", "template_a"@}, 
    @{"A", "E", "template_A"@},  @{"1", "5", "template_1"@})

w, h = wo(resolver, " ", @{
"                    ",
"                    ",
"   a   DB  e    BC  ",
"                    ",
"   CD  b   AE   c   ",
"                    ",
"   d   EA           ",
"                    ",
"           x        ",
"                    ",
"                    ",
"   4  2  5  1  3    ",
"                    "
@})
@end example
@end table

@c ----------------- Composer Resolver -------------------- 

@node res.composer
@subsection res.composer

The composer resolver reduces the number of required tile declarations by
geneating them by composition of base tiles. Small motley levels and nearly
every large level will use many different objects in numerous tile compositions.
As the usable one character tile key candidates will not suffice you will need
to use two or three character tile keys. But you will need numerous tile
declarations, one for every used object combination.

The composer frees you from declaring every used combination. You just declare
the base objects, e.g. the floors and all stones, items, actors and use 
combinations of these base tiles keys. The composer constructs the required
tile declarations on the fly. E.g. with the following base tile declarations:

@example
ti[" ."] = @{"fl_space"@}
ti[" ~"] = @{"fl_water"@}
ti["X "] = @{"st_grate"@}
ti["h "] = @{"it_hammer"@}
@end example

You can freely use any of the additional combination like @code{"X."} - a grate
on space, @code{"X~"} - a grate on water, @code{"h."} - a hammer on space, 
@code{"h~"} - a hammer on water.

@table @asis
@item @b{Syntax:}

@b{res.composer}(@i{subresolver})

@table @asis
@item @i{subresolver}
Resolver to which unresolved requests should be forwarded. May be @samp{ti}
as the final resolver of the resolver chain.
@end table

@item @b{Syntax Samples:}
@example
res.composer(ti)
@end example

@item @b{Details:}
For every key in the map the subresolver will be first requested for a tile
declaration. Thus any given declaration will preceede the auto composition.

Just in case that no declaration exists the search starts for existing subkey
tiles. Subkeys are keys with some characters replaced by a whitespace @samp{ }.
For all key lengths the basic subkeys with just one character different from a
whitespace will be examined. Additional just for three character key length
the three keys with just one whitespace replacement and two remaining 
original characters will be examined and these compositions will preceed the
composition of three one character tiles.

Thus for the key @code{"h~"} the composer will look for @code{"h "} and 
@code{" ~"}. For the three character key @code{"#h~"} The compser will look for
@code{"#h "} plus @code{"  ~"}, @code{"# ~"} plus @code{" h "}, @code{" h~"}
plus @code{"#  "} and finally @code{"#  "} plus @code{" h "} plus @code{"  ~"}.
For the 4 character key @code{"A#h~"} the compser will just look for 
@code{"A   "} plus @code{" #  "} plus @code{"  h "} plus @code{"   ~"}. The
same holds for any larger key length.

It is recommended to add the composer resolver behind most other library
resolvers in the resolver chain.

@item @b{Full Example:}
@example
ti["  "] = @{"fl_sahara"@}
ti[" ="] = @{"fl_tigris"@}
ti[" ."] = @{"fl_abyss"@}
ti[" ~"] = @{"fl_water"@}
ti[" ;"] = @{"fl_leaves"@}

ti["# "] = @{"st_rock1"@}
ti["W "] = @{"st_wood"@}
ti["X "] = @{"st_oxyd"@}
ti["G "] = @{"st_grate1"@}

ti["2 "] = @{"it_coin_s"@}
ti["s "] = @{"it_seed"@}
ti["c "] = @{"it_cherry"@}
ti["h "] = @{"it_hammer"@}

ti["k "] = @{"it_key"@} .. ti(@{"st_glass1"@})

ti["xx"] = @{"#ac-blackball"@} 

local resolver = res.composer(ti)

w, h = wo(resolver, "  ", @{
"                                        ",
"  h= ;W;2;c G~ ~# #.2.X X~k=k;          ",
"                                        ",
"  2;s;    2.s.    2=s=                  ",
"  c;h;    c.h.    c=h=    xx            ",
"                                        "
@})
@end example

@end table


@node res.maze
@subsection res.maze


@c ----------------- Random Resolver -------------------- 

@node res.random
@subsection res.random

With map based level description you have explicit control about the objects
being set on every single grid. But sometimes you may want to introduce some
randomness in the used objects. E.g. a floor may be made up of two types at
random to generate a different look on every level start. The randomness would
even make a level more difficult to play if one of the two floors would 
invert the mouse forces. The random resolver allows you to set up such
cases.

@table @asis
@item @b{Syntax:}

@b{res.random}(@i{subresolver}, @i{hits}, @i{replacements})

@table @asis
@item @i{subresolver}
Resolver to which unresolved requests should be forwarded. May be @samp{ti}
as the final resolver of the resolver chain.
@item @i{hits} = @i{key} | @{@i{hit}, @i{hit}, ...@}
Either a single tile key string that defines the tiles to be randomized, or a
table of hit descriptors that should all be examined in parallel.
@item @i{hit} = @i{key} | @{@i{key}, @i{superkey}@}
Either a single tile key string or a pair of tile key string and a related
tile superkey string. The superkey tile will be set additionally to the random
replacement.
@item @i{replacements} = @i{key} | @{@i{replacement}, @i{replacement}, ...@}
Either a single tile key string that would be taken without randomness or as in
most cases a table of replacement descriptors from which the resulting tile
should be selected with randomness.
@item @i{replacement} = @i{key} | @{@i{key}, @i{frequency}@}
Either a single tile key string that should be taken with a frequency of @samp{1},
or a pair of a tile key string with a given frequency number.
@end table

@item @b{Syntax Samples:}
@example
res.random(ti, "x", @{"a", "b"@})
res.random(ti, @{@{"x", "y"@},@{"i","j"@}@}, @{@{"a", 2@}, @{"b", 1@}@})
@end example

@item @b{Details:}
Every key in the map is checked against the given hit key strings. If it fits
one of them a replacement will take place.

The replacement will be one of the replacement tile keys resolved via the
subresolver. The different keys will be chosen with a likelyhood according to
the ratio of the given frequency numbers. If no frequency is supplied a default
of @samp{1} is taken. Thus in the first example both keys are taken in an ratio
1:1, whereas in the second the ratio will be 2:1.

When a superkey is given for a hit key this superkey will additionally be 
resolved via the subresolver. This feature allows to use randomness on tiles
with more than one object on a grid position. E.g. an item or an actor on a
random floor. The other objects can be set via the superkey while the random
floor is set according to the replacement rules.

@item @b{Full Example:}
@example
ti["~"] = @{"fl-water"@}
ti["s"] = @{"fl-sahara"@}
ti["t"] = @{"fl-tigris"@}
ti["i"] = @{"fl-inverse2"@}
ti["b"] = @{"fl-acblack"@}
ti["w"] = @{"fl-acwhite"@}

ti["c"] = @{"it_coin_s"@}
ti["p"] = @{"it_brush"@}

ti["1"] = @{"ac-blackball", 0, 0.5@}

simple_random = res.random(ti, " ", @{"s", "t"@})

full_random = res.random(simple_random, @{".",@{"C","c"@},@{"p","p"@}@},
                                        @{@{"i",3@},@{"b",4@},@{"w",1@}@})

w, h = wo(full_random, "s", @{
"         ~~.........",
"         ~~.........",
"         ~~......C..",
"         ~~.........",
"         ~~.........",
"         ~~.........",
"         c1.........",
"         ~~.........",
"         ~~.........",
"         ~~.........",
"         ~~......p..",
"         ~~.........",
"         ~~........."
})
@end example

Note that in this example we can use @samp{p} as key as well as superkey. This
is due to the fact that nowhere else this tile is directly set. Whereas the
tile key @samp{c} is used for another tile with the default floor. Thus we do
need to use another unique key @samp{C} for the coin on our random floor. 

@end table

@node General Features
@section General Features

@menu 
* Display Follow Strategy::    How the display view follows the active marble
* Fire Spreading::
* Freeze Checking::
@end menu

@node Display Follow Strategy
@subsection Display Follow Strategy

As the world can be larger than a display screen the active marble can move
out of the area that is visible at level start. Somehow the display has to
follow the active marble. 

Whereas prior Enigma versions did provide just a handful of fixed modes, future
versions will give you a much more detailed control of the display following 
strategy. We decided to switch the configuration to the future parameters
already now. This allows us to give you some more follower control, even though
some attributes are still limited in their values.

The strategy is described by the following parameters.

@table @asis
@item @b{Attributes:}

@table @asis
@item @ref{FollowGrid}
@item @ref{FollowMethod}
@item @ref{FollowThreshold}
@item @ref{FollowAction}

@end table

@item @b{Syntax Samples:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_SCROLL
@end example

@item @b{Details:}
The attributes should always be set in the sequence as given above. This is due
to the fact that the first attributes may reset some of the later attributes
to matching defaults. This way you will have to set just a two attributes for
the most common cases.

You can set the display follow strategy at any point. You are even allowed to
switch the strategy during the running game.

@item @b{Valid Configurations as of Enigma 1.10:}

@table @asis
@item @b{Screen Flipping:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_FLIP
@end example
The default strategy. The screen flips as soon as the marble reaches the outer
half of the boundary grid tile. The screen moves by a full screen minus the
common tile row or column.

@item @b{Half Screen Scrolling:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_SCROLL
wo["FollowAction"] = FOLLOW_HALFSCREEN
@end example
As soon as the marble reaches the outer half of the boundary grid tile the
display scrolls pixel by pixel by half a screen. It realigns to the grid. As
on a standard sized screen the display would have to scroll 9.5 grids in 
horizontal direction such scrolls will alternate in scrolls of 9 and 10 grids.
The follower will try to stabilize the reachable scroll positions.

@item @b{Permanent Smooth Scrolling:}
@example
wo["FollowGrid"] = false
wo["FollowMethod"] = FOLLOW_SCROLL
@end example
The active actor will always stay in the center of the screen. The display
compensates the actors movement pixel by pixel by scrolling. The display 
positions are not aligned to grid tiles.

@item @b{Full Screen Scrolling:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_SCROLL
wo["FollowAction"] = FOLLOW_FULLSCREEN
@end example
As soon as the marble reaches the outer half of the boundary grid tile the
display scrolls pixel by pixel by a full screen minus the common tile row or
column.

@item @b{No Screen Scrolling:}
@example
wo["FollowMethod"] = FOLLOW_NO
@end example
No scrolling at all. Even if the active actor moves out of sight the display
remains at its position.

@item @b{Screen Flipping at a given threshold:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_FLIP
wo["FollowThreshold"] = po(2.5, 1.5)
@end example
The screen flips as soon as the marble reaches the given distance to the screen
boundary. The screen moves by a full screen minus twice the threshold distance.
The final display realigns to the grid even on odd threshold distances.

@item @b{Full Screen Scrolling at a given threshold:}
@example
wo["FollowGrid"] = true
wo["FollowMethod"] = FOLLOW_SCROLL
wo["FollowThreshold"] = po(2.5, 1.5)
@end example
The screen scrolls as soon as the marble reaches the given distance to the screen
boundary. The screen moves by a full screen minus twice the threshold distance.
The final display realigns to the grid even on odd threshold distances.
@end table

@end table

@node Fire Spreading
@subsection Fire Spreading

@node Freeze Checking
@subsection Freeze Checking


@node Tips and Tricks
@section Tips and Tricks

@menu 
* Nearest Object Clustering::    When nearest object address wrong target
@end menu

@node Nearest Object Clustering
@subsection Nearest Object Clustering

The nearest object as described in @ref{Object Naming} provides a major feature
for reducing the number of needed tile declarations. As the selection needs
to be unique a rule had to be defined in case of equal distances. South wins, 
then East, Stone are favored to Items, Floors and Actors.

In most cases level authors can arrange their objects to fit these rules. But
sometimes the level design does not allow the straight forward usage of a
simple nearest object selection. E.g.

@example
ti["F"] = @{"st_floppy", target="@@door#*"@}
ti["B"] = @{"st_blocker", name="door#"@}
wo{ti, " ", {
"       B            ",
"       FB#####FB####",
"       # F    B     ",
"       # #    F#####",
@end example

In both cases the floppy switch that is located at the crossing of to blocker
doors will open the false one.

But you can use a cluster concept like the one we introduced for
@ref{Cluster Stones}. Just add one or in rare cases two or three additional
groups. Assign all standard cases to group A and the out of line cases in 
group B:

@example
ti["F"] = @{"st_floppy", target="@@doorA#*"@}
ti["B"] = @{"st_blocker", name="doorA#"@}
ti["f"] = @{"st_floppy", target="@@doorB#*"@}
ti["b"] = @{"st_blocker", name="doorB#"@}
wo{ti, " ", {
"       b            ",
"       fB#####fb####",
"       # F    B     ",
"       # #    F#####",
@end example

By clustering the doors in two groups you just need two additional tile
declarations. But you will likely be able to handle a dozen of additional
switch/door combinations.



@c ==================  Extension Development  =======================

@node Extension Development
@chapter Extension Development

@menu 
* Resolver Development::    
@end menu

@node Resolver Development
@section Resolver Development

Resolvers are designed to provide easy pluggable extensions for usage by level 
authors. Furtheron resolvers should be as flexible as possible. To reach these
goals each resolver consists of three parts: the configurator, the implemention
and the finalizer.

@menu 
* Resolver Configurator::      
* Resolver Implementation::      
* Resolver Finalizer::      
@end menu


@node Resolver Configurator
@subsection Resolver Configurator

The configurator is the function that is being called, when the author
supplies the resolver specific parameters.

@table @asis
@item @b{Syntax:}
context = @b{res.resolvername}(@i{subresolver},...)

@table @asis
@item @i{subresolver}
Resolver to which unresolved requests should be forwarded. May be @samp{ti}
as the final resolver of the resolver chain.
@end table

@item @b{Details:}
This function has just one mandatory paramenter, the subresolver. You are free
to specify arbitrary further parameters due to the needs of the resolvers task.

All official resolvers will be registered in the registry table @samp{res} under
their official name:

@example
function res.composer(subresolver)
    ...
end
@end example

This configurator function will be called just once per level start. It is 
called after the tile declarations and before the first tile is set and the
implementation part may be called.

It is the task of the configurator function to check the user supplied
parameters thoroughly and to provide appropriate error messages on bad
parameters. Do this with an lua error message call at level 2:
@example
error("Resolver autotile rule " .. i.." is not a table", 2)
@end example

The configuration function has to return a table that contains the context
for subsequent calls of the implementation. This table has three predefined
entries:

@table @asis
@item @b{[1]} = @i{implementation function}
@item @b{[2]} = @i{finalizer function}
@item @b{[3]} = @i{subresolver}
@item @b{...} = resolver specific additional entries
@end table

All the checked and preprocessed parameters have to be stored in this context
table for later usage. The resolver implementation function is usually 
registered as @samp{res.resolvername_implementation}. The finalizer can be
@samp{nil} if no finalization is necessary. The subresolver given as the
first parameter of the configurator call needs to be the third context
table entry.

@item @b{Full Example:}
@example
function res.composer(subresolver)
    local context = @{res.composer_implementation, nil, subresolver@}
    return context
end
@end example
@end table

@node Resolver Implementation
@subsection Resolver Implementation

When the map gets evaluated on the world creation the top resolver is asked
for every key to return the valid tile declaration. This is done with the
following call.

@table @asis
@item @b{Syntax:}
tile = @b{resolver_implementation}(@i{context}, @i{evaluator}, @i{key}, @i{x}, @i{y})

@table @asis
@item @i{context}
The context as provided as return value by the @ref{Resolver Configurator}.
@item @i{evaluator}
A system function that needs to be called whenever this resolver needs to
look up the key by its subresolver.
@item @i{key}
The key string that should be resolved
@item @i{x}, @i{y}
The position of the tile.

@item @b{Details:}
Based on the given parameters, the key, the position, the resolver parameters
stored in the context and the existing tiles that can be requested via the
evaluator function the implementation needs to decide if it takes influence on
the key. Note that it is not possible to access any world object via its
coordinate at this time. On every call you have to assume that it may be the
first tile that is set.

If the key is not resolved to a final tile by this resolver, the subresolver
must be called via the evaluator function:
@example
local tile = evaluator(context[3], key, x, y)
@end example

Remember that the subresolver is stored at position 3 of the context. As no
influence should be taken this tile is the one that should be returned.

But if you want to return another tile you are free to do it. You can decide
on another key and ask the subresolver for the appropriate tile. You can
even concatenate two tiles returned by subsequent subresolver calls. You are
allowed to return a new tile with a table declaration of an object. Some valid
return statements:
@example
return evaluator(context[3], "a", x, y)
return evaluator(context[3], "a", x, y) .. evaluator(context[3], "b", x, y)
return evaluator(context[3], "a", x, y) .. ti({"st_laser_n", state=ON})
@end example

You are even allowed to add new tile declartions to the tiles repository to
speed up subsequent calls:
@example
ti["newkey"] = evaluator(context[3], "a", x, y) .. ti({"st_laser_n", state=ON})
@end example

A resolver implementation can store and modifiy any of its private parameters
in the context table for subsequent calls. Especially it can enlist all 
coordinates for postprocessing operations in the finalizer.

@item @b{Full Example:}
The implementation of the composer (without the special 3 character key treatment)
@example
function res.composer_implementation(context, evaluator, key, x, y)
    local tile = evaluator(context[3], key, x, y)
    if tile ~= nil then
        return tile
    end
    -- try to compose tile
    for i = 1, #key do
        local subkey = string.rep(" ", i-1) .. string.sub(key, i, i) .. string.rep(" ", #key - i)
        local subtile = evaluator(context[3], subkey, x, y)
        if subtile == nil then
            return nil
        end
        if tile == nil then
            tile = subtile
        else
            tile = tile .. subtile
        end
    end
    return tile
end
@end

@node Resolver Finalizer
@subsection Resolver Finalizer

If the @ref{Resolver Configurator} provides a finalizer function in its context
this function will be called once when all tiles from the map have been set.

@table @asis
@item @b{Syntax:}
@b{resolver_finalization}(@i{context})

@table @asis
@item @i{context}
The context as provided as return value by the @ref{Resolver Configurator}.
@end table

@item @b{Details:}
The finalization functions of chained resolvers are called from top to bottom.

Many resolvers have no need of a finalization. But some like a maze constructor
need to know all participating tiles until they can do their final work.

As all tiles from the map have been processed the objects can now be accessed.
Further information may be stored in the resolvers context.

The finalizer does neither call its subresolver nor does it return a value.
@end table

@c ===================  Old API - Objects  =======================

@node Old API - Objects
@chapter Old API - Objects

@menu
* Floors::                      
* Items::                       
* Stones::                      
* Actors::                      
* General object attributes::
* The 1.0-Fire System::
* Freeze Checking::
* Differences between Compatibility Modes::
@end menu

@node Floors
@section Floors

@menu
* Common Floor Attributes::     Common attributes for single floor tiles
* Special floor tiles::         List of special floors
* Regular floor tiles::         List of regular floors
* fl-abyss::                    Abyss
* fl-ac[black/white]::          Blackmarble and Whitemarble Floor
* fl-bridge::                   Bridge
* fl-dummy::                    Dummy floor
* fl-gradient::                 Gradient
* fl-ice::                      Ice
* fl-inverse::                  Inverse Floor
* fl-nomouse::                  No-mouse-floor
* fl-space::                    Space Floor
* fl-space-force::              Space Floor with Vertical Force
* fl-swamp::                    Swamp
* fl-thief::                    Thief Floor
* fl-water::                    Water
@end menu


@node Common Floor Attributes
@subsection Common Floor Attributes

Standard attributes:

@table @code
@item friction
Overrides the default friction for this floor tile.
@item mousefactor
Overrides the default mousefactor.
@item force_x, force_y
Define horizontal and vertical flat forces on the floor. On
@ref{fl-gradient}, @code{force_x} and @code{force_y} are additive to
the gradient's standard force.
@item freeze_check
See @ref{Freeze Checking}.
@end table

Attributes connected to @ref{The 1.0-Fire System} (all boolean):
@table @code
@item burnable
Sets if the floor may burn.
@item ignitable
Sets if the floor gets ignited by explosions.
@item secure
Sets if the floor gets securely ignited and/or heated by neighbors.
@item eternal
Sets if the floor doesn't stop burning after awhile.
@item noash
Sets if the floor doesn't leave @code{it-burnable_ash} behind.
@item fastfire
Sets if the fire spreads fast.
@item initfire
Sets if the floor starts burning on initialization.
@end table


@node Special floor tiles
@subsection Special floor tiles

@example
fl-abyss
fl-acblack
fl-acwhite
fl-bridge( type )
fl-bridge-closed( type )
fl-bridge-open( type )
fl-dummy
fl-gradient( type force )
fl-gradient@{1..16@}( force )
fl-ice
fl-inverse
fl-inverse2
fl-nomouse
fl-swamp
fl-thief
fl-water
@end example


@node Regular floor tiles
@subsection Regular floor tiles

@example
fl-abyss_fake
fl-black
fl-bluegray
fl-bluegreen
fl-bluegreenx
fl-brick
fl-bumps
fl-concrete
fl-darkgray
fl-dunes
fl-floor_001
fl-gravel
fl-gray
fl-hay
fl-himalaya
fl-leaves
fl-leavesb
fl-leavesc@{1..4@}
fl-leavesd@{1..4@}
fl-leavese@{1..4@}
fl-light
fl-lightgray
fl-marble
fl-metal
fl-metal@{1..6@}
fl-mortar
fl-normal
fl-normal_x
fl-plank
fl-red
fl-rock
fl-rough
fl-rough-blue
fl-rough-red
fl-rough_medium
fl-rough_slow
fl-sahara
fl-samba
fl-samba1
fl-samba2
fl-sand
fl-space
fl-space-force
fl-springboard
fl-stone
fl-stwood
fl-stwood1
fl-stwood2
fl-tigris
fl-trigger
fl-white
fl-wood
fl-woven
@end example


@node fl-abyss
@subsection fl-abyss

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.  Marbles may jump over an @ref{fl-abyss} with an
@ref{it-spring[1/2/board]}.  Compare with @ref{it-abyss},
@ref{fl-water} and @ref{fl-swamp}.


@node fl-ac[black/white]
@subsection fl-ac[black/white]

Marbles on this floor are controlled by player 0 only (who has
@ref{ac-blackball} by default), respectively player 1 only
(@ref{ac-whiteball} by default).  See @ref{it-changefloor} for an item
interacting with these floors.


@node fl-bridge
@subsection fl-bridge

@code{fl-bridge} can be open (marbles fall into it) or closed (marbles
may pass).  The state can be changed via messages.

@code{fl-bridge} closes and re-opens automatically when a stone is
pushed onto it.  Thus @ref{st-wood} and other stones don't fall into
it, as they do on @ref{fl-abyss}.

@strong{Attributes}

@table @code
@item type
@code{a}, @code{x} or @code{y}
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
change state, like @code{openclose}
@end table

@strong{Variants}

@table @code
@item fl-bridge
open by default
@item fl-bridge-open
@item fl-bridge-closed
@end table


@node fl-dummy
@subsection fl-dummy

Prints its Oxyd code when entered.  Used for maintenance purposes.
Compare it with @code{st-dummy} (@ref{Oxyd Compatibility Stones}) and
@code{it-dummy} (@ref{System and Debug Items}).


@node fl-gradient
@subsection fl-gradient

Adds a horizontal, vertical or diagonal force to actors on it.  The
strength of the force is determined by @code{enigma.SlopeForce} (see
@ref{Old API - Variables}) or the attribute @code{force}.  It is additive to the
force determined by the @code{force_[x/y]}-attributes (see @ref{Common
Floor Attributes}).

@strong{Attributes}

@table @code
@item force
overrides @code{enigma.SlopeForce}
@item type
between 1 and 24, determines the direction of the gradient and its design.
@end table

Direction of the forces to certain types: 1 and 21: south, 2 and 22:
north, 3 and 23: east, 4 and 24: west, 5 and 9: south-east, 6 and 11:
south-west, 7 and 10: north-east, 8 and 12: north-west.

@strong{Variants}

@table @code
@item fl-gradient
type 1 by default
@item fl-gradient1 .. fl-gradient12
type is 1..12
@item fl-gradient13 .. fl-gradient16
types are 22, 21, 24 and 23 
@end table

The latter four gradients don't show an outline like the first twelve:
They all look identical, and similar to @code{fl-gray}.  The remaining
types show outlines that don't correspond to their forces (use them
for tubes etc.).


@node fl-ice
@subsection fl-ice

Ice has very low friction and mousefactor, such that it's difficult to
move on it.  You can use @ref{it-pin} and @code{enigma.IceFriction}
(see @ref{Old API - Variables}) to ease the friction.

@strong{Variants}

@table @code
@item fl-ice
@end table

@node fl-inverse
@subsection fl-inverse

Inverses the mouse movements (negative @code{mouseforce}).

@strong{Variants}

@table @code
@item fl-inverse
@item fl-inverse2
@end table


@node fl-nomouse
@subsection fl-nomouse

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}).


@node fl-space
@subsection fl-space

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}), but in contrast to @ref{fl-nomouse}, there
also is no friction, so that marbles seldom get stuck on space.


@node fl-space-force
@subsection fl-space-force

This floor has (like @ref{fl-space}) no friction and no mouseforce,
but adds a vertical force of the amount given in
@code{enigma.FlatForce}.  This is obsolete since you can use
@code{fl-space} with @code{force_y}-attribute (see @ref{Common Floor
Attributes}).  Note however, that the @code{enigma.FlatForce} overrides the
@code{force_y}-attribute of @code{fl-space-force}.


@node fl-swamp
@subsection fl-swamp

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.

Once in the swamp, marbles constantly sink with the speed
given by @code{enigma.SwampSinkSpeed} (see @ref{Old API - Variables}),
and may rise again when moving fast enough (compare with
@ref{fl-water} and @ref{fl-abyss}).

Marbles may jump over the swamp with an
@ref{it-spring[1/2/board]}.


@node fl-thief
@subsection fl-thief

This floor steals one item from the player's inventory. It looks like
the simple floor @code{fl-bluegray}. Compare with @ref{st-thief} for
details.

Like @code{st-thief}, @ref{st-chess_[black/white]} can deactivate @code{fl-thief}, leaving an
@ref{it-bag} behind, filled
with the items the thief stole from the actors (plus possibly the item
that already lay on the floor, if it could be picked up; if it is a
static item, no @code{it-bag} is produced). 


@node fl-water
@subsection fl-water

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}. 

Once in the water, marbles constantly sink with the speed
given by @code{enigma.WaterSinkSpeed} (see @ref{Old API - Variables}).
In contrast to @ref{fl-swamp}, they can't rise again, as
long as they're in the water.

Marbles may jump over @ref{fl-water} with an
@ref{it-spring[1/2/board]}.


@c ================== Items ====================

@node Items
@section Items

@menu
* Item List::                   A complete list of all items
* System and Debug Items::      Items for System, Debug and Compatibility
* Hills and Hollows::           Hills and Hollows
* Fire and Extinguisher::       Fire and Extinguisher
* it-abyss::                    Abyss as Item
* it-bag::                      Bag
* it-banana::                   Banana
* it-blackbomb::                Black Bomb
* it-blocker::                  Blocker Item
* it-booze::                    Booze
* it-booze-broken::             Broken Booze
* it-brake::                    Brake Item
* it-brush::                    Brush
* it-changefloor::              Changefloor Item
* it-cherry::                   Cherry
* it-coffee::                   Coffee Pause Item
* it-coin::                     Coins
* it-crack::                    Cracks in the Floor
* it-cross::                    Cross on the Floor
* it-death::                    Death Item
* it-document::                 Scrolls of Paper
* it-drop::                     Transmuting Liquid
* it-dynamite::                 Dynamite
* it-extralife::                Extralife
* it-flag[black/white]::        Black and White Flag
* it-floppy::                   Floppy Disk
* it-glasses::                  Glasses
* it-hammer::                   Hammer
* it-[h/v]strip::               Floor Strips
* it-key::                      Key
* it-landmine::                 Landmine
* it-magicwand::                Magic Wand
* it-magnet::                   Magnets
* it-odometer::                 Odometer
* it-pencil::                   Pencil
* it-pin::                      Pin
* it-pipe::                     Pipes
* it-puller::                   Puller Items
* it-ring::                     Ring
* it-rubberband::               Rubberband
* it-seed::                     Seeds
* it-sensor::                   Sensor
* it-shogun::                   Shogun Items
* it-spade::                    Spade
* it-spoon::                    Spoon
* it-spring[1/2/board]::        Springs and Springboard
* it-squashed::                 Squashed Fruit
* it-surprise::                 Surprise Item
* it-sword::                    Sword
* it-trigger::                  Trigger
* it-umbrella::                 Umbrella
* it-vortex::                   Vortices for Teleporting
* it-weight::                   Weight
* it-whitebomb::                White Bomb
* it-wormhole::                 Wormhole
* it-wrench::                   Wrench
* it-yinyang::                  Yinyang Item
@end menu

@node Item List
@subsection Item List

@example
it-1pkillstone
it-2pkillstone
it-abyss
it-bag
it-banana
it-blackbomb
it-blackbomb_burning
it-blocker
it-blocker-new
it-booze
it-booze-broken
it-brake
it-bridge-oxyd
it-bridge-oxyd_active
it-brush
it-burnable
it-burnable_ash
it-burnable_burning
it-burnable_fireproof
it-burnable_ignited
it-changefloor
it-cherry
it-coffee
it-coin1( value )
it-coin2( value )
it-coin4( value )
it-crack@{0..3@} ( type fixed brittleness )
it-cross( action target )
it-debris
it-document( text )
it-drop
it-dummy
it-dynamite
it-easykeepstone
it-easykillstone
it-explosion1
it-explosion2
it-explosion3
it-extinguisher( load )
it-extinguisher_empty( load )
it-extinguisher_medium( load )
it-extralife
it-flagblack
it-flagwhite
it-floppy
it-glasses
it-glasses-broken
it-hammer
it-hill
it-hollow( essential )
it-hstrip
it-inversesensor( action target )
it-key( keycode )
it-key_a
it-key_b
it-key_c
it-landmine
it-magicwand
it-magnet( on strength range )
it-magnet-off( on strength range )
it-magnet-on( on strength range )
it-odometer
it-oxyd5f( action target )
it-pencil
it-pin
it-pipe-e
it-pipe-es
it-pipe-h
it-pipe-n
it-pipe-ne
it-pipe-s
it-pipe-sw
it-pipe-v
it-pipe-w
it-pipe-wn
it-puller-e
it-puller-n
it-puller-s
it-puller-w
it-ring
it-rubberband( target length strength minlength scissor)
it-seed
it-seed_nowood
it-seed_volcano
it-sensor( action target )
it-shogun-l( action target )
it-shogun-m( action target )
it-shogun-s( action target )
it-signalfilter0( action target )
it-signalfilter1( action target )
it-spade
it-spoon
it-spring1
it-spring2
it-springboard
it-squashed
it-surprise
it-sword
it-tinyhill
it-tinyhollow( essential )
it-trigger( action target invisible )
it-umbrella
it-vortex-closed( autoclose targetx targety )
it-vortex-open( autoclose targetx targety )
it-vstrip
it-weight
it-whitebomb
it-wormhole( on targetx targety strength range interval )
it-wormhole-off( on targetx targety strength range interval )
it-wrench
it-yinyang
@end example


@c -------------------- System and Debug Items --------------------
@node System and Debug Items
@subsection System and Debug Items

Enigma includes several items that are not meant as items in the usual way:

@table @code
@item it-1pkillstone, it-2pkillstone
Kills the stone on the same tile in single-player mode
(correspondingly in multi-player mode). Unused, due to Enigma's missing networking
capability.

@item it-bridge-oxyd, it-bridge-oxyd_active
Used for Oxyd compatibility to animate bridges. Use @ref{fl-bridge}
instead.

@item it-debris
Animation of a breaking floor. Creates @ref{fl-abyss}, then kills
itself.

@item it-dummy
Prints its own Oxyd code when picked up or used. Compare
@ref{fl-dummy} and @code{st-dummy} (@ref{Oxyd Compatibility Stones}).

@item it-easykillstone
Kills the stone on the same tile in easy mode; if it is one of
@ref{st-death}, @ref{st-flash} or @ref{st-thief}, it is transformed to
@ref{st-plain} instead.

@item it-easykeepstone
Kills the stone on the same tile in normal mode; no exceptions.

@item it-explosion[1,2,3]
Sets a visual explosion effect of strength 1 (no remainder), 2
(@code{it-hollow} remains, see @ref{Hills and Hollows}) or 3
(@code{it-debris} remains, shattering the floor).

@item it-oxyd5f
When a message is sent to this item, it performs its
@code{action/target}-pair. Used for Oxyd compatibility only.

@item it-signalfilter[0/1]
Transforms signal 1 to signal 0 or 1, forgets signal 0. Used for Oxyd
compatibility only.

@end table


@c -------------------- Hills and Hollows  --------------------
@node Hills and Hollows
@subsection Hills and Hollows

@code{it-hill} and @code{it-hollow} create small hills and hollows in
the floor, @code{it-tinyhill} and @code{it-tinyhollow} are smaller
versions.  The strength of the slope is given by
@code{enigma.HoleForce} (see @ref{Old API - Variables}).

When a stone is pushed over them or an @ref{it-spade} is used on them,
they decrease their size: @code{it-hill} and @code{it-hollow} become
@code{it-tinyhill} and @code{it-tinyhollow}; the latter two disappear
completely.

@strong{Messages}

@table @code
@item trigger
Converts a hill to a hollow and vice versa.
@item shovel
Hills and hollows are replaced by their tiny versions; tiny ones are
removed.
@item signal
0: become @code{it-hollow} or @code{it-tinyhollow}, 1: become
@code{it-hill} or @code{it-tinyhill}
@end table

@strong{Attributes}

@table @code
@item essential
only @code{it-tinyhollow} and @code{it-hollow}, see below
@end table

@strong{In Meditation Levels}

If all existing @ref{ac-whiteball-small} are inside hollows
(@code{it-hollow} or @code{it-tinyhollow}), the level succeeds.

Use the @code{essential}-attribute if there are more holes than small
whiteballs in a level, and you want to determine which of the holes are
needed to finish the level (1 means this hollow must be filled with a
whiteball to end the level).

For example: If you have many holes and 3 whiteballs, then set
@code{essential=1} in 3 holes.  The game will end when the 3
whiteballs are inside the 3 marked holes.

Note that hollows might appear or disappear during the game; they are
handled the same way as described above.


@c -------------------- Fire and Extinguisher  --------------------
@node Fire and Extinguisher
@subsection Fire and Extinguisher

Compare @ref{The 1.0-Fire System}.

Six items are particular to the fire system:
@itemize
@item Use @code{it-burnable} to allow a floor tile to catch fire, and
it ignites from explosions, like from @ref{it-dynamite},
@ref{it-blackbomb} and @ref{it-whitebomb}.
@item @code{it-burnable_oil} is the visible variant of the invisible
@code{it-burnable}.
@item @code{it-burnable_ignited} carries the starting-animation of
fire. Use the @code{setfire}-message to a floor instead.
@item @code{it-burnable_burning} carries the animation of burning
fire. Use @code{setfire} instead.
@item @code{it-burnable_ash} is the unburnable remnant of a fire.
@item @code{it-burnable_fireproof} saves a floor from fire.
@end itemize

Use @code{it-extinguisher} to set @code{it-burnable_fireproof}. After
using it once, it becomes @code{it-extinguisher_medium}, which guards
less floor, and itself becomes @code{it-extinguisher_empty}, which can
be laid down again.

@c -------------------- Abyss as Item --------------------
@node it-abyss
@subsection it-abyss

Use this to set an invisible alternative to @ref{fl-abyss}.  Note
however, that @ref{st-wood} doesn't fill @code{it-abyss} as it does
with @code{fl-abyss}.  Marbles may jump over @code{it-abyss} with an
@code{it-spring[1/2/board]}, in contrast to @ref{it-death}.  Also,
compare to @ref{it-booze-broken}.


@c -------------------- Bag --------------------
@node it-bag
@subsection it-bag

As long as @code{it-bag} is at the first place in the inventory, new
items are put into the bag instead of the inventory, until the bag is
full (13 items). The player can drop @code{it-bag} anytime.  When picked up again,
items from the bag are put back into the inventory (until it is full).

The quite complex rules in detail:

@enumerate
@item 
Inventory and bag are limited concerning pickups to 13 items.

@item
Both are LIFO (last item picked up is first item out) - besides inventory rotation.

@item
If you pick up any item besides a bag and your first inventory item is not a bag
the item is added to the inventory.

@item
If you pick up any item besides a non-empty bag and your first inventory item is
a bag the item is added to the first inventroy bag (this includes non-empty bags
into bags!)

@item
You empty a bag by picking it up with any item at the first inventory position
but a bag. As many items as possible are taken from the bag and added to the
inventory.

@item
Empty bags are never put into other bags (this would cause unresolvable recursion
problems - see below). They will only be added to the inventory.

@item
If the touched bag cannot empty its contents to the inventory or a bag at the
inventory position is full the bag is not picked up and keeps the remaining items.

@end enumerate

@code{it-bag} is created by @ref{st-thief} and @ref{fl-thief} when
they're captured by @ref{st-chess_[black/white]}.


@c -------------------- Banana --------------------
@node it-banana
@subsection it-banana

@code{it-banana} transforms into @ref{it-cherry} when hit by a laser
beam, and into @ref{it-squashed} when a stone is pushed over it.


@c -------------------- Black Bomb --------------------
@node it-blackbomb
@subsection it-blackbomb

This item can't be picked up, but received from @ref{st-bombs}.  It
can be ignited by lasers, fire and other explosions (other
@code{it-blackbomb}, @ref{it-whitebomb}, @ref{it-dynamite}, exploding
@code{st-bombs} above them), messages ``ignite'', ``expl'' and
``explosion'' and by pushing stones over them (except for
@ref{st-shogun-<sml>} and, in Oxyd compatibility mode,
@ref{st-wood}).

When exploding, @code{it-blackbomb} ignites or destroys neighboring
items, and destroys its own floor tile by replacing it against
@code{fl-abyss}. See also @ref{it-whitebomb} for a stronger version.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@end table

@strong{Variants}

@table @code
@item it-blackbomb
@item it-blackbomb_burning
@end table


@c -------------------- Blocker Item --------------------
@node it-blocker
@subsection it-blocker

This item is the shrunken form of @ref{st-blocker}.  When it is hit by
@ref{st-bolder}, it becomes @code{st-blocker} again.  It can be
destroyed with @ref{it-brake}.

@strong{Messages}

@table @code
@item trigger, openclose
If shrunken, grow. Otherwise, change internal state; only sensible
while a stone is on top of @code{it-blocker}.
@item open, close
These are complicated, but in most cases @code{close} makes the item
grow. Consult the source code for details.
@item signal
1: open, 0: close
@end table

@strong{Variants}

@table @code
@item it-blocker
@item it-blocker-new
doesn't grow at once when @code{st-bolder} just arrives (acts as if
recently shrank)
@end table


@c -------------------- Booze --------------------
@node it-booze
@subsection it-booze

When used, the actor becomes slower for a short period of time.  Note
that @code{it-booze} is still under development; its behavior might be
changed.

When hit by a stone, @code{it-booze} transforms into
@ref{it-booze-broken}.


@c -------------------- Broken Booze --------------------
@node it-booze-broken
@subsection it-booze-broken

The remnants of @ref{it-booze} after pushing a
stone over it. Kills a marble that touches it, but not when it is jumping with
@ref{it-spring[1/2/board]} or protected by @ref{it-umbrella}, compare
@ref{it-abyss} and @ref{it-death}.  Can be removed with @ref{it-brush}
while jumping over it, or otherwise protected.


@c -------------------- Brake Item --------------------
@node it-brake
@subsection it-brake

When used, this item creates an @ref{st-brake}, which itself can be
picked up as @code{it-brake} again.  It can be used to destroy
@ref{it-blocker}.


@c -------------------- Brush --------------------
@node it-brush
@subsection it-brush

This item can be used to make some invisible stones visible
(@code{st-actorimpulse_invisible} (see @ref{st-actorimpulse}),
@code{st-break_invisible} (see @ref{Breakable-Stones}),
@code{st-stonebrush} (see @ref{st-invisible}), and to remove debris
from the level: (@ref{it-cross}, @ref{it-squashed},
@ref{it-booze-broken}, @code{it-glasses-broken} (see
@ref{it-glasses}), @code{it-burnable_ash},
@code{it-burnable_fireproof} (see @ref{Fire and Extinguisher})).

In addition, this item can be used to transform @code{st-firebreak}
into @code{st-plain} and @code{st-firebreak_move} into
@code{st-plain_move} (see @ref{st-firebreak[_move]} and
@ref{st-plain}).

The Per.Oxyd-compatibility stone @code{st-yinyang3} (see
@ref{st-yinyang}) must be touched with an @code{it-brush} or
@ref{it-magicwand} in order to activate it. 


@c -------------------- Changefloor Item --------------------
@node it-changefloor
@subsection it-changefloor

When in multi-player mode, this item exchanges @code{fl-acblack} and
@code{fl-acwhite} below it after an actor has left it (see
@ref{fl-ac[black/white]}).  This way the marble can't roll back
as easily as before.  Try the original Per.Oxyd Link Level 69 to see
this scarcely-used item in action.


@c -------------------- Cherry --------------------
@node it-cherry
@subsection it-cherry

When used, the marble becomes invisible for a short time.
Some benefits of this are that rotors and tops can't find it and
it can walk through glass. There are some different glassstones, and not all
may be passed when invisible. For details, see @ref{Glassstones}.
When a stone is pushed over @code{it-cherry}, it becomes
@ref{it-squashed}.


@c -------------------- Coffee --------------------
@node it-coffee
@subsection it-coffee

@code{it-coffee} is supposed to pause the game; not implemented yet.


@c -------------------- Coins --------------------
@node it-coin
@subsection it-coin

Activates @ref{st-coinslot}. 

When hit by a stone, @code{it-coin2} transforms into @code{it-coin4},
and @code{it-coin1} into @code{it-coin2}.  A laser beam transforms
@code{it-coin1}, @code{it-coin2}, and @code{it-coin4} into
@ref{it-umbrella}, @ref{it-hammer}, and @ref{it-extralife}.

@strong{Attributes}

@table @code
@item value
Determines how long @ref{st-coinslot} keeps activated. Defaults:
@code{it-coin1} 3.0, @code{it-coin2} 6.0, @code{it-coin4} 12.0.
@end table

@strong{Variants}

@table @code
@item it-coin1
@item it-coin2
@item it-coin4
@end table


@c -------------------- Cracks --------------------
@node it-crack
@subsection it-crack

Represents cracks in the floor. @code{it-crack0} is invisible and
grows to @code{it-crack1}, @code{it-crack2}, @code{it-crack3}, after
which the floor desintegrates to @ref{fl-abyss}.

The @code{brittleness}-attribute and
@code{enigma.Brittleness}-variable determine the probability that a
crack grows when an actor enters. When the crack grows, it spreads to
neighboring unoccupied tiles.  If you want to suppress this, set
@code{enigma.Brittleness} to 0.0 and the @code{brittleness}-attribute
of the cracks to 0.5 (or whatever you like, also see @ref{Old API - Variables}).

@strong{Attributes}

@table @code
@item type
0, 1, 2, or 3
@item fixed
0: crack can grow, 1: crack doesn't grow
@item brittleness
overrides @code{enigma.Brittleness}
@end table

@strong{Messages}

@table @code
@item crack
grow by one step
@end table

@strong{Variants}

@table @code
@item it-crack0
@item it-crack1
@item it-crack2
@item it-crack3
@end table


@c -------------------- Cross --------------------
@node it-cross
@subsection it-cross

Marks an interesting spot, can be created with an @ref{it-pencil} and
removed with @ref{it-brush}.

When a marble remains on the cross for at least 10 seconds,
@code{it-cross} performs its @code{action/target} (only once, not
every 10 seconds).   @ref{it-trigger} and
@ref{it-sensor} have similar functions.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item brush
remove @code{it-cross}
@item signal
performs @code{action/target} with inverted signal-data; works only in
Per.Oxyd-compatibility mode
@end table


@c -------------------- Death Item --------------------
@node it-death
@subsection it-death

Kills a marble that touches it, even when it is jumping with
@ref{it-spring[1/2/board]}, compare @ref{it-abyss} and
@ref{it-booze-broken}.  @ref{it-umbrella} protects the marble.


@c -------------------- Document --------------------
@node it-document
@subsection it-document

This item looks like a piece of paper and contains a text message that
can be displayed by activating the item.  It is destroyed by
explosions (like from @ref{it-blackbomb}, @ref{it-whitebomb},
@ref{st-bombs} and also @ref{it-dynamite}).

@strong{Attributes}

@table @code
@item text
The message to be displayed.
@end table

@strong{Messages}

@table @code
@item expl, bombstone
destroy
@item ignite
destroy if not in Oxyd compatibility mode
@end table

@strong{Example}
@example
set_item("it-document", 1,1, @{text="Hello World!"@})
Document(1,1, "Hello World")
@end example

@c -------------------- Drop --------------------
@node it-drop
@subsection it-drop

Transforms the marble into an @ref{ac-rotor} for a short time.
Can be used multiple times.

@c -------------------- Dynamite --------------------
@node it-dynamite
@subsection it-dynamite

@code{it-dynamite} can be ignited by dropping it, by lasers, fire,
other explosions (@ref{it-blackbomb}, @ref{it-whitebomb}, other
@code{it-dynamite} and @ref{st-bombs}).  While burning, it can't be
picked up.  During explosion (@code{it-explosion2}, see
@ref{System and Debug Items}), it ignites neighboring items and
leaves an @code{it-hollow} behind (see @ref{Hills and Hollows}). On
@ref{fl-ice}, it creates @code{it-crack2} instead (see @ref{it-crack}).

On @ref{fl-space}, dynamite is supposed to result in shards. This is
not implemented yet: It creates @code{it-hollow} without explosion.
Note that this and the exact implementation of explosions might change
in future versions.

@strong{Messages}

@table @code
@item ignite, expl, bombstone
ignite, then explode
@item explode
explode instantly
@end table


@c -------------------- Extralife --------------------
@node it-extralife
@subsection it-extralife

Adds a life to the player's inventory.

A laser beam transforms this into @ref{it-glasses}, and
@code{it-extralife} itself results from @code{it-coin4} (see
@ref{it-coin}).


@c -------------------- Black and White Flag --------------------
@node it-flag[black/white]
@subsection it-flag[black/white]

Marks the place, where @ref{ac-blackball} respectively
@ref{ac-whiteball} respawn when killed.  For this purpose, they have
to be used at least once.


@c -------------------- Floppy --------------------
@node it-floppy
@subsection it-floppy

The floppy disk is needed to activate the floppy switch (see
@ref{st-floppy}).


@c -------------------- Glasses --------------------
@node it-glasses
@subsection it-glasses

While @code{it-glasses} is in the inventory, hollow stones become
invisible and @code{st-death_invisible} becomes visible (see
@ref{st-death}).

@code{it-glasses} breaks when a stone is pushed over it, and becomes
the inactive version @code{it-glasses-broken}.  @code{it-glasses}
results from the laser transformation of @ref{it-extralife}.

@strong{Variants}

@table @code
@item it-glasses
@item it-glasses-broken
@end table


@c -------------------- Hammer --------------------
@node it-hammer
@subsection it-hammer

The hammer is used to destroy some stones, see @ref{Breakable
Stones} and @ref{st-lightpassenger}. It also transforms into
@ref{it-sword} when hit with a laser beam and is itself a
laser transformation result of @ref{it-sword} and @code{it-coin2} (see
@ref{it-coin}).


@c -------------------- Horizontal and Vertical Land Strip --------------------
@node it-[h/v]strip
@subsection it-[h/v]strip

These items cover a small strip of the ground below them and provide a
narrow bridge for the marble to safely pass @ref{fl-abyss},
@ref{fl-swamp}, @ref{fl-water}, or any other floor.

@strong{Variants}

@table @code
@item it-hstrip
horizontal
@item it-vstrip
vertical
@end table


@c -------------------- Key --------------------
@node it-key
@subsection it-key

Used to activate @ref{st-key}.

@strong{Attributes}

@table @code
@item keycode
see @ref{st-key}
@end table

@strong{Variants}

@table @code
@item it-key
@code{keycode} is 1
@item it-key_a
@code{keycode} is 1
@item it-key_b
@code{keycode} is 2
@item it-key_c
@code{keycode} is 3
@end table


@c -------------------- Landmine --------------------
@node it-landmine
@subsection it-landmine

Explodes when hit by a marble or by a stone, shatters the marble, and
leaves an @code{it-hollow} behind (see @ref{Hills and Hollows}).


@c -------------------- Magic Wand --------------------
@node it-magicwand
@subsection it-magicwand

@itemize @bullet
@item
Changes direction of a oneway stone (@ref{st-oneway}).
@item
Changes direction of a bolder stone (@ref{st-bolder}).
@item
Scrambles blue puzzle stones instead of pushing, causes complete
clusters to explode (@ref{st-puzzle}).
@c @item
@c not implemented?  st-stoneimpulse_movable doesn't pulse
@item
Makes @code{st-brick_magic} transparent (@ref{st-brick_magic}).
@item
Makes @code{st-invisible_magic} visible and non-transparent
(@ref{st-invisible}).
@item
Makes rubberband stones movable (@ref{st-rubberband}).
@item
Changes the color of a chess stone (@ref{st-chess_[black/white]}).
@item
Activates @code{st-yinyang3} (@ref{st-yinyang}).
@end itemize


@c -------------------- Magnet --------------------
@node it-magnet
@subsection it-magnet

Attracts actors in its @code{range} with a force proportional to
@code{strength} and the inverse of the distance.  The magnet can be on
or off.

@strong{Attributes}

@table @code
@item on
@code{TRUE} or @code{FALSE}, see variants below
@item strength
default: 30
@item range
default: 1000 (quasi infinite)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-magnet
by default off
@item it-magnet-on
@item it-magnet-off
@end table


@c -------------------- Odometer --------------------
@node it-odometer
@subsection it-odometer

Supposed to measure the route the marble has rolled since picking up
@code{it-odometer}.  Not implemented yet.


@c -------------------- Pencil --------------------
@node it-pencil
@subsection it-pencil

Try to scratch an @ref{it-cross} into the floor; the pencil is lost
after this. Scratching onto ice results in a crack, scratching
while flying or on certain floors results in dropping the pencil.

In addition, this item can be used to transform @code{st-plain} into
@code{st-firebreak} and @code{st-plain_move} into
@code{st-firebreak_move} (see @ref{st-plain} and
@ref{st-firebreak[_move]}).


@c -------------------- Pin --------------------
@node it-pin
@subsection it-pin

While in inventory, @code{it-pin} increases the friction of the
floor.  Used in conjunction with @ref{fl-ice}.


@c -------------------- Pipes --------------------
@node it-pipe
@subsection it-pipe

Pipes are used by @ref{st-mail} to transport items over large
distances or onto unreachable grounds.  Pipes can be destroyed by
explosions (such as from @ref{it-blackbomb} or @ref{it-whitebomb}).

@strong{Variants}

@table @code
@item it-pipe-e
@item it-pipe-w
@item it-pipe-s
@item it-pipe-n
@item it-pipe-es
@item it-pipe-ne
@item it-pipe-sw
@item it-pipe-wn
@item it-pipe-h
horizontal
@item it-pipe-v
vertical
@end table

The first four variants depict endpoints of the pipe, they're of no
use to @ref{st-mail} other than blocking the endpoint.


@c -------------------- Puller --------------------
@node it-puller
@subsection it-puller

When dropped, these items pull a stone from the direction they point
to, to their own position.  They explode during this, shattering
marbles near them.

@strong{Variants}

@table @code
@item it-puller-e
@item it-puller-w
@item it-puller-s
@item it-puller-n
@end table


@c -------------------- Ring --------------------
@node it-ring
@subsection it-ring

When a player drops this item, the marble is teleported.  The
destination depends on the game mode:

@table @emph
@item Single player levels:
The marble is transported to its starting position or
to the position of the last dropped @ref{it-flag[black/white]}.

@item Multi player levels:
Both marbles exchange their positions.  In contrast to
@ref{it-yinyang}, the positions are exchanged, not the players.
@end table


@c -------------------- Rubberband --------------------
@node it-rubberband
@subsection it-rubberband

Connects the actor using it with a target. This target can be an other actor or a stone.
The target is determined by its name-attribute. If the target doesn't exist,
the it-rubberband will be dropped.

@strong{Attributes}

@table @code
@item target
The target to connect with. It must be the name of an other actor or a stone.
@item length
The natural length of the rubberband (default: 1)
@item strength
The strength of the rubberband (default: 10)
@item minlength
The minimal length of the rubberband (default: 0)
@item scissor
Boolean value defining if already-existing rubberbands to the actor should be cut off.
(Default: false)
@end table

@subsection Examples

@example
set_stones("st-glass", 5, 5, @{name="MyRubberTarget1"@})
@dots{}
-- When used, this it-rubberband will connect the actor with the glassstone.
set_item("it-rubberband", 3, 5, @{target="MyRubberTarget1"@})
@end example

@c -------------------- Seeds --------------------
@node it-seed
@subsection it-seed

Stones can grow from three different seeds:
@code{it-seed} creates @ref{st-wood}, @code{it-seed_nowood} creates
@code{st-greenbrown-growing}, which produces the unmovable simple
stone @code{st-greenbrown}, and @code{it-seed_volcano} that creates
an @ref{st-volcano}.  The new
stone inherits the name of the seed.

In Oxyd-Magnum-compatibility mode, @code{it-seed} under
@code{st-grate1} (see @ref{st-grate}) grows to the simple floor
@code{fl-stwood} instead of destroying the grate.  In all other cases,
stones at the position of the seed are replaced by the new stone.

Seeds start growing on dropping them, on laser beams, stone hits and
the @code{grow} and @code{signal}-messages.

@strong{Messages}

@table @code
@item grow, signal
start growing
@end table

@strong{Variants}

@table @code
@item it-seed
@item it-seed_nowood
@item it-seed_volcano
@end table


@c -------------------- Sensor --------------------
@node it-sensor
@subsection it-sensor

This is an invisible, quiet and less extensive version of
@ref{it-trigger}.  Whenever an actor enters it, it performs its
@code{action/target}-pair, with second data @code{TRUE} for
@code{it-sensor} and @code{FALSE} for @code{it-inversesensor}.
Also compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item it-sensor
@item it-inversesensor
@end table


@c -------------------- Shogun Item --------------------
@node it-shogun
@subsection it-shogun

Performs its @code{action/target}-pair when an @ref{st-shogun-<sml>}
of fitting size covers it.

@strong{Attributes}

@table @code
@c @item size couldn't find this in code, though announced in remark
@item target, action
as usual
@end table

@strong{Messages}

@table @code
@item noshogun
deactivate
@item shogun @enddots{}
used to activate or deactivate @code{it-shogun}
@end table

@strong{Variants}

@table @code
@item it-shogun-s
@item it-shogun-m
@item it-shogun-l
@end table


@c -------------------- Spade --------------------
@node it-spade
@subsection it-spade

Decreases the size of an @code{it-hill} or @code{it-hollow} and
removes @code{it-tinyhill} and @code{it-tinyhollow}, see @ref{Hills
and Hollows}.


@c -------------------- Spoon --------------------
@node it-spoon
@subsection it-spoon

Shatters the marble.  Note that in contrast to F3, @code{it-spoon}
only shatters the marble using it, not all of them.


@c -------------------- Springs --------------------
@node it-spring[1/2/board]
@subsection it-spring[1/2/board]

Springs let marbles jump, e.g., over @ref{fl-water}, @ref{fl-swamp},
@ref{fl-abyss}, @ref{it-abyss}, and laser beams.  Note that you can't
jump over any kind of stone, or pass @ref{st-grate} during the
jump, even if you could on the ground.  The interplay of jumping and
fire (@ref{The 1.0-Fire System}) will be target of future changes;
don't use them together yet.

You can pick up and use @code{it-spring1} and @code{it-spring2}.  You
keep the former in the inventory, but in general, drop
@code{it-spring2} when using.  @code{it-springboard} is fixed to the
ground; you can only use it where it is.

When you're already sinking in @code{fl-swamp} or @code{fl-water}, you
can use springs to jump out of them, sinking then starts anew.

@strong{Variants}

@table @code
@item it-spring1
@item it-spring2
@item it-springboard
@end table


@c -------------------- Squashed Fruits --------------------
@node it-squashed
@subsection it-squashed

The remnants of @ref{it-cherry} or @ref{it-banana} after pushing a
stone over them.  Can be removed with @ref{it-brush}.


@c -------------------- Surprise Item --------------------
@node it-surprise
@subsection it-surprise

This item turns randomly into @ref{it-umbrella}, @code{it-spring1} (see
@ref{it-spring[1/2/board]}), @ref{it-dynamite}, @ref{it-coffee}, or
@ref{it-hammer} when dropped.  The corresponding stone is @ref{st-surprise}.


@c -------------------- Sword --------------------
@node it-sword
@subsection it-sword

Used to neutralize @ref{st-knight}.  The laser transforms it into
@ref{it-hammer} and vice versa.


@c -------------------- Trigger --------------------
@node it-trigger
@subsection it-trigger

When pushed down by an actor or a stone, this trigger performs its
@code{action/target}-pair, and a second time when it is released
again. As second data it uses @code{TRUE} when pressed, and
@code{FALSE} if not. 

Floating stones do not hold down a trigger, except of the tunnel
puzzle-stone (see @ref{st-puzzle}). 

@code{it-trigger} can be initialized as invisible with attribute
@code{invisible = TRUE}.  Note that it still produces its
click-sounds.  For a simpler version, see @ref{it-sensor}.  Also
compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item invisible
0.0 (visible) or 1.0 (invisible), by default 0.0
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item signal
perform @code{action/target} according to second data
@end table


@c -------------------- Umbrella --------------------
@node it-umbrella
@subsection it-umbrella

@code{it-umbrella} temporarily protects a marble from @ref{st-death},
@ref{st-knight}, @ref{st-thief}, @ref{fl-abyss}, @ref{fl-water},
@ref{fl-swamp}, @ref{fl-thief}, @ref{it-death}, @ref{it-abyss},
@ref{it-booze-broken}, explosions, moving stones and the ``shatter''
and ``fall''-messages; in other words, from all lethal situations and
thieves.

@code{it-umbrella} can be destroyed by laserlight and is the result of
laser-transforming an @code{it-coin1} (see @ref{it-coin}).


@c -------------------- Vortex -------------------- 
@node it-vortex
@subsection it-vortex

Vortices, like @ref{it-wormhole}, can be used to teleport marbles.  In
the simplest case, every vortex is connected to exactly one other
vortex. If there are multiple target vortices, the marble will be
teleported to the first @emph{unblocked} target site.  Many levels in
the original Oxyd games required the player to selectively block
vortices to gain access to new parts of the level.

In a further contrast to wormholes, vortices can be open or closed,
and when marbles exit, they jump out of them.  Furthermore, connecting
vortices in a cycle works as expected and is standard (though not
necessary), whereas connecting wormholes cyclic results in an
error-message (as long as their @code{interval}-message isn't used).

@strong{Attributes}

@table @code
@item targetx, targety
destination of teleport
@item autoclose
not implemented yet, see variants below
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item trigger
identical to @code{openclose}
@item signal
0: close, 1: open
@item arrival
used by the teleport-system, don't use in levels
@end table

@strong{Variants}

@table @code
@item it-vortex-open
This vortex starts open and doesn't close when an actor jumps out of
it. Default teleportation target is the own position, thus an actor
keeps jumping in and out of it until moved away.
@item it-vortex-closed
This vortex starts closed and closes again when an actor jumps out of
it.  If you want to create an open vortex that closes after an actor,
send a @code{trigger}-message to @code{it-vortex-closed} on
initialization.
@end table

Note that @code{it-vortex-open} and @code{it-vortex-closed} @emph{do
behave differently}, in contrast to their names.

@strong{Example}

This example creates three vortices.  If the second vortex is blocked, a
marble falling into the first one is transported to (20,1).

@example
set_item ("it-vortex-open", 1, 1)
set_item ("it-vortex-open", 10,1)
set_item ("it-vortex-open", 20,1)
Signal ("it(1 1)", "it(10 1)")
Signal ("it(1 1)", "it(20 1)")
Signal ("it(10 1)", "it(1 1)")
Signal ("it(20 1)", "it(1 1)")
@end example


@c -------------------- Weight -------------------- 
@node it-weight
@subsection it-weight

Heightens the mass of the marble (making it more difficult to
accelerate and guide) and it can't be dropped.  Note that it can still be
stolen by @ref{st-thief} or @ref{fl-thief} and mailed away with
@ref{st-mail}. 


@c -------------------- White Bomb --------------------
@node it-whitebomb
@subsection it-whitebomb

This item is the stronger version of @ref{it-blackbomb}, and can't be
picked up also.  It can be ignited by lasers, fire and other 
explosions (@ref{it-blackbomb}, other @code{it-whitebomb},
@ref{it-dynamite}), messages ``ignite'', ``expl'' and ``explosion''
and by pushing stones over them (except for @ref{st-shogun-<sml>} and,
in Oxyd compatibility mode, @ref{st-wood}).

When exploding, @code{it-whitebomb} ignites or destroys neighboring
items and destroys all nine neighboring floor tiles by replacing them
with @code{fl-abyss}.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@end table

Note that, in contrast to @ref{it-blackbomb}, white bombs are not
removed from @ref{st-bombs}-explosions.


@c -------------------- Wormhole -------------------- 
@node it-wormhole
@subsection it-wormhole

Teleports actors to the coordinates given by the @code{targetx}- and
@code{targety}-attributes (compare @ref{it-vortex}).  In addition,
wormholes have a variable force field, which can be switched on and
off.

After teleporting an actor, the wormhole's teleporting ability is
switched off for a time period given by the @code{interval}-attribute,
which is by default 0.0.

@strong{Attributes}

@table @code
@item targetx, targety
exit of the wormhole
@item strength, range
strength and range of the force field
@item on
whether force field is on
@item interval
minimal delay between two teleports
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-wormhole
@item it-wormhole-off
wormhole without force field
@end table


@c -------------------- Wrench -------------------- 
@node it-wrench
@subsection it-wrench

Changes direction of @ref{st-rotator}.


@c -------------------- Yinyang Item -------------------- 
@node it-yinyang
@subsection it-yinyang

Toggles between players.  Compare @ref{it-ring} in multiplayer mode.


@c ===================  Stones  =======================

@node Stones
@section Stones

@menu
* Stone List::                  A complete list of all stones
* Glassstones::                 A summary of all kinds of glassy stones
* Breakable-Stones::            A summary of all breakable stones
* Oxyd Compatibility Stones::   Special stones for Oxyd compatibility and debugging
* st-actorimpulse::             Bumper Stones
* st-big[brick/bluesand]::      Big Stones
* st-[black/white]::            Black and White Stones
* st-[black/white]balls::       Blackballs Stone and Whiteballs Stone
* st-block::                    Movable and sinkable stone
* st-blocker::                  Shrinkable Blocker Stone
* st-bolder::                   Bolder (or Arrow) Stone
* st-bombs::                    Bombstone
* st-brake::                    Brake
* st-brick_magic::              Magic Brick Stone
* st-chameleon::                Chameleon Stone
* st-charge::                   Charge Stones
* st-chess_[black/white]::      Chess (Knight) Stone
* st-coffee::                   Coffee Stone
* st-coinslot::                 Coin Slot Switch
* st-death::                    Skull Stones
* st-disco::                    Disco Stones
* st-door::                     Doors
* st-easymode::                 Easy Mode Stone
* st-explosion::                Explosion Stone
* st-fakeoxyda::                Movable Fake Oxyd Stone
* st-fart::                     The Infamous Fart Stones
* st-firebreak[_move]::         Firebreakable Stones
* st-flash::                    Flash Stone
* st-floppy::                   Floppy Switch
* st-fourswitch::               Fourswitch
* st-grate::                    Various Grates
* st-invisible::                Invisible Stones
* st-key::                      Key (or Lock) Stone
* st-knight::                   Knight Stone
* st-laser::                    Laser Stones
* st-laserswitch::              Laser Switch
* st-lasertimeswitch::          Laser Time Switch
* st-lightpassenger::           Light Passenger
* st-mail::                     Mail Stones
* st-mirror::                   Mirror Stones
* st-oneway::                   One-way Stones
* st-oxyd::                     The Famous Oxyd Stones
* st-plain::                    Plain Stones
* st-polarswitch::              Light Switch in Polarizator Style
* st-pull::                     Pull Stone
* st-puzzle::                   Puzzle Stones
* st-rotator::                  Rotator Stone
* st-rubberband::               Rubberband Stone
* st-scissors::                 Scissors Stone
* st-shogun-<sml>::             Shogun Stones
* st-spitter::                  Spitter Stone
* st-stoneimpulse::             Impulse Stones
* st-surprise::                 Surprise Stone
* st-swap::                     Swap Stones
* st-switch::                   Ordinary Switches
* st-thief::                    Thief (Thieves)
* st-timer::                    Timers
* st-timeswitch::               Time Switch
* st-turnstile::                Turnstiles
* st-volcano::                  Volcano
* st-window::                   Breakable Window
* st-wood::                     Wooden Stones
* st-yinyang::                  Yin-Yang Stones
@end menu

For the common stone attribute @code{freeze_check}, see @ref{Freeze Checking}.

@node Stone List
@subsection Stone List

@strong{Simple stones}

The following stone types are commonly used for ``decoration''.  They
generally do not have special properties or abilities.  We use three types of
abbreviations in the tables: @code{[abc]} stands for any of the
characters in square brackets, @code{<abc>} stands for any subsequence
of the characters between the angle brackets (in this case abc, ab, bc,
a, b, c), and @code{@{1..9@}} indicates a sequence of numbers.

@example
st-beads
st-blue-sand
st-bluegray
st-bluegray_hole
st-brick
st-brownie
st-bumps
st-camouflage
st-camouflage_hole
st-camouflage_move
st-dummy
st-fakeoxyd( blinking )
st-glass
st-glass_move
st-glass[123]
st-glass[12]_hole
st-glass[12]_move
st-greenbrown
st-greenbrown_hole
st-greenbrown_move
st-likeoxyd[abcd]
st-likeoxyd[abcd]-open
st-marble
st-marble_hole
st-marble_move
st-metal
st-metal_hole
st-redrock
st-rock@{1..10@}
st-rock[123]_hole
st-rock[13]_move
st-stone[12]
st-wood[12]
st-wood_001
st-woven
st-yellow
@end example

@strong{Special stones}

The following stones types are special in the sense that they perform
some action, either when hit by an actor, or all by themselves.

@example
st-3mirror( transparent movable orientation )
st-actorimpulse( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-actorimpulse_invisible( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-bigbluesand-<nesw>
st-bigbrick-<nesw>
st-black@{1..4@}
st-blackballs
st-block
st-blocker
st-blocker-growing
st-bolder( direction )
st-bolder-[ensw]( direction )
st-bombs
st-brake
st-break_acblack
st-break_acwhite
st-break_bolder
st-break_gray
st-break_invisible
st-breaking
st-brick_magic
st-bug
st-chameleon
st-chargeminus( charge )
st-chargeplus( charge )
st-chargezero( charge )
st-chess_black( color direction1 direction2 )
st-chess_white( color direction1 direction2 )
st-coffee
st-coinslot( on action target )
st-death
st-death_invisible
st-disco-dark
st-disco-light
st-disco-medium
st-door( type )
st-door-h( type )
st-door-h-open( type )
st-door-v( type )
st-door-v-open( type )
st-door_[abc]
@c st-dynamite
st-easymode
st-explosion
st-fakeoxyda
st-fart
st-firebreak
st-firebreak_move
st-flash( hit_factor hit_distortion_[xx,xy,yx,yy] )
st-flhay
st-floppy( action target on )
st-flrock
st-fourswitch( action target on )
st-grate[123]
st-greenbrown-growing
st-invisible
st-invisible_magic
st-key( action target on keycode )
st-key_[abc]( action target on keycode )
st-knight
st-laser( dir on )
st-laser-[ensw]( dir on )
st-laserbreak
st-laserswitch( action target inverse )
st-lasertimeswitch( action target inverse delay )
st-lightpassenger( interval friction_factor gradient_factor )
st-magic
st-mail-[ensw]
st-mirror*( movable transparent orientation )
st-mirror-3<
st-mirror-3<m
st-mirror-3<t
st-mirror-3<tm
st-mirror-3>
st-mirror-3>m
st-mirror-3>t
st-mirror-3>tm
st-mirror-3^
st-mirror-3^m
st-mirror-3^t
st-mirror-3^tm
st-mirror-3v
st-mirror-3vm
st-mirror-3vt
st-mirror-3vtm
st-mirror-p-
st-mirror-p-m
st-mirror-p-t
st-mirror-p-tm
st-mirror-p/
st-mirror-p/m
st-mirror-p/t
st-mirror-p/tm
st-mirror-p\
st-mirror-p\m
st-mirror-p\t
st-mirror-p\tm
st-mirror-p|
st-mirror-p|m
st-mirror-p|t
st-mirror-p|tm
st-oneway( orientation )
st-oneway-[nesw]( orientation )
st-oneway_black( orientation )
st-oneway_black-[nesw]( orientation )
st-oneway_white( orientation )
st-oneway_white-[nesw]( orientation )
st-oxyd( flavor color static )
st-oxyd-0x18
st-peroxyd-0xb8
st-peroxyd-0xb9
st-plain
st-plain_break
st-plain_breaking
st-plain_cracked
st-plain_falling
st-plain_hole
st-plain_move
st-pmirror( transparent movable orientation )
st-polarswitch( on )
st-pull
st-puzzle-hollow( oxyd )
st-puzzle-<nesw>( oxyd )
st-puzzle2-hollow( oxyd )
st-puzzle2-<nesw>( oxyd )
st-rock3_break
st-rock3_movebreak
st-rotator-left
st-rotator-right
st-rotator_move-left
st-rotator_move-right
st-rubberband( length strength minlength scissor)
st-scissors( action target )
st-shogun-<sml>( holes )
st-spitter( hit_factor hit_distortion_[xx/xy/yx/yy] )
st-stone_break
st-stonebrush
st-stoneimpulse
st-stoneimpulse-hollow
st-stoneimpulse_movable
st-surprise
st-swap
st-switch( action target on )
st-switch_black( action target on )
st-switch_white( action target on )
st-thief
st-timer( action target on interval loop invisible )
st-timeswitch( action target delay inverse )
st-turnstile
st-turnstile-green
st-turnstile-[ensw]
st-volcano
st-volcano-growing
st-volcano_active
st-volcano_inactive
st-white@{1..4@}
st-whiteballs
@c st-whitebombs
st-window
st-wood
st-wood-growing
st-yinyang@{1..3@}
@end example

@node Glassstones
@subsection Glassstones

There are a few kinds of glassstones, all similar, but with different details.
Some of them may be passed after the use of an @ref{it-cherry}, others will be
just pushed. Some are transparent for lasers, but not all! This table shows their
exact properties.

@multitable {st-polarswitch (off)  } {actor is visible:  } {actor is invisible:  } {lasertransparent:  }
@headitem stone: @tab actor is visible: @tab actor is invisible: @tab lasertransparent:
@item st-glass @tab - @tab pass @tab yes
@item st-glass_move @tab push @tab pass @tab yes
@item st-glass1 @tab - @tab pass @tab yes
@item st-glass1_move @tab push @tab push @tab yes
@item st-glass1_hole @tab pass @tab pass @tab yes
@item st-glass2 @tab - @tab pass @tab no
@item st-glass2_move @tab push @tab push @tab no
@item st-glass2_hole @tab pass @tab pass @tab yes
@item st-glass3 @tab - @tab -@tab yes
@item st-polarswitch (on) @tab toggle @tab pass @tab yes
@item st-polarswitch (off) @tab toggle @tab pass @tab no
@item st-beads @tab - @tab pass @tab no
@end multitable

These entries can be visualized as follows: A glassstone is transparent for
laser light, if it is not dark, or if it is hollow. Exception is
@code{st-beads}, whose irregular sides would scatter the beam. A glassstone
can always be passed by invisible actors, with three exceptions:
@code{st-glass3}, whose inside is filled with red stripes, and the two movables
@code{st-glass1_move} and @code{st-glass2_move} which have a non-glass frame
which the actor can use to move the stone. @code{st-glass_move} does not have 
such a frame and cannot be moved by an invisible actor.


@node Breakable-Stones
@subsection Breakable-Stones

A list of all breakable stones and what may break them. Messages are
given in quotation marks. ``pyro'' is short for dynamite, bombs,
bombstones, ``ignite'', ``expl'' and ``bombstone''.

@table @code
@item st-stone_break, st-rock3_break, st-break_gray
hammer, laser, pyro
@item st-break_acblack
@ref{ac-blackball} with hammer, laser, pyro
@item st-break_acwhite
@ref{ac-whiteball} with hammer, laser, pyro
@item st-break_bolder
hammer, laser, bolder, ``trigger'', (pyro?)
@item st-break_invisible
hammer after using a brush
@item st-laserbreak
laser, pyro
@item st-rock3_movebreak
hammer, pyro; this stone is movable by impulses (not actors)
@item st-plain_break
hammer, laser, pyro; falls into @ref{fl-abyss}
@item st-plain_cracked
hammer, pyro
@item st-plain_move
pyro; this stone is movable; falls into @ref{fl-abyss},
@ref{fl-water} and @ref{fl-swamp}; see also @ref{st-plain}
@item st-bug
@ref{ac-bug}
@item st-breaking, st-plain_breaking
breaks instantly, looks like @code{st-rock3}
@item st-fart
hammer, laser; see also @ref{st-fart}
@item st-bombs
@c st-dynamite, st-whitebombs
bombs, bombstones, ``expl'', ``bombstone''; see also @ref{st-bombs}
@item st-brake
laser, bombs, ``expl''; see @ref{st-brake}
@item st-puzzle
see @ref{st-puzzle}
@item st-volcano_active
hammer; see @ref{st-volcano}
@item st-lightpassenger
hammer when active and trapped; see @ref{st-lightpassenger}
@item st-firebreak
fire near the stone; see also @ref{st-firebreak[_move]}
@item st-firebreak_move
fire under the stone; movable; falls into @ref{fl-abyss},
@ref{fl-water} and @ref{fl-swamp}; see also @ref{st-firebreak[_move]}
@end table

For the mentioned objects, see @ref{it-hammer}, @ref{it-dynamite},
@ref{it-blackbomb}, @ref{st-bombs}, @ref{st-bolder}, @ref{it-brush}.
Also compare @ref{st-plain}, since @code{st-plain_cracked} results from
@code{st-plain} when hit by a laser beam, and @code{st-plain[_move]}
can be transformed into and out of @code{st-firebreak[_move]}.


@node Oxyd Compatibility Stones
@subsection Oxyd Compatibility Stones

@code{st-magic} disappears when hit hard enough.

@code{st-dummy} prints its own Oxyd code when hit. Compare
@code{it-dummy} (@ref{System and Debug Items}) and @ref{fl-dummy}.

@code{st-peroxyd-0xb8}, @code{st-peroxyd-0xb9} and @code{st-oxyd-0x18}
just seem to destroy themselves on creation, the former two creating
@code{fl-normal} beneath them.  Their purpose in the original games is
unknown.


@node st-actorimpulse
@subsection st-actorimpulse: Bumper Stones

These stones apply an impulse to actors that touch them.  The amount
of force applied can be controlled by setting
@code{enigma.BumperForce} (see @ref{Old API - Variables}) accordingly (the
default is 200). Alternatively, the @code{force} attribute can be used
to set this factor for @emph{individual} bumper stones.

@strong{Attributes}

@table @code
@item force
factor of the transmitted force (overrides @code{enigma.BumperForce})
@item hit_factor
factor of the transmitted force (overrides @code{enigma.BumperForce}
and @code{force})
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@strong{Variants}

The invisible variant, @code{st-actorimpulse_invisible} can be
``painted'' with an @ref{it-brush}.

@node st-big[brick/bluesand]
@subsection st-big[brick/bluesand]: Big Stones

These stones are used to construct big clusters of stones that
visually seem like one big stone.  Though mainly decorative, they also
have a small special ability, since they are the only stones that can't
be swapped with @ref{st-swap} or @ref{st-pull} (besides @ref{st-oxyd}
with true @code{static}-attribute).

@strong{Attributes}

@table @code
@item connections
A number between 1 and 16.  Each bit in (connections-1) corresponds to
an open face of the stone.  You will normally simply use one of the
Lua constants @code{PUZ_0001} to @code{PUZ_1111}.
@end table

@strong{Variants}

Two families of big stones differ in design:
@code{st-bigbrick-<nesw>} (similar to @code{st-brick}) and
@code{st-bigbluesand-<nesw>} (similar to @code{st-blue-sand}). 

The term @code{<nesw>} denotes all non-empty substrings of
@code{nesw}, describing the directions to which the single parts are
open. Examples: @code{st-bigbluesand-nw} is a blue stone with a border
on the south and east side, @code{st-bigbrick-esw} is a brick-type
stone which connects to the east, south and west, and has a border on
the north side.

@code{st-bigbrick} and @code{st-bigbluesand}, without suffix, are not
defined. Use @code{st-brick} and @code{st-blue-sand} to set single
stones of these designs.  Note, however, that both these stones are
swappable and pullable like normal stones.

See @ref{st-puzzle} for another kind of cluster-building stones.


@node st-[black/white]
@subsection st-[black/white]: Black and white stones

These stones only let black, or respectively, white marbles, pass.

@strong{Variants}

@code{st-black} and @code{st-white} come in four flavors each:
@code{st-black1} and @code{st-white1} are not transparent at all,
@code{@dots{}2} has a diagonal bar, @code{@dots{}3} a cross and @code{@dots{}4}
only consists of a black or white frame.

See @ref{st-grate} for other stones that only special actors may
pass.


@node st-[black/white]balls
@subsection st-[black/white]balls: Blackballs and Whiteballs Stones

Mainly used as decorative, this stone also has a special function: When
it receives a message from a stone, which is just hit by a black
(or white, respectively) marble, it sends signal 1 to the neighboring stones
west and east of it and 0 to north and south; or vice versa, depending
on the position of the message-sending stone.

A typical construction for this is an @code{st-blackballs} surrounded
by @ref{st-door} and @ref{it-sensor}, with @code{st-blackballs} as
target of the action of @code{it-sensor}.  When in this situation a
black marble hits one of the closed doors, the door lets
@code{it-sensor} perform its action, sending a message to
@code{st-blackballs}.  This then opens the knocked door and the door in
the opposite direction, while closing the doors in the perpendicular
directions.  However, when @code{it-sensor} triggers because of the
marble entering it, @code{st-blackballs} won't trigger since there is no
collision causing this event.


@node st-block
@subsection st-block: Solid Block

This stone is movable and sinks on @ref{fl-abyss}, @ref{fl-water} and
@ref{fl-swamp}.


@node st-blocker
@subsection st-blocker: Shrinkable Blocker Stone

This stone shrinks to @ref{it-blocker} when hit by an
@ref{st-bolder} and vice versa.

@strong{Messages}

@table @code
@item trigger, openclose, open, close
shrink (open) / grow (close)
@item signal
1: shrink, 0: grow
@end table

Note that @code{st-blocker} becomes a new object when shrinking, so
that the messages @code{close} and @code{signal (0)} only make sense
during transformation.

@strong{Variants}

@table @code
@item st-blocker
@item st-blocker-growing
@end table


@node st-bolder
@subsection st-bolder: Bolder (or Arrow) Stone

This stone runs in the direction given by the arrow on its picture.
When a stone blocks its way, it triggers it (e.g. @ref{st-oxyd},
@ref{st-stoneimpulse}), marbles are shattered.

Bolder stones fall into @ref{fl-abyss}, but cross @ref{fl-water}
unchanged.  @ref{it-magicwand} and lasers reverse its direction.
@ref{st-rotator} changes its direction according to the rotators
direction.

@strong{Attributes}

@table @code
@item direction
@code{EAST}, @code{NORTH}, @code{SOUTH} or @code{WEST}
@end table

@strong{Messages}

@table @code
@item direction
Change direction to the direction in the second argument,
e.g. @code{SendMessage(mystone, "direction", WEST)}.
@end table

@strong{Variants}

@table @code
@item st-bolder
default direction is @code{NORTH}
@item st-bolder-w
@item st-bolder-s
@item st-bolder-e
@item st-bolder-n
@end table


@node st-bombs
@subsection st-bombs: Bombstones

When hit, @code{st-bombs} adds an @ref{it-blackbomb} to the
inventory.  It can be destroyed with explosions from
@ref{it-blackbomb}, @ref{it-whitebomb} and other bombstones (see
@ref{Breakable-Stones}).  When exploding, it ignites items below it. It
also ignites @ref{it-dynamite} beneath it, but not @code{it-blackbomb}
or @code{it-whitebomb}.

@c There are two more variants of @code{st-bombs}, that differ in that
@c they dispense @code{it-dynamite} and @code{it-whitebomb}:
@c @code{st-dynamite} and @code{st-whitebomb}

@strong{Messages}

@table @code
@item expl, bombstone
destroy stone
@end table

@c @strong{Variants}

@c @table @code
@c @item st-bombs
@c @item st-dynamite
@c @item st-whitebombs
@c @end table


@node st-brake
@subsection st-brake: Brake

This stone can be picked up as item @ref{it-brake}.  It can be used to
block @ref{st-bolder}.  It destroys @ref{it-blocker} and can itself be
destroyed by lasers and explosions from bombs (@ref{it-blackbomb},
@ref{it-whitebomb}).

@strong{Messages}

@table @code
@item expl
destroy stone
@end table


@node st-brick_magic
@subsection st-brick_magic: Magic Brick Stone

At first sight identical with @code{st-brick}, this stone becomes
transparent when hit with an @ref{it-magicwand}.


@node st-chameleon
@subsection st-chameleon: Chameleon Stone

This stone takes on the look of the floor beneath it.  Actors can
move through it, so these stones are perfect for hiding stuff under
them.  For solid, yet invisible stone-types see @ref{st-invisible}.


@node st-charge
@subsection st-charge: Charge Stones

When hit, the marble is provided with a constant electrostatic charge,
given by the @code{charge}-attribute of @code{st-charge}.  The charge
is confined to be between -1.0 and +1.0.  Actors with charges are
drawn together or pushed apart respectively, by a force given by
multiplication of their charges and the factor
@code{enigma.ElectricForce} (see @ref{Old API - Variables}) and divided by their
relative distance.

@strong{Attributes}

@table @code
@item charge
@end table

@strong{Variants}

@table @code
@item st-chargeplus
charge +1.0
@item st-chargeminus
charge -1.0
@item st-chargezero
charge 0.0
@end table


@node st-chess_[black/white]
@subsection st-chess_[black/white]: Chess (Knight) Stone

When hit, a chess stone makes a knight move: two steps in direction of
the hit plus one step in direction of the vertical velocity
component. @code{st-chess_black} can be moved only with the black
marble, @code{st-chess_white} only with the white. When there is a
chess stone of opposite color or a thief stone (@ref{st-thief}) at
the target position of a knight move, this stone is destroyed.

When hit with a magic wand (@ref{it-magicwand}), a chess stone changes
color.  Chess stones fall into @ref{fl-abyss} and sink in
@ref{fl-swamp}, but cross @ref{fl-water} undamaged.  They inactivate
@ref{fl-thief}.

Chess stones can't jump over or into fire (see @ref{The 1.0-Fire
System}).  At least, a chess knight is brave enough not to
panic when fire starts to burn beneath.  Note that fire can't ignite
the floor below an @code{st-chess_[black/white]}, in this context it
acts like an immovable stone.  In the same sense, they don't act on
impulses of @ref{st-stoneimpulse} or similar stones.

@strong{Attributes}

@table @code
@item color
0 for black, 1 for white
@item direction1, direction2
Used by the @code{move}-message
@end table

@strong{Messages}

@table @code
@item capture
Destroy stone with capture-animation.
@item flip
Change color.
@item move_[nne, nnw, wwn, wws, ssw, sse, ees, een]
Make a knight move.
@item move
Make a knight move defined by the attributes @code{direction1} (two
steps) and @code{direction2} (one step). You can use the @code{NORTH},
@code{SOUTH}, @code{EAST} and @code{WEST} constants for this.
@end table

@strong{Variants}

@table @code
@item st-chess_black
@item st-chess_white
@end table


@node st-coffee
@subsection st-coffee

This stone is non-transparent at first and becomes transparent and
movable when hit (@code{st-glass_move}). See @ref{st-fakeoxyda} for a
similar stone.


@node st-coinslot
@subsection st-coinslot

A switch that can be activated with coins (see @ref{it-coin}). The
more coins you put in, the longer the switch will stay activated.

@strong{Attributes}

@table @code
@item on
as usual
@item target, action
As usual
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@node st-death
@subsection st-death: Skull Stones

Simply kills all marbles that touch it (except when protected by an
@ref{it-umbrella}).

The invisible variant @code{st-death_invisible} becomes visible while
using @ref{it-glasses}.

@strong{Variants}

@table @code
@item st-death
@item st-death_invisible
@end table


@node st-disco
@subsection st-disco: Disco Stones

A passable stone, which darkens everything that is underneath the
stone (much like tinted glass).  Can be switched on and off (hence the
name).

When lightened or darkened, this stone also lightens and darkens
neighboring @code{st-disco}, such that the light on a passage can be
switched on and off just by sending a single message.

@strong{Messages}

@table @code
@item signal
With parameter 1, lighten the stone and (recursively) all neighboring
disco stones; with parameter smaller than 1, darken them.
@item lighten
@item darken
@end table

@strong{Variants}

@table @code
@item st-disco-light
@item st-disco-medium
@item st-disco-dark
@end table


@node st-door
@subsection st-door: Doors

Doors are designed to let actors pass or not, depending on their
internal state, which can be changed by triggers and other objects in
the game. There is a family of ``standard doors'' (referred to as
@code{st-door}-variants) and three single variants
(@code{st-door_a}, @code{st-door_b}, @code{st-door_c}), which differ
in design and behavior.

@code{st-door}-variants let actors and laser beams pass in all
directions when they are opened, and block those perpendicular to the
doors when @code{st-door} is closed. The other three have no
distinguished directions, they let actors and laser beams pass if, and
only if, they're open.

When an @code{st-door}-variant is hit, the item at the door's position
performs its @code{action/target}-pair (you can use all items for
this). There is nothing similar for the other variants.

@code{st-door}-variants do not hold @ref{it-trigger} down.

@strong{Attributes}

@table @code
@item type
@code{h} (horizontal) or @code{v} (vertical): only
@code{st-door}-variants.
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
0: close, 1: open
@end table

@strong{Variants}

@table @code
@item st-door
equals st-door-h
@item st-door-h
@item st-door-v
@item st-door-h-open
@item st-door-v-open
@item st-door_a
@item st-door_b
@item st-door_c
@end table

The first five all have the same design, the last three differ:
@code{st-door_a} looks like @ref{st-oxyd} of flavor @code{a} when
closed and like @code{st-grate} when open, @code{st-door_b} like
@code{st-plain} and shrinks when opened, @code{st-door_c} also like
@code{st-plain}, but @code{st-grate3} when opened.  Note that this is
just design; they don't behave the same way.


@node st-easymode
@subsection st-easymode: Easy Mode Stone

In easy game mode, this stone converts the floor at its position to
@code{fl-normal}.  In normal game mode, the stone removes any item at
its position.  The stone itself never appears in either game mode; it
removes itself immediately after performing its job.

This stone is commonly used to hide danger areas (water holes, abyss)
or to insert helper items (umbrellas, seeds, etc.) that make the level
easier in easy game mode.


@node st-explosion
@subsection st-explosion: Explosion Stone

This stone mimics an explosion when set, and destroys itself
afterwards.  Actors that contact it are shattered.


@node st-fakeoxyda
@subsection st-fakeoxyda: Movable Fake Oxyd Stone

This stone looks like an @ref{st-oxyd} of flavor @code{a}, yet it
transforms into the movable and transparent @code{st-glass1_move} when
hit. See @ref{st-coffee} for a similar stone.


@node st-fart
@subsection st-fart: Fart Stone

The fart stone has the unpleasant habit of ``blowing off'' when
triggered (by actor hit or signal) and will close all Oxyd stones.
It can be destroyed with lasers and @ref{it-hammer}, see also
@ref{Breakable-Stones}.

@strong{Messages}

@table @code
@item trigger
blow off
@end table


@node st-firebreak[_move]
@subsection st-firebreak[_move]: Firebreakable Stones

@code{st-firebreak} gets destroyed when there is fire near it (see
@ref{The 1.0-Fire System}). @code{st-firebreak_move} is movable and
gets destroyed when there is fire below it, just like
@ref{st-wood}. It falls into @ref{fl-water}, @ref{fl-abyss} and
@ref{fl-swamp} (if you need it not to fall, use @ref{fl-bridge}
instead).

@code{st-firebreak} and @code{st-firebreak_move} are the results of
@code{st-plain} and @code{st-plain_move} when using @ref{it-pencil} on
them (see @ref{st-plain}), and can be reverted again by using
@ref{it-brush}.

@strong{Messages}

@table @code
@item fire
@code{st-firebreak[_move]} breaks
@item heat
@code{st-firebreak} breaks
@end table

@strong{Variants}

@table @code
@item st-firebreak
@item st-firebreak_move
@end table


@node st-flash
@subsection st-flash: Flash Stone

When the flash stone is hit by the black marble, an impulse will
be given to the white marble as if it had been hit itself -- and vice
versa, when the white marble hits the flash stone.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 20)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@node st-floppy
@subsection st-floppy: Floppy Switch

A switch that is activated by inserting a floppy disk (see @ref{it-floppy}).

@strong{Attributes}

@table @code
@item on
1 or 0
@item target
@item action
@end table


@node st-fourswitch
@subsection st-fourswitch: Fourswitch

When hit, this stone visually turns its pointer and performs the
action given by the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item on
1: @code{EAST} or @code{WEST}, 0: @code{NORTH} or @code{SOUTH}
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item trigger, signal
turn as if hit with a marble
@end table

Note that no @code{direction}-attribute nor -message is implemented
yet.  When using the direction in a level, you have to count the hits
yourself: The stone always starts with direction @code{NORTH}.


@node st-grate
@subsection st-grate: Grates

Floating grates, mainly decorative.  @code{st-grate1} and
@code{st-grate2} block jumping marbles; all other actors may pass.  In
Oxyd compatibility mode, all actors may pass.  

@code{st-grate3} lets only small marbles (@ref{ac-killerball} and
@ref{ac-whiteball-small}) and @ref{ac-horse} pass. See
@ref{st-[black/white]} for other stones that let only some actors
pass.

@strong{Variants}

@table @code
@item st-grate1
@item st-grate2
@item st-grate3
@end table


@node st-invisible
@subsection st-invisible: Invisible Stones

@code{st-invisible} is invisible and non-transparent for lasers, and
is solid, in contrast to @ref{st-chameleon}.

@code{st-stonebrush} initially equals @code{st-invisible}, but
turns into @code{st-rock4} when hit with an @ref{it-brush},
respectively into @code{st-likeoxydc-open} in Per.Oxyd compatibility
mode.

@code{st-invisible_magic} is invisible and transparent for lasers, and
turns into @code{st-greenbrown} when touched with @ref{it-magicwand}.

@strong{Variants}

@table @code
@item st-invisible
@item st-invisible_magic
@item st-stonebrush
@end table


@node st-key
@subsection st-key: Key (or Lock) Stone

When the right @ref{it-key} is used on this stone, it performs the
action given by the @code{action/target}-pair.  For this, the key must
have the same @code{keycode}-attribute as the stone.

In Enigma compatibility mode, the key remains in the stone and can't
be used until removed from it. In all other modes, you keep the key.

@strong{Attributes}

@table @code
@item keycode
a numerical code determining the correct key
@item on
1: key used, 0: no key
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item st-key
@code{keycode} is 0
@item st-key_a
@code{keycode} is 1
@item st-key_b
@code{keycode} is 2
@item st-key_c
@code{keycode} is 3
@end table

Note that @code{it-key} and @code{st-key} do not match by defaults,
since the default keycodes are different.  Use @code{st-key_a}
instead.


@node st-knight
@subsection st-knight: Knight Stone

Also called ``black knight stone'', this stone destroys all marbles
that hit it, as long as they are not protected by @ref{it-umbrella}
or wield an @ref{it-sword}.  By hitting @code{st-knight} with an
@code{it-sword} four times, the knight stone spits out a cheeky remark
and can be passed thereafter, even without a sword.


@node st-laser
@subsection st-laser: Laser Stone

@code{st-laser} emits a laser beam in a specified direction while
activated.  Note that a laser stone starts deactivated, but you can
attach an @code{on=TRUE}-attribute to it to initialize it in an
activated state.

@strong{Attributes}

@table @code
@item on
@item dir
direction of the laser beam (use @code{SOUTH, EAST, NORTH, WEST}; read-only)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@end table

@strong{Variants}

@table @code
@item st-laser
standard direction is @code{EAST}
@item st-laser-w
@item st-laser-s
@item st-laser-e
@item st-laser-n
@end table

For redirecting and forking laser beams, see @ref{st-mirror}.


@node st-laserswitch
@subsection st-laserswitch: Laser Switch

This switch is @code{on} while hit by a laserbeam
and @code{off} when not hit by a laserbeam.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item inverse=1
Inverts the on/off state of the switch
(i.e @code{on} at startup and switch @code{off} with laserbeam)
@item target,action
as usual
@end table


@node st-lasertimeswitch
@subsection st-lasertimeswitch: Laser Time Switch

This switch is a mix between @ref{st-laserswitch} and @ref{st-timeswitch}.


@node st-lightpassenger
@subsection st-lightpassenger: Light Passenger

The light passenger skates on a laser beam, and may push up to one
movable stone in front of it. Opposing laser beams are ignored.
When another laser beam crosses the actual laser beam on which the
passenger skates, the passenger switches beams. If it is initially
lighted by two rectangular beams, one of them will be chosen by
random. The light passenger's skating ability can be turned off
and on.

When a stone is in its way, the passenger sends an impulse to the
blocking stone, which may move it, but it may also have other effects;
e.g., a turnstile turns around and an impulse-stone starts pulsing,
but it does not open oxyds (this is intended).

The light passenger can't be pushed by actors, but, e.g., by
@ref{st-stoneimpulse}.

The speed of the light passenger can be changed with the
@code{interval}-attribute (default 50 ms, which is quite fast) and may
include the floor friction and local gradient via
@code{friction_factor} (ff) and @code{gradient_factor} (gf).
The resulting interval results as

@example
interval  =  base * (1 + ff * friction) / (1 + gf * gradient)
@end example

with @code{base} the value of the @code{interval}-attribute,
@code{friction} the friction of the floor below the light passenger,
and @code{gradient} the parallel part of the force of the floor,
i.e., the sum of gradient-force and @code{force_x/y}-attributes.

The light passenger can be switched on and off by messages (see
below), and appears as @code{st-glass2} when inactive.  The variant
@code{st-lightpassenger_off} is deactivated from the beginning.

When an active @code{st-lightpassenger} is trapped between exactly two
opposing light beams or light beams from all four directions, it
starts blinking.  In this state, it can be destroyed with
@ref{it-hammer}.

@strong{Attributes}

@table @code
@item interval
overrides the standard speed of the light passenger
@item friction_factor
involves friction into the speed of the light passenger (sensible:
1.0, default 0.0)
@item gradient_factor
involves gradients into the speed of the light passenger (sensible:
0.02, default 0.0)
@end table

@strong{Messages}

@table @code
@item onoff, on, off, trigger
trigger between activated and deactivated (= no skating)
@item signal
with parameter 0: deactivating, else activating
@end table

@strong{Variants}

@table @code
@item st-lightpassenger
@item st-lightpassenger_off
@end table


@node st-mail
@subsection st-mail: Mail Stones

When hit, these stones take the first item out of the player's
inventory and drop it at their exit, or the exit of the appending
@ref{it-pipe}-structure. If this position is blocked (e.g., by another
item), no item is taken from inventory.

@strong{Variants}

@table @code
@item st-mail-w
@item st-mail-e
@item st-mail-s
@item st-mail-n
@end table


@node st-mirror
@subsection st-mirror: Mirror Stones

These stones redirect and fork laser beams. They can be movable or
non-movable, semi-transparent or non-transparent, plane or triangular,
and have one of four orientations.  When hit, the mirror turns 90
degrees clockwise.

@strong{Attributes}

@table @code
@item movable
@item transparent
@item orientation
@end table

@strong{Messages}

@table @code
@item trigger, turn
rotate clockwise
@item signal
0: do nothing, else: rotate clockwise
@item mirror-north, mirror-east, mirror-south, mirror-west
set orientation
@end table

@strong{Variants}

There is a total of 32 mirrors, the names are constructed in the
following way: Start with @code{st-mirror}. For a plane mirror, add
@code{p} and one of the orientations @code{|,/,-,\\} (the last one is
the backslash and has to be masked by doubling). For a triangular
mirror, instead add @code{3} and one of @code{v,<,>,^}. For a
semi-transparent mirror, add a @code{t}. Finally, for a movable
version, add an @code{m}.

Or, use @code{st-pmirror} and @code{st-3mirror} and set the attributes
accordingly, with defaults @code{/} or @code{v}, non-transparent and
non-movable.


@node st-oneway
@subsection st-oneway: One-way Stones

The marble can be pass this stone  in only one direction. (Or to
be more exact, the arrow on the stone points to the one side of the
stone through which it @emph{can't} be entered.  Hard to explain, try
it yourself :-)

There are three different variants of the one-way stone: the standard
one, @code{st-oneway}, which both the black and the white marble can
pass, and two colored ones, @code{st-oneway_black} and
@code{st-oneway_white}, which completely block marbles of the other
color.

When hit with an @ref{it-magicwand}, the standard @code{st-oneway}
flips its direction, the variants @code{st-oneway_black} and
@code{st-oneway_white} do not.

@strong{Attributes}

@table @code
@item orientation
One of @code{NORTH}, @code{EAST}, @code{SOUTH}, or @code{WEST}.  This
determines the orientation of the stone when the level is loaded.  You
need to use the @code{direction} message for changing the orientation
during the game.  Note that it is usually easier to use one of the
alternative names, like @code{st-oneway-north} instead of explicitly
setting this attribute.
@end table

@strong{Messages}

@table @code
@item direction
Set the direction of the arrow during the game.  Simply setting the
attribute @code{orientation} is not enough, since this does not update
the stone's model on the screen.
@item signal, flip
Both these messages flip the direction of the arrow.
@end table

@strong{Variants}

@table @code
@item st-oneway
@item st-oneway-[nesw]
@item st-oneway_black
@item st-oneway_black-[nesw]
@item st-oneway_white
@item st-oneway_white-[nesw]
@end table


@node st-oxyd
@subsection st-oxyd: Oxyd Stones

Oxyd stones are characterized by two attributes: Their flavor and
their color.  The @code{flavor} only affects the visual representation
of the stone; it can be either `a' (opening like a flower), `b'
(displaying a fade-in animation), `c', or `d'.  The @code{color}
attribute determines the color on the oxyd stone.  The @code{static}
attribute declares the oxyd stone to be unswappable/unpullable (see
@ref{st-swap} and @ref{st-pull}).

@strong{Note}: You should rarely need to create oxyd stones manually
with @ref{set_stone}.  Use the predefined @ref{oxyd} function
instead.  It will automatically take care of creating two oxyd stones
of every color.

@strong{Attributes}

@table @code
@item flavor
`a', `b', `c', or `d'
@item color
a number between 0 and 7
@item static
@code{true}, @code{false} (default) - static oxyds may not be swapped
or pulled
@end table

@strong{Messages}

@table @code
@item closeall
Close all oxyd stones.
@item shuffle
Interchange the colors of the oxyd stones in the current
landscape. Better use the @ref{oxyd_shuffle} function.
@item trigger
Open the stone (useful for opening oxyd stones using switches)
@end table


@node st-plain
@subsection st-plain: Plain Stones

@code{st-plain} and @code{st-plain_hole} trigger between solid and
hollow when they receive a @code{trigger}- or @code{signal}-message.

The solid version additionally becomes @code{st-plain_cracked} when hit
by a laser beam and can then be destroyed with an @ref{it-hammer} or
explosions (see @ref{Breakable-Stones}).  The hollow version is
transparent to lasers.  Note that @code{st-plain_cracked} doesn't
become transparent or hollow by messages.

@code{st-plain_move} is a movable and breakable stone (see
@ref{Breakable-Stones}) that looks identical to @code{st-plain}. It
falls into @ref{fl-abyss}, @ref{fl-water} and @ref{fl-swamp}, but only
when moved. @code{st-plain_move} and @code{st-plain} can be
transformed into @ref{st-firebreak[_move]} with @ref{it-pencil}, and
get reverted by @ref{it-brush}.

As @code{st-plain} is a frequent design scheme, you might want to use
a version that doesn't transform under laser light.  For this purpose,
use @code{st-rock3} or one of the closed doors @code{st-door_b} or
@code{st-door_c} (see @ref{st-door}).  Other stones with the typical
@code{st-plain}-design are @ref{st-chess_[black/white]} and the
already mentioned @code{st-firebreak[_move]}.

@strong{Messages}

@table @code
@item trigger, signal
switch between solid and hollow
@end table

@strong{Variants}

@table @code
@item st-plain
@item st-plain_hole
@end table

Note that there are more stones starting with ``st-plain'', but none
of them has the ability to trigger between solid and hollow:
@code{st-plain_move}, @code{st-plain_breaking},
@code{st-plain_falling}, @code{st-plain_break} and
@code{st-plain-cracked}.  See @ref{Breakable-Stones} for them, and
@ref{st-door} for stones with similar functions like @code{st-plain}.


@node st-polarswitch
@subsection st-polarswitch: Light Switch

When hit, this stone changes transparency for laser
beams. It uses the same graphics as @code{st-glass1} and 
@code{st-glass2}. By default, it is non-transparent.

Attributes and messages are equivalent to those of switches:

@strong{Attributes}

@table @code
@item on
1 (transparent) or 0 (non-transparent)
@end table

@strong{Messages}

@table @code
@item signal
1 (lighten) or 0 (darken)
@item on, off, onoff
on = lighten, off = darken, onoff = toggle
@end table


@node st-pull
@subsection st-pull: Pull Stone

When pushed, this stone acts like pulled, regardless of the source of
the impulse.  Actors on the destination field are pulled through it,
not caged under them.  Hollow stones on the
position of the actor exchange their position with the pull-stone.
Note however, that the special combination of @ref{st-brake} and
@code{st-pull} is lethal for the marble.

The only stones that cannot be pulled, are
@ref{st-big[brick/bluesand]}.  Use them to make sure that an
@code{st-pull} can't get out of a restricted area when you use, e.g.,
@ref{st-rotator} or other objects that @code{st-pull} reacts on.
In addition, you can declare @ref{st-oxyd} to be unswappable by
attribute @code{static}.

Note that, in non-Enigma-modes, @code{st-pull} may not get pulled into
the border of the level.  This behavior might change in future
versions.

For a stone with similar function and restrictions, see @ref{st-swap}.
 

@node st-puzzle
@subsection st-puzzle: Puzzle Stones

Puzzle stones can construct large clusters of stones, that move
together and can be destroyed together.  There are two families, blue
and yellow puzzle stones, which behave different (the yellow ones are
compatible to the puzzle stones in the original Oxyd-game). Each of
these families again consists of several variants that differ in the
location of sockets to which neighboring puzzle stones can be
attached.  A cluster is complete as soon as all sockets are connected
to sockets of other puzzle stones of the same color.

Laser beams make all complete puzzle clusters explode. Besides this,
yellow, incomplete puzzle cluster rotate on a laser beam (means: the
lightened row or column rotates by one stone position).  Incomplete
blue clusters don't react on lasers. 

If a complete cluster is moved fully onto a combination of
@ref{fl-water} and @ref{fl-abyss}, it becomes a bridge of
@code{fl-gray}, similar to @ref{st-wood}.  An incomplete cluster
forms a bridge only on @ref{fl-water}, and only if the wielded item
is not @ref{it-magicwand}.  Note that in contrast to @code{st-wood},
puzzle stones become bridges only after they are moved' they don't
react on changing the floor.

There also is a single hollow variant for each of the two colors,
@code{st-puzzle-hollow} and @code{st-puzzle2-hollow}.  It acts as if
it had sockets to all four directions, but is still hollow.  However,
these stones are the only hollow ones that press down
@ref{it-trigger}. 

When an actor hits:
@itemize @bullet
@item a yellow complete cluster, it explodes;
@item a single yellow puzzle stone, it moves;
@item a yellow incomplete cluster, it rotates;
@item a blue complete cluster with @code{it-magicwand}, it explodes;
@item a blue complete cluster without @code{it-magicwand}, it moves;
@item a blue incomplete cluster with @code{it-magicwand}, it rotates.
@end itemize
Note that an exploding cluster can shatter the marble.

In the current implementation, moving a puzzle stone over an item
doesn't change it.  This affects, e.g., @ref{it-coin} (that don't
transform), @ref{Hills and Hollows} (that don't diminish),
@ref{it-blackbomb} and @ref{it-whitebomb} (that don't explode).  Be
aware when using these items with @code{it-puzzle} that
future implementations of Enigma might change this behavior.


@strong{Messages}

@table @code
@item scramble
Internal message used to scramble a puzzle using secondary
information; use @ref{AddScramble} and @ref{SetScrambleIntensity} to
scramble a puzzle in a level instead or make use of one of the
libraries (@code{ant} and @code{libpuzzle} both offer this
possibility)
@end table

@strong{Attributes}

@table @code
@item connections
A number between 1 and 16.  Each bit in (connections-1) corresponds to
a socket on one of the four faces.  Normally, you will simply use
one of the Lua constants @code{PUZ_0000} to @code{PUZ_1111}.
@item oxyd
0, if the puzzle stone is blue; 1, if it is yellow
(@code{st-puzzle2-*})
@end table

@strong{Variants}

@table @code
@item st-puzzle-hollow
blue hollow puzzle stone
@item st-puzzle-<nesw>
blue solid puzzle stone
@item st-puzzle2-hollow
yellow hollow puzzle stone
@item st-puzzle2-<nesw>
yellow solid puzzle stone
@end table

The term @code{<nesw>} denotes all non-empty substrings of
@code{nesw}, describing the directions to which there are sockets on
the stone.  Examples: @code{st-puzzle-nw} is a blue puzzle stone with
connections going north and west, @code{st-puzzle2-esw} is a yellow
puzzle stone with connections to the east, south and west.

See @ref{st-big[brick/bluesand]} for other kinds of cluster-building
stones.


@node st-rotator
@subsection st-rotator: Rotator Stone

Rotator stones come in four flavors: Clockwise or counterclockwise
rotation, and movable or not movable.  They send impulses to
neighboring stones, thus pushing them in the direction given by the
rotation.  @ref{st-bolder} additionally change their direction to the
one they are pushed to.  @code{st-rotator} changes direction when hit
with an @ref{it-wrench} or by a laser beam.

@strong{Variants}

@table @code
@item st-rotator-right
@item st-rotator-left
@item st-rotator_move-right
@item st-rotator_move-left
@end table


@node st-rubberband
@subsection st-rubberband: Rubberband Stone

If hit by a marble, this stone first removes existing connections with
other stones, then attaches a new elastic between the
marble and itself.  Nothing happens if the marble was already attached
to this particular stone.

This stone can be moved if hit with a magic wand.

@strong{Attributes}

@table @code
@item length
The natural length of the rubberband (default: 1)
@item strength
The strength of the rubberband (default: 10)
@item minlength
The minimal length of the rubberband (default: 0)
@item scissor
Boolean value defining if already existing rubberbands to other Stones should be cut off.
(Default: true)
@end table


@node st-scissors
@subsection st-scissors: Scissors Stone

This stone cuts all rubber bands attached to an actor that touches it.
When at least one rubber band is cut, it performs the action given in
the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item target, action
as usual
@end table


@node st-shogun-<sml>
@subsection st-shogun-<sml>: Shogun Stones

These stones come in three basic variants: small (@code{s}), medium
(@code{m}) and large (@code{l}).  The smaller ones can be pushed into
bigger ones, forming combined forms denoted by combinations of @code{s},
@code{m} and @code{l}.  When hit, these combined stones split again
into the smaller ones.

The shogun stones trigger shogun items (see @ref{it-shogun}):  A
single @code{st-shogun-s} triggers @code{it-shogun-s}, a combined
@code{st-shogun-sm} triggers @code{it-shogun-m}, and the triplet
@code{st-shogun-sml} triggers @code{it-shogun-l}.

Shogun stones don't ignite bombs when pushed over them.

@code{st-shogun-s} is handled differently in a @ref{Freeze Checking} than
the other shogun stones. This allows to use @code{st-shogun-s} to use in a
Sokoban and avoids false freeze checks when used together with other shogun
stones (which are handled as non-existent during a freeze check).

@strong{Attributes}

@table @code
@item holes
between 1 and 7 (the three lower bits), used internally, thus
read-only
@end table


@node st-spitter
@subsection st-spitter: Spitter Stone

When hit, an @ref{it-extralife} from the inventory of the hitting
marble is transformed into a cannonball (@ref{ac-cannonball}) which
can open @ref{st-oxyd}, destroy items and floor tiles (replacing them
by @ref{fl-abyss}).  You can vary the initial velocity of the cannonball
by using the @code{hit_factor}- and
@code{hit_distortion_*}-attributes.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 1.0)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table


@node st-stoneimpulse
@subsection st-stoneimpulse: Impulse Stones

These stones send impulses to their neighbors when they receive such
themselves, or when hit by a laser beam (only when the laser beam is
turned on or changed, not the entire time).

@strong{Messages}

@table @code
@item trigger
Pulse as if pulse arrived from direction given in the second argument to
SendMessage (like in @code{SendMessage(mystone, "trigger",
NORTH}). Use @code{NODIR} if no direction shall be assumed.
@item signal
0: do nothing, else: start pulsing
@end table

@strong{Variants}

@table @code
@item st-stoneimpulse
@item st-stoneimpulse-hollow
not activated by lasers; blocks laser and may shatter actors while
pulsing
@item st-stoneimpulse_movable
movable version; pulses after move
@end table


@node st-surprise
@subsection st-surprise: Surprise Stone

When hit, this stone randomly transforms into one of @code{st-grate1},
@code{st-death}, @code{st-glass1_hole}, @code{st-magic},
@code{st-knight}, @code{st-thief}, @code{st-plain_break},
@code{st-plain_breaking}, or another @code{st-surprise}
(see @ref{st-grate}, @ref{st-death}, @ref{Oxyd Compatibility Stones},
@ref{st-knight}, @ref{st-thief}, and @ref{Breakable-Stones}). The corresponding
item is @ref{it-surprise}.


@node st-swap
@subsection st-swap: Swap Stone

This stone can exchange its position with other neighboring stones
if it is hit hard enough.  In a way, this makes swap stones a kind
of ``movable stone'', except that they can be exchanged only with
other stones and may not be moved on empty fields.

The only stones that cannot be swapped, are
@ref{st-big[brick/bluesand]}.  Use them to make sure that an
@code{st-swap} can't get out of a restricted area.  In addition, you
can declare @ref{st-oxyd} to be unswappable by attribute
@code{static}.

Note that, in non-Enigma-modes, @code{st-swap} may not swap into the
border of the level.  This behavior might change in future versions.

For a stone with similar function and restrictions, see @ref{st-pull}.


@node st-switch
@subsection st-switch: Switches

A simple switch. 

@strong{Attributes}

@table @code
@item on
1 (activate) or 0 (inactive)
@item target, action
as usual
@end table

@strong{Variants}

@table @code
@item st-switch
All kinds of objects can activate this switch.
@item st-switch_black
Only black marbles can activate this switch.
@item st-switch_white
Only white marbles can activate this switch.
@end table


@node st-thief
@subsection st-thief: Thief Stone

Takes one item from inventory shortly after hit by a player's marble.
@ref{it-umbrella} protects against thievery.

Thief stones can be destroyed with chess stones
(@ref{st-chess_[black/white]}).  They then leave an @ref{it-bag}
behind, filled with the stolen items.  If the tile is already occupied
by an item that could be picked up, it is added to the bag, if the item
couldn't be picked up, no bag is produced (you can use this to
suppress bag generation).

Compare with @code{fl-thief} (@ref{fl-thief}).

@strong{Messages}

@table @code
@item capture
Destroy the thief stone with capture-animation (as if captured by a chess
stone).
@end table


@node st-timer
@subsection st-timer: Timer Stone

This stone can be used to trigger periodic events or to trigger one
single event after a certain amount of time.  When triggering, it
performs its @code{action/target}-pair, the second data is 1 for every
odd activation, and 0 for every even one.

@strong{Attributes}

@table @code
@item on
1 if the timer is running (default: 1)
@item interval
number of seconds before @code{action} is performed (default: 1.0)
@item loop
If @code{true}, restart the timer after performing @code{action}, stop
on @code{false}. Note: This argument doesn't work in Enigma 1.01 or
older. (default: @code{true})
@item action, target
as usual
@item invisible
if 1, stone is invisible (default: 0)
@end table

@strong{Messages}
@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@strong{Example}

@example
-- activate a laser after 5 seconds
set_stone("st-laser", 10,11, @{name="laser"@})
set_stone("st-timer", 10,10,
          @{loop=0, action="onoff", target="laser", interval=5@})
@end example


@node st-timeswitch
@subsection st-timeswitch: Time Switch

When this switch is touched by an actor, it switches @code{on}
for 1.8 seconds and then switches @code{off} again.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item delay
The delay in seconds after which the switch goes @code{off}.
@item inverse=1
Inverts the on/off state of the switch.
@item action, target
as usual
@end table


@node st-turnstile
@subsection st-turnstile: Turnstiles

A turnstile consists of the pivot (@code{st-turnstile} or
@code{st-turnstile-green}) and up to four arms
(@code{st-turnstile-[w/e/s/n]}). When hit by an actor or by another
impulse (e.g., @ref{st-lightpassenger} or @ref{st-stoneimpulse}), the
whole complex turns 90 degrees.  The red standard version takes only
the actor hitting the turnstile, with it to the other side and shatters all
others in its surrounding; the green version takes all actors to the other
side, for which there is an arm behind them, and ignores the rest. Imagine the
red turnstile as pulling, the green one as pushing.  

The turnstile may be blocked by other stones (even movable ones).
Items are handled during rotation as if a stone is pushed over them.

When a turnstile-pivot rotates, it subsequently performs its
@code{action/target}-pair, with secondary data 0 if it rotates
clockwise, 1 if counterclockwise.  If you send a signal to a pivot (or
otherwise try to rotate it) that is already rotating, the signal
will be discarded.  This way you can concatenate several turnstiles to
a complex, which simultaneously rotates (or only in certain parts),
without constructing an endless loop.

When two green turnstiles are intertwined, one of them is hit and an actor would
be transported between them, then the second turnstile will be hit, too.

When an actor is to be warped outside of the level by a turnstile
(which only happens with a green one directly at the levelborder), the
actor is shattered instead of warped. This is the only case in which a
green turnstile is able to shatter a marble.

@strong{Messages to the pivot}

@table @code
@item signal
0: rotate clockwise, 1: rotate counterclockwise
@end table

@strong{Variants}

@table @code
@item st-turnstile
@item st-turnstile-green
@item st-turnstile-e
@item st-turnstile-s
@item st-turnstile-n
@item st-turnstile-w
@end table


@node st-volcano
@subsection st-volcano: Volcano

This stone duplicates itself and spreads out very fast.  During one
``life-cycle'', it starts as @code{it-seed_volcano} (see
@ref{it-seed}), grows as @code{st-volcano-growing} (during which it
shatters nearby marbles), becomes @code{st-volcano_active} when
mature, spreads new @code{it-seed_volcano} on neighboring tiles and
becomes inactive after some random time period.

Seeds are spread to randomly chosen neighboring tiles on which are no
other stones.  Other items are destroyed by this.

While active (not while growing or while inactive), a volcano
stone can be broken with @ref{it-hammer} (see @ref{Breakable-Stones}).

@strong{Messages}

@table @code
@item trigger
Makes an inactive stone active again.
@end table

@strong{Variants}

@table @code
@item st-volcano
starts inactive
@item st-volcano-growing
@item st-volcano_active
@item st-volcano_inactive
@end table

See also @ref{it-seed}.


@node st-window
@subsection st-window: Breakable Stone

Hit this window hard with your marble to blast it into smithereens.


@node st-wood
@subsection st-wood: Wooden Stone

This stone is movable.  If moved into @ref{fl-abyss}, @ref{fl-water} or
@ref{fl-swamp}, it builds a wooden plank (@code{fl-stwood1} or
@code{fl-stwood2}).  In Oxyd 1 compatibility mode @code{st-wood} only
checks for floor when it is moved or when it receives the message
``fall''.

Note: There are two flavors of @code{st-wood} that you may specify
by using @code{st-wood1} or @code{st-wood2}.

@code{st-wood-growing} is a growing version of @code{st-wood}, it
results from using a particular @ref{it-seed}.

@code{st-flhay} and @code{st-flrock} are movable, too, and create
@code{fl-hay}, respectively @code{fl-rock}, when moved into
@code{fl-abyss}, @code{fl-water} or @code{fl-swamp}.  The difference
to @code{st-wood} is that @code{fl-hay} doesn't become @code{fl-abyss}
when burning and @code{fl-rock} doesn't burn at all.

When there is fire under @code{st-wood} or @code{st-flhay}, they burn
away.  In contrast to this, @code{st-flrock} extinguishes fire as it
is pushed over it (see @ref{The 1.0-Fire System}).  This distinguishes
it from all other movable stones.  Fire that is extinguished in this
way might leave @code{it-burnable_ash} behind, but the floor does not
fire-transform.

@strong{Variants}

@table @code
@item st-wood
@item st-wood1
@item st-wood2
@item st-wood-growing
@item st-flrock
@item st-flhay
@end table


@node st-yinyang
@subsection st-yinyang: Yin-Yang Stones

Yin-Yang stones change into @code{st-white1} or @code{st-black1}
if you touch them (see @ref{st-[black/white]}).

Actors get stuck inside the Yin-Yang Stone if they are starting
there or when they warp there. They can be freed by changing the 
color of the Yin-Yang Stone to their color.

@strong{Variants}

There are several flavors of this stone:

@table @code
@item st-yinyang1       
If touched, it changes it's color to the opposite color of your marble.
@item st-yinyang2
If touched, it changes it's color to the same color as your marble.
@item st-yinyang3
The Per.Oxyd compatible: You must hold @ref{it-magicwand} or
@ref{it-brush} to change the color to the color opposite of your
marble.
@end table


@c ----------------------------------------------------------------------
@node Actors
@section Actors

@menu
* Actor Attributes::            Common attributes of actors
* ac-blackball::                Black Marble
* ac-bug::                      Bug
* ac-cannonball::               Cannonball
* ac-horse::                    Horse
* ac-killerball::               Small killer marble
* ac-rotor::                    Rotor
* ac-top::                      Spinning Top
* ac-whiteball::                White Marble
* ac-whiteball-small::          Meditation Marble
@end menu

Movable objects are called ``actors'' in Enigma.  The most common
actor is, of course, the black marble, but there are others, including
the white marble, the killerball and a few more:

@node Actor Attributes
@subsection Actor Attributes

All actors share a set of common attributes that determine their
general behavior:

@table @code
@item @b{player} values: 0, 1, nil; default: nil 
The player ``owning'' this actor.  This is either 0 or 1 for the first
or second player respectively.  Actors attached to a player can pick
up items and can be respawned when they are killed (same player means
same inventory).  Note: The controllers of the marble are given by the
@code{controllers}-attribute

@item @b{mouseforce} values: float; default: 1.0
A factor that determines how much the actor accelerates when the mouse
is moved.  Default is 1, use higher values for fast moving actors.  If
set to 0, the actor cannot be moved with the mouse (but external
forces can still exert a force on it).

@item @b{controllers} values: 0, 1, 2, 3
Determines which players may move this actor: 1=Player 0, 2=Player 1,
3=both, 0=none. By default, @code{ac-blackball}, @code{ac-whiteball} and
@code{ac-whiteball-small} have their @code{controllers} attribute set
to 1, 2, and 3 respectively. Use value 0 if you want a passive actor.

@item @b{essential} values: 0, 1, -1
Describes the necessity of an actor to be alive in case of multiple actors being
attached to a player. A value 0 marks an actor as not essential. The player
may well continue to play with other actors that he controls which are still
alive. A value of -1
marks an actor as totally necessary. If such an actor cannot be resurrected
after a death, the player is essentially dead. A value of 1 marks an actor as
partially essential. Not the actor itself needs to survive but the number of
actors of its kind controlled by the player need to be larger than the number
of actors with value 1. For example, marking 3 out of 5 small whiteballs with 1 means
that the player is dead if 3 small whiteballs are no longer alive. See 
@ref{Old API - Variables} @samp{enigma.ConserveLevel} for more details about restart of levels.

@item @b{essential_id} values: string; default: model name of actor
Since a player may control actors of different kinds at the same time, the 
essentialness of actors is limited to its kind via this id. It is possible
to group actors of different kinds into an essential group via this id. The
engine keeps this id even if actors are transformed into other kinds.

@item @b{whiteball}, @b{blackball} @i{deprecated}
@code{TRUE} or @code{FALSE}. Used by color-sensitive stones
(black/white switches for example) to determine whether the actor is
the black or the white marble.  These attributes may disappear in
future versions, please do not use them.
@end table


@node ac-blackball
@subsection ac-blackball

This is the most common actor.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 0.0)
@item blackball (default 1)
@item player (default 0)
@item controllers (default 1)
@end table


@node ac-bug
@subsection ac-bug

A small, passive marble.  It can be used to break @code{st-bug} (see
@ref{Breakable-Stones}), to pass @code{st-grate3} (see @ref{st-grate})
to open oxyds, etc.  It can't shatter or die.

@c @strong{Attributes}

@c @table @code
@c @end table


@node ac-cannonball
@subsection ac-cannonball

Used by @ref{st-spitter} as a cannon ball. Don't use in levels.


@node ac-horse
@subsection ac-horse

A slightly larger actor that shuttles between the targets given in
its @code{target1}- to @code{target4}- attributes with a given
@code{force}.  In future versions, it's planned that marbles can ride
@code{ac-horse} to surpass @ref{fl-abyss}, @ref{fl-water} etc.
@code{ac-horse} can pass @code{st-grate3} (see @ref{st-grate}), open
oxyds and much more, without shattering or dying.

@strong{Attributes}

@table @code
@item force (default 10.0)
@item target1
@item target2
@item target3
@item target4
@end table

@strong{Example}

The syntax of the @code{target}-attributes is a little bit
uncommon. Here is an example from the meditation @code{ral04_1}:

@example
set_actor("ac-horse",16.5, 6.5, @{force=6, target1="16 3",
    target2="3 3", target3="3 9", target4="16 9" @})
@end example

The attribute consists of a string, holding the x- and y-coordinates,
separated by a blank.  The @code{ac-horse} in the example shuttles
between the coordinates (16,3), (3,3), (3,9) and (16,9) on a
rectangular route.  Note that only four targets are allowed at
the moment.


@node ac-killerball
@subsection ac-killerball

A small marble, mostly controlled by the player, which shatters other
marbles.

@strong{Attributes}

@table @code
@item mouseforce (default 2.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@node ac-rotor
@subsection ac-rotor

An actor that is actively attracted by marbles and shatters them.
Compare @ref{ac-top}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls, the default behavior for rotors is to attack the
center of all balls. If this flag is set to @samp{TRUE}, the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelihood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behavior of rotors.
@end table

@node ac-top
@subsection ac-top

An actor that is actively attracted by marbles and shatters them.
Compare @ref{ac-rotor}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls, the default behavior for rotors is to attack the
center of all balls. If this flag is set to @samp{TRUE}, the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelihood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behavior of rotors.

@end table


@node ac-whiteball
@subsection ac-whiteball

This marble is mostly played by another player or via
@ref{it-yinyang}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item player (default 1)
@item controllers (default 2)
@end table


@node ac-whiteball-small
@subsection ac-whiteball-small

This is the meditation marble. In meditation levels, you must place
them in @code{it-hollow} or @code{it-tinyhollow} to win the level,
see @ref{Hills and Hollows}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@c ----------------------------------------------------------------------
@node General object attributes
@section General object attributes

@table @code
@item name
All objects may be given a @code{name} attribute. Such @emph{named objects} can
be searched using @ref{enigma.GetNamedObject}.
@end table

@c ----------------------------------------------------------------------
@node The 1.0-Fire System
@section The 1.0-Fire System

The 1.0-version of Enigma introduces a new fire system, making use of
attributes and messages of the floor tiles. The default fire, once
ignited, spreads over the landscape and destroys items, marbles and
some stones. It spreads along those floor tiles that are marked
``burnable'' by default (like @code{fl-hay} or @code{fl-wood1}), by
attribute (setting @code{enigma.SetAttrib(myfloor, "burnable", TRUE)}),
or by one of two items that indicate burnability: the invisible
@code{it-burnable} and the visible @code{it-burnable_oil}. On a
burning floor, all items are destroyed. However, some items prevent the
floor from burning, like @code{it-hollow} (see @ref{Hills and Hollows}) or
@ref{it-dynamite} (which is ignited instead).

Fire can be ignited in several standard ways:
@itemize @bullet
@item The @code{setfire}-message sets fire to a floor if it is
burnable and the item on it allows it to burn; non-burnable items like
@code{it-dynamite} are not ignited by this!
@item The @code{heat}-message ignites burnable floors as does
@code{setfire}, but also initiates a heat-transformation of the floor
(see below) and ignites items on it.
@item The @code{ignite} and @code{expl}-messages that are used by
@code{it-dynamite}, @ref{it-blackbomb} and @ref{it-whitebomb} can
initiate fire via @code{it-burnable[_oil]} or if the
@code{ignitable}-attribute of the floor is set (off by default).
@item The floor already starts burning on initialization when the
@code{initfire}-attribute is set (off by default).
@item Fire in the neighborhood, see below.
@end itemize

If needed, the @code{forcefire}-message can be used to set fire to
non-burnable floors. Internally, it is equivalent to manually setting
@code{it-burnable_ignited}, the last method (which was quite famous in
0.92) should be avoided in future, to allow a further development of
the fire-system.

Fire does the following:
@itemize @bullet
@item It kills @ref{st-wood} and @ref{st-firebreak[_move]} above it
(in case of @code{st-firebreak}: beneath it).
@item It heats its neighboring tiles, which might result in a
``heat-transform'' of the floor (see below).
@item It might ignite or destroy items on its neighbor, this concerns
@code{it-dynamite}, @code{it-blackbomb}, @code{it-whitebomb} and
@ref{it-crack}.
@item It might set fire to its neighbor.
@item It shatters marbles that are not protected with
@ref{it-umbrella}. Note that in future versions, jumping over
fire with @ref{it-spring[1/2/board]} might get allowed.
@end itemize

Fire stops burning after a random amount of time, as long as the
@code{eternal}-attribute of the floor is not set. When it stops
burning, it might replace the floor by another kind
(``fire-transform''), this is: Wooden floors are replaced by
@ref{fl-abyss}, leaves are replaced by @code{fl-dunes}. Finally, it
puts @code{it-burnable_ash} on the floor, which prohibits a second
fire and which can be removed with @ref{it-brush}. However, ash is not
set if the floor is @code{fl-abyss} or the @code{noash}-attribute is
set.

Since the spreading of fire is a random event, in 0.92, a level author
couldn't be sure that a particular item was ignited or fire was
set. In 1.0, these can be assured by setting the
@code{secure}-attribute: When a burnable floor with
@code{secure}-attribute is near fire, it will eventually catch fire,
items on it are ignited, etc.

In 0.92, there were two speeds of fire: When using @code{it-burnable},
fire spread much faster than without. This is still the same in
1.0. However, you can set the @code{fastfire}-attribute to hasten
the fire without setting the invisible @code{it-burnable}. 

Fire that burns under a stone is not allowed to spread; the only exceptions
are floating stones (as @ref{st-grate}), and those stones that
are destroyed by fire anyway (see @ref{st-wood}-variants and
@ref{st-firebreak[_move]}). In contrast to this, fire might also
spread to under a movable stone, but not further. 

You can stop fire with @code{it-extinguisher}, which creates the
fireproof @code{it-burnable_fireproof}. Another way to stop fire is to
push the totally inert @code{st-flrock} (see @ref{st-wood}) over
it: This is the only movable stone that doesn't allow fire under it. A
final way to stop fire is to send the @code{stopfire}-message to a
floor, which works the same way as @code{st-flrock}.

Compare with @ref{Fire and Extinguisher}.

@strong{Heat-Transformations}

When a fire starts to burn near @ref{fl-ice}, it melts to
@ref{fl-water}. In the same sense, @code{fl-water} boils to
@ref{fl-swamp}, and this again to @code{fl-dunes}. In contrast to most
other fire-related actions, this is not random, but always and only
happens, when a nearby fire starts to burn.

Examples: Put an @code{st-flrock} on @code{fl-ice}. A fire will melt
the ice, and @code{st-flrock} creates a fireproof and safe way to the
other side. If you use @ref{st-wood} instead, @code{fl-stwood} is
created, which presumably catches fire and leaves @code{fl-abyss}
behind. A similar combination is @code{fl-water} with
@ref{st-chess_[black/white]}.

If you want to suppress this transformation, you can switch to
a non-Enigma-compatibility-mode, see the following section.

@strong{Differences between 1.0 and 0.92}

The old fire system of Enigma versions up to 0.92, differs from
the 1.0 version mainly in the following points:

@itemize @bullet
@item no fire-transform except @code{fl-[st]wood} to @code{fl-abyss}
@item no heat-transformations
@item ash on fl-abyss
@item no difference between different floors
@item replication via same-floor-pattern instead of
burnable-floor-pattern: 0.92 didn't distinguish between burnable and
non-burnable floors. Instead, fire was allowed to spread to floors of
the same kind slowly.
@item burnable items always catch fire: In 1.0, a burnable item (except
for @code{it-burnable} and @code{it-burnable_oil} themselves) on an
non-burnable floor won't catch fire, in 0.92 it did.
@end itemize

A good model of the 0.92-system can be attained via the
compatibility-modes: All non-Enigma-modes (see @ref{Differences
between Compatibility Modes} and @ref{<compatibility>}) feature a
version which only marginally differs from 0.92-fire, yet allowing
some of the new achievements, like secure- or eternal-fire.

Note that in 0.92, fire-transformation happened at the beginning of
the fire, which manifested in the so called ``burning-abyss''-bug.
Besides other details, this is how the original 0.92 system differs from the
one in 1.0-non-Enigma-mode.

@strong{Burnable and Fireproof Floors}

The following floors are fireproof (they don't burn by default):
@code{fl-abyss*, fl-ac*, fl-black, fl-brick, fl-bridge*, fl-bumps,
fl-concrete, fl-dummy, fl-dunes, fl-gradient*, fl-gravel, fl-gray,
fl-himalaya, fl-ice*, fl-inverse, fl-inverse2, fl-darkgray, fl-metal*,
fl-mortar, fl-normal*, fl-rock, fl-sahara, fl-sand, fl-space*,
fl-springboard, fl-stone, fl-swamp, fl-water, fl-white}

The following floors are burnable: @code{fl-bluegray, fl-bluegreen*,
fl-hay, fl-light, fl-lightgray, fl-marble, fl-red, fl-rough*,
fl-tigris, fl-woven*, fl-trigger}

The following floors are burnable and leave @code{fl-dunes} behind:
@code{fl-leaves*}

The following floors are burnable and leave @code{fl-abyss} behind:
@code{fl-floor_001, fl-plank, fl-samba*, fl-stwood*, fl-wood*}

@strong{Fireproof Items}

Most items are passively burnable, this is: An item is destroyed by
fire, if and only if the floor could burn all by itself.  However,
there are some items with individual reactions (@code{it-burnable,
it-burnable_oil, it-dynamite, it-blackbomb, it-whitebomb, it-crack*})
and some items that are completely fireproof. These are:
@code{it-hollow, it-tinyhollow, it-hill, it-tinyhill, it-vortex*,
it-burnable_fireproof, it-burnable_ash, it-extinguisher,
it-extinguisher_medium, it-abyss}, all items of section @ref{System
and Debug Items} (@code{it-[1/2]pkillstone, it-bridge-oxyd*,
it-debris, it-dummy, it-easy[kill/keep]stone, it-explosion*,
it-oxyd5f, it-signalfilter[0/1]}) and the fire animations themselves:
@code{it-burnable_ignited} and @code{it-burnable_burning}.

Note that @code{it-extinguisher_empty, it-trigger} (visible and
invisible), @code{it-landmine}, @code{it-changefloor} and
@code{it-death} are passively burnable.  In particular,
@code{it-landmine} does not explode or create
@code{it-hollow} when burning. The reaction of @ref{it-sensor} and
@code{it-inversesensor} towards fire might be changed in future
versions.

If you need to save a passively burnable item from fire, simply set a
fireproof floor like @code{fl-sand} or @code{fl-rock} below it. This
normally is the case when using @ref{it-[h/v]strip} and
@ref{it-changefloor}. However, you can use the
@code{burnable}-attribute in these cases to force burnability of the
floors.


@c ----------------------------------------------------------------------
@node Freeze Checking
@section Freeze Checking

With Enigma 1.1 and above, you can use a special feature to support Sokoban
levels and Sokoban parts of levels: Whenever a movable stone is pushed into
some unmovable position, this feature automatically transforms the stone into
@ref{st-death}, to demonstrate that the game is lost and provide a simple way
for the player to restart.

The feature is called ``Freeze Checking''. It applies to each stone with
attribute @code{freeze_check = true} which is pushed onto a floor with
attribute @code{freeze_check = true}. This way you can restrict the freeze
check to a bounded area. For a true Sokoban the goal tiles should not be marked
with @code{freeze_check = true}, as a frozen box on a goal is not considered
harmful. On the other hand, you can specify which boxes are freeze-checked. This
gives further freedom to use other stones inside your Sokoban area: Floor and
stone both need the @code{freeze_check}-attribute activated.

The freeze check recognizes three basic constellations of stones that lead to a
freeze of a standard movable stone. With @code{B} as box (movable or
persistent) and @code{#} as wall (persistent):
@example
BB   #B   #B
BB    #    B#
@end example
There are more freeze constellations which are not recognized, the simplest
would be:
@example
#B
 BB
  #
@end example
Don't rely on this fact, it might be changed in future versions.

Please bear in mind: The freeze check is not intelligent. It can't foresee that
one of your functions might remove a stone, it can't foresee that some door
will never open up again (doors are considered as not existent), it doesn't
recognize when you put an @ref{it-puller}, @ref{it-cherry}, or @ref{st-swap} in
your level. It handles special stones in a way to minimize false-positive freeze
checks.

Floating stones (like @ref{st-grate}) create completely new frozen
constellations. From the following two examples, only the right example is
frozen (@code{G} is @code{st-grate1}):
@example
G    G
BB   BB
GB   GBG
@end example
At present, none of these are recognized as frozen by Enigma, floating stones
are considered as not existing during a freeze check. To demonstrate the
difficulty, you may analyze yourself which of the following constellations is
frozen:
@example
G      G      GBG   GB#    G G#G
B#    BBB     BB    GB G   BBBBB
G    #B B#   #B      G     G#G G
      G G     G
@end example

In some cases, stones are even handled differently although they have similar
properties: @ref{st-wood} and @code{st-firebreak_move} (see
@ref{st-firebreak[_move]}) are both movable and both destroyed by fire (see
@ref{The 1.0-Fire System}). There would never be frozen stones, as they can
easily be burned away. Yet, @code{st-wood} uses the default freeze checking,
whereas @code{st-firebreak_move} is considered as not existing. This is because
@code{st-wood} is often used without fire, whereas @code{st-firebreak_move} is
primarily used in combination with fire.

Another example is @code{st-shogun-s}, which is considered as a default
movable stone, in contrast to the remaining shogun stones (see
@ref{st-shogun-<sml>}). This way you can use @code{st-shogun-s} with goal
@code{it-shogun-s}, but don't have to fear false-positive freeze checks from
the non-standard way in which shogun stones move.

As a concluding remark, the freeze checking is to be used as a support for the
gamer only. It's not meant to be exploited as special feature to make movable
stones unmovable or to provide a way to jump back to the starting position. It
is subject to changes in future versions. And versions before 1.1 won't make a
freeze check at all - so you can't rely on it to happen. It should really be
used in Sokoban-kind parts of a level only, for which it is designed.


@c ----------------------------------------------------------------------
@node Differences between Compatibility Modes
@section Differences between Compatibility Modes

Although Enigma was inspired by the original Oxyd-series, there are
some differences between the current Enigma engine and the Oxyds as
well as between the Oxyds themselves. Using the compatibility-section
of the xml-metadata (see @ref{<compatibility>}) or the
@ref{enigma.SetCompatibility}-function, it's possible to activate some
of these behaviors. Here's a list of the currently implemented
differences, not all of them are mentioned at the corresponding
sections above: 

@strong{All non-Enigma modes @code{(oxyd1, per.oxyd, oxyd.magnum, oxyd.extra)}}

@itemize @bullet
@item Keep @ref{it-key} when using @ref{st-key}.
@item Oxyd-stones (@ref{st-oxyd}) must blink before they can be
ultimately opened (pairs must be hit with some time delay).
@item The non-Enigma modes feature a model of the 0.92-Fire System
(see @ref{The 1.0-Fire System}).
@item @ref{it-squashed} and @ref{it-cross} can't be removed with
@ref{it-brush}.
@item Only function of @ref{it-pencil} is to turn
@code{st-plain[_move]} into @code{st-firebreak[_move]}.
@item @ref{it-booze} doesn't break to @ref{it-booze-broken} when a
stone is pushed over it.
@item @ref{st-swap} and @ref{st-pull} may not swap/pull into the level
border.
@end itemize


@strong{@code{oxyd1}-compatibility}

@itemize @bullet
@item @ref{it-seed} grows to @code{fl-stwood} under @code{st-grate1}
(@ref{st-grate}), not to @ref{st-wood}.
@item Flying actors may pass @code{st-grate1} and @code{st-grate2}
(see @ref{st-grate}).
@item @ref{st-wood} only falls when moved.
@item The @code{ignite}-message (e.g. by @ref{it-dynamite}) doesn't
kill @ref{it-document}.
@item Bombs (@ref{it-blackbomb}, @ref{it-whitebomb}) aren't ignited
when @ref{st-wood} is pushed over them (see
@code{oxydmagnum}-compatibility).
@end itemize


@strong{@code{per.oxyd}-compatibility}

@itemize @bullet
@item When painted with @ref{it-brush}, @code{st-stonebrush} (see
@ref{st-invisible}) becomes @code{st-likeoxydc-open} instead of
@code{st-rock4}.
@item @ref{it-hammer} doesn't laser-transform into @ref{it-sword}.
@item @ref{it-umbrella} doesn't explode in laser light.
@item @ref{it-cross} inverts signals it receives.
@end itemize


@strong{@code{oxyd.magnum}-compatibility}

@itemize @bullet
@item @ref{it-seed} grows to @code{fl-stwood} under @code{st-grate1}
(@ref{st-grate}), not to @ref{st-wood}.
@item Bombs (@ref{it-blackbomb}, @ref{it-whitebomb}) aren't ignited
when @ref{st-wood} is pushed over them (see
@code{oxyd1}-compatibility).
@end itemize



@c ======================================================================
@node Old API - Variables
@chapter Old API - Variables

This chapter describes a few variables that you can change from
level descriptions to alter the behavior of the game engine or set
default attributes for some particular objects, or that carry
interesting information about the context of the level.  In the second
case, you can usually achieve the same effect by setting the
corresponding object attributes directly, but being able to specify a
global default value often is more convenient.  You can always
override these default attribute values for specific objects by
setting the appropriate object attributes.

@defvar enigma.ConserveLevel values: @code{TRUE}, @code{FALSE}; default: @code{TRUE} 
The conserve mode determines if a dead actor will be resurrected in case of
extralives in the gamer's inventory. 

If @code{TRUE}, dead actors attached to a
player will be resurrected as long as extralives are available. If a player has
no living actor to control or is missing the actor's essential constraints 
(@pxref{Actor Attributes}), the
player is dead. The level may still continue if a second player is alive. If
the gamer has a yinyang in his inventory in single user mode, the control switches
to the second player. If all players are dead, a new level game is started.

If the conserve mode is @code{FALSE}, no actors will be resurrected. As soon as the
player is dead and the control cannot switch to another player, all dead actors
are resurrected by using extralives, and the level is restarted without
finishing the level game.

Use @code{FALSE} if the level cannot be solved in case of resurrected actors.
In all other cases, mode @code{TRUE} with proper usage of actors essential 
constraints will be preferable (@pxref{Actor Attributes}).
@end defvar

@defvar enigma.CreatingPreview 
@code{TRUE} or @code{FALSE}, read-only.  Use this in a
level to determine whether it is just loaded to build a thumbnail.  If so, you can,
e.g., change the start-position of @ref{ac-blackball} to display
another part of the level in the preview, or hide objects from it.
When changing the initial position, it might be advantageous to also
set the follow-mode to smooth (@ref{display.SetFollowMode}):
@example
if enigma.CreatingPreview then
  display.SetFollowMode(display.FOLLOW_SMOOTH)
else
  display.SetFollowMode(@dots{})
end
@end example
@end defvar

@defvar enigma.Brittleness
A value between 0 and 1, denoting the probability that a brittle floor
plate disintegrates further when an actor enters or leaves it.  1
means that the floor will always crack, 0 that it is indestructible
(see @ref{it-crack}).  Default: 0.5.
@end defvar

@defvar enigma.BumperForce
The amount of force applied to an actor that hits an
@ref{st-actorimpulse} stone.
Default: 200.0.
@end defvar

@defvar enigma.ElectricForce
A force multiplier for all electric forces between actors,
see @ref{st-charge}.
Default: 15.0.
@end defvar

@defvar enigma.FrictionFactor
All friction forces are multiplied by this value.
Default: 1.0.
@end defvar

@defvar enigma.FlatForce
A global downward force.  This is currently only applied on floors of
type @ref{fl-space-force}, and obsolete since introduction of the
@code{force_[x/y]}-attributes.  Default: 0.
@end defvar

@defvar enigma.IceFriction
Friction of @ref{fl-ice} is multiplied with this constant. Default:
1.0.
@end defvar

@defvar enigma.HoleForce
A force factor that affects the steepness of hollows and hills (see
@ref{Hills and Hollows}).  Default: 1.0.
@end defvar

@defvar enigma.MagnetForce
A force multiplier for magnetic fields (see @ref{it-magnet}).
Default: 30.0.
@end defvar

@defvar enigma.MagnetRange
The range of magnetic fields (see @ref{it-magnet}).  Default: 10.0.
@end defvar

@defvar enigma.ShowMoves
@code{TRUE} or @code{FALSE}.  This is preferably used in Sokoban
levels to display a move counter in the inventory.
Default: @code{FALSE}.
@end defvar

@defvar enigma.SlopeForce
A force multiplier for sloped floor tiles (see @ref{fl-gradient}).
Default: 25.0.
@end defvar

@defvar enigma.WaterSinkSpeed
How quickly balls sink in @ref{fl-water}.  Default: 1000.0.
@end defvar

@defvar enigma.SwampSinkSpeed
How quickly balls sink in @ref{fl-swamp}.  Default: 4.0.
@end defvar

@defvar enigma.WormholeForce
A force multiplier for @ref{it-wormhole}.  Default: 30.0.
@end defvar

@defvar enigma.WormholeRange
The range of @ref{it-wormhole}.  Default: 10.0.
@end defvar


@node Old API - Functions
@chapter Old API - Functions

@menu
* AddRubberBand::               Creating rubber bands
* CreateWorld::                 Create the Level
* display.SetFollowMode::       Sets the follow mode
* draw_border::                 Drawing a border of stones
* draw_checkerboard_floor::     Draws a checkerboard
* draw_floor::                  Draws a line of floortiles
* draw_items::                  Draws a line of items
* draw_stones::                 Draws a line of stones
* enigma.AddConstantForce::     Add a constant force
* enigma.GetAttrib::            Get an objects attribute
* enigma.GetNamedObject::       Get an objects name 
* enigma.GetKind::              Get an objects kind
* enigma.KillFloor::            Kills a floortile
* enigma.KillItem::             Kills an item
* enigma.KillStone::            Kills a stone
* enigma.LoadLib::              Loading a not preloaded library
* enigma.NameObject::           Set the name of an object
* enigma.SetAttrib::            Set an attribute of an object
* enigma.SetAttribs::           Set multiple attributes of an object
* enigma.SetDefaultAttribs::    Set default attributes
* enigma.SetCompatibility::     Compability of a level
* fill_floor::                  Fills a rectangle with a floortile
* fill_items::                  Fills a rectangle with an item
* fill_stones::                 Fills a rectangle with a stone
* MakeObject::                  Creates an object
* SendMessage::                 Sending messages to objects
* set_floor::                   Set a single floortile
* set_item::                    Set a single item
* set_stone::                   Set a single stone
* set_stones::                  Set a list of stones


@end menu

@c ......................................................................
@node AddRubberBand
@section AddRubberBand

@defun AddRubberBand (actor, object, strength, length)

This function connects two objects with a rubber band: The first
object is always an actor, the second object can be either another
actor or a stone.

The first argument @var{actor} is always a reference to an actor
created earlier with the @code{set_actor} function.  The second
parameter @var{object} may be either an actor or a stone created
earlier.  The last two parameters define the properties of the rubber
band: @var{strength} denotes the force factor of the elastic, and
@var{length} denotes its natural length.  No force is exerted on the actor if
the rubber band is shorter than its natural length.

@end defun

@subsection Example

@example
local ac=set_actor("ac-blackball", 1.5,7.5)
local st=set_stone("st-brownie", 10,6)
AddRubberBand(ac, st, 50, 10)
@end example

@c ......................................................................
@node CreateWorld
@section CreateWorld

@defun CreateWorld (width, heigth)

This function creates a new level. Because objects can be added
to the level only after @code{CreateWorld} has been called,
you should usually do so near the beginning of your level
description.

The @var{width} and @var{height} denote the size of the new level.  All
levels with only one screen have the minimum size of 20x13 blocks.

Note that level fields are indexed from zero, i.e., the field indices
for a 20x13 level are in the range (0..19)x(0..12). Also note that the
screens in Enigma overlap by one line or column: A level that fits on
a single screen has size of 20x13, but two a level that is two screens
wide 39x13 or 20x25, three screens 58x13 or 20x37.
@end defun

@c ......................................................................
@node display.SetFollowMode
@section display.SetFollowMode

@defun display.SetFollowMode (mode)

This function sets the followmode of a level. The followmode defines the behavior
of the landscape if a level is bigger than one screen.

Possible values are:
@table @var
@item display.FOLLOW_NONE
Don't follow any sprite.
@item display.FOLLOW_SCROLLING
Scroll the screen.
@item display.FOLLOW_SCREEN
Flip the screen region.
@item display.FOLLOW_SCREENSCROLLING
Scroll to the next screen.
@item display.FOLLOW_SMOOTH
Follow pixel by pixel.
@end table

@end defun

@c ......................................................................
@node  draw_border
@section draw_border

@defun draw_border (stonename, x,y, w,h)

This function adds a border of stones to your level.  If invoked with
only one argument, this border encloses the whole level.

@table @var
@item stonename
The name of the border stone.
@item x,y
(optional) Coordinates of upper-left corner. (0,0) if omitted.
@item w,h
(optional) Width and height of border.
@end table

@end defun

@subsection Example

@example
draw_border("st-marble")
draw_border("st-greenbrown", 0,5,3,3)
@end example

@c ......................................................................
@node  draw_checkerboard_floor
@section draw_checkerboard_floor

@defun draw_checkerboard_floor (name1, name2, x, y, w, h, attribs)

This function draws checkerboard composed of two selected floor
types. @var{name1} and @var{name2} are names of floor objects. See
@ref{set_floor} for further details.

@table @var
@item name1, name2
Names of floor objects
@item x, y
Location of left top corner of checkerboard area. Note that upper left
map corner is [0,0].
@item w, h
Size of generated checkerboard.
@item attribs
Table of attribute names and corresponding values:
@code{@{attrib1=value1, attrib2=value2, @dots{}@}}. These attributes,
together with default attributes, are passed to each tile of the
generated checkerboard.
@end table

@end defun

@subsection Example

@example
draw_checkerboard_floor("fl-abyss", "fl-rough", 2, 2, 23, 11)
draw_checkerboard_floor("fl-normal", "fl-inverse", 0, 0, levelw, levelh) -- racetrack
@end example

@c ......................................................................
@node  draw_floor
@section draw_floor

@defun draw_floor (floorname, location, increment, count , attribs)

Description: Use this function to add several floor objects
to your level at periodic distances. How does it work? At first it
places the floor to location. Then it moves by
increment, and again places the given floor. And again and again
-- as many times as defined by count.
@table @var
@item Floorname 
Name of floor object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first floor object
@item Increment: Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis. Often this function is
used to add a row of floors in one direction, then
Increment looks like this: @{1,0@} or
@{0,1@}.
@item Count
Number of steps to proceed.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created floor. You can omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_floor("fl-abyss", @{3,0@}, @{0,1@}, level_height)
draw_floor("fl-gradient", @{15, 5@}, @{1,0@}, 4, @{type=1@})
draw_floor("fl-water", @{level_width-4,3@}, @{0,1@}, level_height-6)
@end example


@c ......................................................................
@node  draw_items
@section draw_items

@defun draw_items (itemname, location, increment, count [, attribs])

Description: This function adds several item
objects to your level at periodic distances. It works much like draw_floor,
except that it adds items instead of floors.
@table @var
@item Itemname
Name of item object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first item that you
want to add to map.
@item Increment: Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis.
@item Count
Number of steps to proceed.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created item. You may omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_items("it-trigger", @{3,3@}, @{2,0@}, 8)
draw_items("it-tinyhill", @{5,3@}, @{2,0@}, 7)
@end example

@c ......................................................................
@node  draw_stones
@section draw_stones

@defun draw_stones (stonename, location, increment, count [, attribs])

Description: This function adds several stones
to your level at periodic distances. It works much like draw_floor,
except that it adds stones instead of floors.
@table @var
@item Stonename
Name of stone object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first stone to be
placed to map.
@item Increment
Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis.
@item Count
Total number of stones to add.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created stone. You may omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_stones("st-grate1", @{9,1@},@{0,1@}, 5)
draw_stones("st-stone_break", @{21,1@}, @{1,0@}, 10)

function draw_border(stonename, x0, y0, w, h)
    draw_stones(stonename, @{x0,y0@}, @{1,0@}, w)
    draw_stones(stonename, @{x0,y0+h-1@},@{1,0@}, w)
    draw_stones(stonename, @{x0,y0@}, @{0,1@}, h)
    draw_stones(stonename, @{x0+w-1,y0@},@{0,1@}, h)
end
@end example

@c ......................................................................
@node enigma.AddConstantForce
@section enigma.AddConstantForce

@defun enigma.AddConstantForce (gravity_x, gravity_y)

Adds global gravity to the current level.

@table @var
@item gravity_x
adds gravity in horizontal direction (positive means rightwards).
@item gravity_y
adds gravity in vertical direction (positive means downwards).
@end table

@end defun

@c ......................................................................
@node enigma.GetAttrib
@section enigma.GetAttrib

@defun GetAttrib (object, attribname)

Description: The function is similar to SetAttrib, except
that it doesn't set the attribute, but returns current attribute
value. Function arguments have the same meaning as in
SetAttrib, see its description. Also note
GetKind.
@table @var
@end table

@end defun

@subsection Example

@example
local bolder_dir = GetAttrib(bolder1, "direction")
@end example

@c ......................................................................
@node enigma.GetNamedObject
@section enigma.GetNamedObject

@defun enigma.GetNamedObject (objname)

This function searches for an object that has a @code{name} attribute
with value @var{objname}.  It returns a reference to the object or
@code{nil} if none could be found.

@end defun

@subsection Example

@example
set_stone("st-wood", 7, 11, @{name="woodie"@})
@dots{}
local Woodie = enigma.GetNamedObject("woodie")
@end example

@c ......................................................................
@node enigma.GetKind
@section enigma.GetKind

@defun enigma.GetKind(object)

Description: This function returns the kind of an object.
@end defun

@subsection Example

@example
set_stone("st-wood", 7, 11)
@dots{}
local mystone=enigma.GetStone(7,11)
local mystonetype = enigma.GetKind(mystone)

mystonekind will be "st-wood"
@end example

@c ......................................................................
@node enigma.KillFloor
@section enigma.KillFloor

@defun enigma.KillFloor (x, y)

Kills the floor tile at position (x,y).

@table @var
@item x, y
Coordinates of the floortile to kill.
@end table

@end defun

@c ......................................................................
@node enigma.KillItem
@section enigma.KillItem

@defun enigma.KillItem (x, y)

Kills the item at position (x,y).

@table @var
@item x, y
Coordinates of the item to kill.
@end table

@end defun

@c ......................................................................
@node enigma.KillStone
@section enigma.KillStone

@defun enigma.KillStone (x, y)

Kills the stone tile at position (x,y).

@table @var
@item x, y
Coordinates of the stone to kill.
@end table

@end defun

@c ......................................................................
@node enigma.LoadLib
@section enigma.LoadLib

@defun enigma.LoadLib (libraryId)

This function loads a Lua level library that has previously been declared in
@ref{<compatibility>} at a given point of code execution. If the library is
declared with @samp{el:preload="true"}, no Lua function call is necessary.
The @var{libraryId} is the same as in the declaration. 
@end defun

@c ......................................................................
@node enigma.NameObject
@section enigma.NameObject

@defun enigma.NameObject (object, value)

Description: Gives the name value to object.

@table @var
@end table

@end defun

@c ......................................................................
@node enigma.SetAttrib
@section enigma.SetAttrib

@defun enigma.SetAttrib (object, attribname, value)

Description: The function sets the given attribute of a
given object to a given value. If you try to pass an unknown attribute to
an object, Enigma will ignore it (i.e., the value is assigned, but nothing
special happens).
@table @var
@item Object
The variable that holds the object. Every function
that creates an object returns the variable representing the freshly added
object. That's right, what should be passed to SetAttrib. (See example.)
@item Attribname
Name of the attribute. See the description of
objects to learn which object knows what attributes.
@item Value
New value of attribute.
@end table

@end defun

@subsection Examples

@example
local ls = set_stone("st-laser", 1, 4, @{on=FALSE, dir=NORTH@})
set_attrib(ls, "name", "laser")

-- (also "on" and "dir" are attributes in this example)
@end example

@c ......................................................................
@node enigma.SetAttribs
@section enigma.SetAttribs

@defun enigma.set_attribs (object, attribs)

Description: This function sets several attributes at a
time. The only thing it does is to call SetAttrib as many times as needed to set
values of all desired attributes.
@table @var
@item Object
Value that holds the object, whose attributes are
about to change.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
local ls = set_stone("st-laser", 1, 4, @{on=FALSE, dir=NORTH@})
@dots{} (some lua code) @dots{}
set_attribs(ls, @{on=TRUE, dir=WEST@})
@end example

@c ......................................................................
@node enigma.SetDefaultAttribs
@section enigma.SetDefaultAttribs

@defun enigma.SetDefaultAttribs (objectname, attribs)

Description: Use this function if there are several objects
of same kind, which have attributes (all or just some) with the same
value. For example, if there are twenty wormholes with strength of 10,
you can set the strength of 10 as a default value for all
wormholes.

Notes: Default attributes can be overridden or several extra
attributes can be assigned to an object. The attributes specified at
creation time (using set_floor, set_item, set_stone
functions) override the default attributes specified by
SetDefaultAttribs.
@table @var
@item Objname may be name of any Enigma stone, floor or
item. In most cases, this is a wormhole, because it's usual to have
several wormholes with the same strength and range, while it's not very
common to have, for example, all doors vertical or all bolders facing
west.
@item Attribs
Table of keys and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
SetDefaultAttribs("it-wormhole", @{range=1.0, strength=10@})
set_item("it-wormhole", 11, 6, @{targetx="48.5",targety="56.5"@})
@end example

@c ......................................................................
@node enigma.SetCompatibility
@section enigma.SetCompatibility

@defun enigma.SetCompatibility (compatibility)

This function sets the compatibility of a level. Because certain objects may have a different
behavior in the original Oxyd games, a compatibility mode exists for each game. Enigma itself
has also a compatibility mode, it's the default.

Note: This function is deprecated. Set the compatibility information in the 
xml-node @ref{<compatibility>} instead.

Possible values for compatibility are:
@table @var
@item oxyd1
Oxyd1-mode
@item per.oxyd
Per.Oxyd-mode
@item oxyd.magnum
OxydMagnum-mode
@item oxyd.extra
Oxydextra-mode
@item enigma
Enigma-mode

@end table

@end defun

@c ......................................................................
@node fill_floor
@section fill_floor

@defun fill_floor (floorname)
fill_floor (floorname, x, y, w, h)

Description: This function fills an area of map with a
selected floor type.
@table @var
@item Floorname
Name of the floor object. If this is the only argument to the function,
the whole map area is filled with this kind of floor.
@item x, y
Coordinates of upper left corner of filled area. Note
that the upper left square of map is at coordinates [0,0]. If those
arguments are omitted, zero is passed instead.
@item w, h
Size of the filled area. If any of these arguments is
omitted, level width or height respectively is passed by default.
@end table

@end defun

@subsection Examples

@example
fill_floor("fl-space", 0,0, level_width,level_height)  -- these two lines
fill_floor("fl-space")                                 -- do the same
fill_floor("fl-gray", 1, 1, level_width-2, level_height-2)
fill_floor("fl-water", 24,47, 11,1)
@end example

@c ......................................................................
@node fill_items
@section fill_items

@defun fill_items (itemname, x, y, w, h)

Description: This function fills an area of the map with
items of a selected kind.

Note: Please note that in contrast to function fill_floor, this function
doesn't have any default attributes, and no parameter may be omitted.

(strange, no one ever used this function in their map @enddots{})
@table @var
@item Itemname
Name of item object.
@item x, y
Coordinates of the upper left corner of the filled area. Note
that the upper left square of the map is at coordinates [0,0].
@item w, h
Size of the filled area - w is width and
h is height.
@end table

@end defun

@subsection Examples

@example
fill_items("it-wormhole", 1, 1, 3, 3) -- field of 3x3 wormholes
@end example

@c ......................................................................
@node fill_stones
@section fill_stones

@defun fill_stones (stonename, x, y, w, h)

Description: This function fills an area of the map with
stones of a selected kind.

Note: Please note that in contrast to function fill_floor,
this function doesn't have any default attributes, and no parameter may be omitted.
@table @var
@item Stonename
Name of stone object.
@item x, y
Coordinates of the upper left corner of the filled area. Note
that the upper left square of the map is at coordinates [0,0].
@item w, h
Size of filled area - w is width and h is height.
@end table

@end defun

@subsection Examples

@example
fill_stones("st-chameleon", 1, 1, 18, 11)
fill_stones("st-grate1", 1, 5, 5, 7)
fill_stones("st-death", 9, 5, 2, 2)
@end example

@c ......................................................................
@node  MakeObject
@section MakeObject

@defun MakeObject (objname, attribs)

Description: The function MakeObject is used internally by
other functions, like set_floor, set_item or
set_stone.
It takes care of creating the object and sets up all desired
attributes, including default ones
@table @var
@item Objname
Name of an internal Enigma object. It can be the name of
any floor, stone or item.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Example

@example
Example: To my best knowledge, no one uses this function in
their levels. You should instead use set_floor/stone/item functions for
creating particular Enigma objects. If you need this function, you are
probably a guru and you don't need this manual either.
@end example

@c ......................................................................
@node SendMessage
@section SendMessage

@defun SendMessage (object, message, data)

This function sends a @var{message} to an @var{object}.

@table @var
@item object
The recipient of the message.  Can be either the name of an object or a
reference as returned by @ref{enigma.GetNamedObject}.
@item message
The message itself (e.g. ``signal'') You can see which messages are
understood in the documentation of the particular @ref{Old API - Objects}.
@item data
Some specific messages expect some additional data (e.g., message
``direction'' expects a direction like SOUTH or WEST).
@end table

@end defun

@subsection Examples

@example
set_stone("st-laser-s", 2, 2, @{name="laser3", on=FALSE@})
@dots{}
SendMessage("laser3", "onoff")
@end example

@example
set_stone("st-bolder", 7, 11, @{name="bolder1", direction=SOUTH@})
@dots{}
SendMessage("bolder1", "direction", WEST)
@end example

@c ......................................................................
@node set_floor
@section set_floor

@defun set_floor (floorname, x, y, attribs)

Description: As you would expect, this function creates a
floor at a given [x,y] position in Enigma level, and passes all
necessary default attributes and
attributes passed in the attribs argument.
@table @var
@item Floorname
Enigma internal object name. The name should be
the name of the floor (they typically start with ``fl-'' prefix). Enigma
won't let you create a floor from another object, just from real floors.
@item x, y 
Location where you want the floor to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
function setup_gradient_rose(x,y)
   set_floor("fl-gradient", x, y+1, @{type=1@})
   set_floor("fl-gradient", x, y-1, @{type=2@})
   set_floor("fl-gradient", x+1, y, @{type=3@})
   set_floor("fl-gradient", x-1, y, @{type=4@})
end
@end example

@c ......................................................................
@node set_item
@section set_item

@defun set_item (itemname, x, y, attribs)

Description: This function is very similar to the one named
set_floor, described earlier. It creates an
item at a given position. Items in Enigma are all those magic wands,
brushes, coins, triggers, bombs and also, for example, the laser ray or
crackles. Only one single item can be on each position.

Note: The rule of single-item-per-field also means that a
laser cannot ``overshoot'' a magic wand or trigger, or that you cannot drop
an item to cracked floor, etc. It may look like a disadvantage, but on the
other hand, it can be used as an advantage (see, for example, the level
named ``Follow the Light'' in ``Oxyd Clones'' package).
@table @var
@item Itemname
Enigma internal object name. The name must be
the name of an item (they typically start with ``it-'' prefix). Enigma
won't let you create an item from another object, just from real items.
@item x, y
Location where you want the item to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
set_item("it-trigger", 34, 3, @{action="openclose", target="bridge1"@})
@end example

@c ......................................................................
@node set_stone
@section set_stone

@defun set_stone (stonename, x, y, attribs)

Description: This function is very similar to the one named
set_floor, describer earlier. It places the
stone to the desired location. Stones in Enigma are all walls, glass
blocks, death's heads, and also doors, switches, lasers, bolders and
lots of other special Enigma objects.
@table @var
@item Stonename
Enigma internal stone name. The name must be
the name of a stone (they typically start with ``st-'' prefix). Enigma
won't let you create a stone from another object, just from real stones.
@item x, y
Location where you want the stone to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
set_stone("st-door", 18,  6, @{name="door01", type="h"@})
set_stone("st-bolder", 2, 11, @{name="bolder01", direction=NORTH@})
@end example

@c ......................................................................
@node set_stones
@section set_stones

@defun set_stones (stonename, positions, attribs)

Description: This function is somehow similar to draw_stones.
It can place several stones in locations all over the map.
The locations to which the stones will be placed are listed in argument
positions.
@table @var
@item Stonename
Enigma internal stone name.
@item Positions
Table of stone locations. Its format is like this:
@{loc1, loc2, @dots{}@}, where each location is
@{x,y@}. Together it looks like this: @{@{x1,y1@}, @{x2,y2@},
@dots{}@}.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. Those attributes will
be passed to created stones together with default attributes. You may omit this
attribute.
@end table

@end defun

@subsection Examples

@example
set_stones("st-glass", @{@{1,6@},@{1,12@},@{34,1@},@{34,2@},@{35,2@},@{36,1@},@{36,2@}@})
set_stones(bordertile, @{@{34, 1@}, @{34, 5@}, @{34, 7@}, @{34, 11@}@})
@dots{}
set_stones("st-invisible", @{@{7,9@}@}) -- these two lines
set_stone("st-invisible", 7, 9)     -- do the same
@end example

@c ......................................................................

@node Object Index
@unnumbered Object Index

@printindex ob

@node Attribute Index
@unnumbered Attribute Index

@printindex at

@node Message Index
@unnumbered Message Index

@printindex ms

@node Function Index
@unnumbered Function Index

@syncodeindex vr tp
@syncodeindex fn tp

@printindex tp

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
